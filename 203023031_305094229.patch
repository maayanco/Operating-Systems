diff --git a/.nfs00000000038300e300000156 b/.nfs00000000038300e300000156
new file mode 100644
index 0000000000000000000000000000000000000000..bcc23a1abd747922baa5756652680ac02dc1d5bf
GIT binary patch
literal 1857
zcmY+E*HRQg6o$tUOD{}VmRxDAibY;v$vF;T$t*c9u)vbTlJOyY58uEC@Cm%;%7^gI
z{?43{V^_^r^UdGg)6>)4p69(8O6M}M)MffO)|cJS#1io;&-32;_hsMjfBwEY$uCSM
zf2DuqeXIMEn)Ez>)}@p}WG1}#o+8sK1;~`j2PCE9Bkqz?f=pN$S9we_W|L8sQj!sy
z3|kqplC(0YQcMQ}DsiOWCVe&uY|?9!9-DOAq)Vlot~*uaOFOKztH^NLRAe}<D$+rV
zZPRSqG}$(dDqnbMgNn>`y~;b1Iu#jCt;!RU8kP4*LPdUKwTkq{!l2Yrtunm#o*{9S
z8l*zyGg7XShm=L)mWn?MX23L<0x2*FCcrot1EXLB41*z%1cP7z^n*SSfL_o8x<MD{
z1RbCqw1HO80-8Y+Xao(Q9@K$aPy-U68dQNw5C;{YJdlql3uL#HMqeC0Ee)TR{QtBh
z42y%5+gyH;3qJ-aw_^R`s9wyKFy&ERnEvY}OqpOF`C*Mn=|cV<EhS@=?v+%yBXvb8
z+=lm_{I?qw`ES=MvU09$wM!K_4K7rQ==$8Y$=Nn%w#})P6BX&;SVdlXq#|QGw8?=@
z_HD9flU<u+ZL*^xpRjFZ%Sy(|ri$#i4V$c6Nn2S{k-1*AvZ5kq<+6%w%q10>gGH4D
z)4QM|qn=lhuIE%_&qt^AC)z}(wRG)PffU*E(P>@4+V~3Yz%94|*We0Vf(vjCa^MV{
zf)j8Ij=&)}0Q+DM?1C)V0oz~;WWXla0P7$P*1#%Q0n1<sEP@3v59WY5R>Ez<gg$rI
iBe%cURQL-#``|C}!v}wb=N|ku?ly1KJ|A~`DEJG-Kc(>i

literal 0
HcmV?d00001

diff --git a/2.txt b/2.txt
new file mode 100644
index 0000000..8d1c8b6
--- /dev/null
+++ b/2.txt
@@ -0,0 +1 @@
+ 
diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index c6159fe..5fdae56
--- a/Makefile
+++ b/Makefile
@@ -137,7 +137,7 @@ tags: $(OBJS) entryother.S _init
 vectors.S: vectors.pl
 	perl vectors.pl > vectors.S
 
-ULIB = ulib.o usys.o printf.o umalloc.o
+ULIB = ulib.o usys.o printf.o umalloc.o thread.o bsem.o csem.o
 
 _%: %.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
@@ -172,9 +172,13 @@ UPROGS=\
 	_rm\
 	_sh\
 	_stressfs\
-	_usertests\
 	_wc\
 	_zombie\
+	_thread\
+	_bsem\
+	_csem\
+	_sanity\
+	#_usertests\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/Notes b/Notes
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/TRICKS b/TRICKS
old mode 100644
new mode 100755
diff --git a/alarmTime b/alarmTime
new file mode 100644
index 0000000..af2c4b3
--- /dev/null
+++ b/alarmTime
@@ -0,0 +1,3495 @@
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+bsem.asm:  if(bp + bp->s.size == p->s.ptr){
+bsem.asm:    bp->s.size += p->s.ptr->s.size;
+bsem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+bsem.asm:    bp->s.ptr = p->s.ptr;
+bsem.asm:  if(p + p->s.size == bp){
+bsem.asm:    p->s.size += bp->s.size;
+bsem.asm:    p->s.ptr = bp->s.ptr;
+bsem.asm:    p->s.ptr = bp;
+bsem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+bsem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+bsem.asm:  if(bp + bp->s.size == p->s.ptr){
+bsem.asm:    bp->s.size += p->s.ptr->s.size;
+bsem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+bsem.asm:    bp->s.ptr = p->s.ptr;
+bsem.asm:  if(p + p->s.size == bp){
+bsem.asm:    p->s.size += bp->s.size;
+bsem.asm:    p->s.ptr = bp->s.ptr;
+bsem.asm:    p->s.ptr = bp;
+bsem.asm:    bp->s.size += p->s.ptr->s.size;
+bsem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+bsem.asm:    bp->s.ptr = p->s.ptr;
+bsem.asm:  if(p + p->s.size == bp){
+bsem.asm:    p->s.size += bp->s.size;
+bsem.asm:    p->s.ptr = bp->s.ptr;
+bsem.asm:    p->s.ptr = bp;
+bsem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+bsem.asm:    if(p->s.size >= nunits){
+bsem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+bsem.asm:    if(p->s.size >= nunits){
+bsem.asm:        p->s.size = nunits;
+bsem.asm:  hp->s.size = nu;
+bsem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+bsem.asm:    if(p->s.size >= nunits){
+bsem.asm:      if(p->s.size == nunits)
+bsem.asm:        prevp->s.ptr = p->s.ptr;
+bsem.asm:        p->s.size -= nunits;
+bsem.asm:        p += p->s.size;
+bsem.asm:        p->s.size = nunits;
+bsem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+bsem.asm:    if(p->s.size >= nunits){
+bsem.asm:      if(p->s.size == nunits)
+bsem.asm:        prevp->s.ptr = p->s.ptr;
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:cat.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:cat.asm:    bp->s.size += p->s.ptr->s.size;
+btf:cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:cat.asm:    bp->s.ptr = p->s.ptr;
+btf:cat.asm:  if(p + p->s.size == bp){
+btf:cat.asm:    p->s.size += bp->s.size;
+btf:cat.asm:    p->s.ptr = bp->s.ptr;
+btf:cat.asm:    p->s.ptr = bp;
+btf:cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:cat.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:cat.asm:    bp->s.size += p->s.ptr->s.size;
+btf:cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:cat.asm:    bp->s.ptr = p->s.ptr;
+btf:cat.asm:  if(p + p->s.size == bp){
+btf:cat.asm:    p->s.size += bp->s.size;
+btf:cat.asm:    p->s.ptr = bp->s.ptr;
+btf:cat.asm:    p->s.ptr = bp;
+btf:cat.asm:    bp->s.size += p->s.ptr->s.size;
+btf:cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:cat.asm:    bp->s.ptr = p->s.ptr;
+btf:cat.asm:  if(p + p->s.size == bp){
+btf:cat.asm:    p->s.size += bp->s.size;
+btf:cat.asm:    p->s.ptr = bp->s.ptr;
+btf:cat.asm:    p->s.ptr = bp;
+btf:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:cat.asm:    if(p->s.size >= nunits){
+btf:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:cat.asm:    if(p->s.size >= nunits){
+btf:cat.asm:        p->s.size = nunits;
+btf:cat.asm:  hp->s.size = nu;
+btf:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:cat.asm:    if(p->s.size >= nunits){
+btf:cat.asm:      if(p->s.size == nunits)
+btf:cat.asm:        prevp->s.ptr = p->s.ptr;
+btf:cat.asm:        p->s.size -= nunits;
+btf:cat.asm:        p += p->s.size;
+btf:cat.asm:        p->s.size = nunits;
+btf:cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:cat.asm:    if(p->s.size >= nunits){
+btf:cat.asm:      if(p->s.size == nunits)
+btf:cat.asm:        prevp->s.ptr = p->s.ptr;
+btf:cat.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:cat.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:echo.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:echo.asm:    bp->s.size += p->s.ptr->s.size;
+btf:echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:echo.asm:    bp->s.ptr = p->s.ptr;
+btf:echo.asm:  if(p + p->s.size == bp){
+btf:echo.asm:    p->s.size += bp->s.size;
+btf:echo.asm:    p->s.ptr = bp->s.ptr;
+btf:echo.asm:    p->s.ptr = bp;
+btf:echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:echo.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:echo.asm:    bp->s.size += p->s.ptr->s.size;
+btf:echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:echo.asm:    bp->s.ptr = p->s.ptr;
+btf:echo.asm:  if(p + p->s.size == bp){
+btf:echo.asm:    p->s.size += bp->s.size;
+btf:echo.asm:    p->s.ptr = bp->s.ptr;
+btf:echo.asm:    p->s.ptr = bp;
+btf:echo.asm:    bp->s.size += p->s.ptr->s.size;
+btf:echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:echo.asm:    bp->s.ptr = p->s.ptr;
+btf:echo.asm:  if(p + p->s.size == bp){
+btf:echo.asm:    p->s.size += bp->s.size;
+btf:echo.asm:    p->s.ptr = bp->s.ptr;
+btf:echo.asm:    p->s.ptr = bp;
+btf:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:echo.asm:    if(p->s.size >= nunits){
+btf:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:echo.asm:    if(p->s.size >= nunits){
+btf:echo.asm:        p->s.size = nunits;
+btf:echo.asm:  hp->s.size = nu;
+btf:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:echo.asm:    if(p->s.size >= nunits){
+btf:echo.asm:      if(p->s.size == nunits)
+btf:echo.asm:        prevp->s.ptr = p->s.ptr;
+btf:echo.asm:        p->s.size -= nunits;
+btf:echo.asm:        p += p->s.size;
+btf:echo.asm:        p->s.size = nunits;
+btf:echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:echo.asm:    if(p->s.size >= nunits){
+btf:echo.asm:      if(p->s.size == nunits)
+btf:echo.asm:        prevp->s.ptr = p->s.ptr;
+btf:echo.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:echo.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ex1.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ex1.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr;
+btf:ex1.asm:  if(p + p->s.size == bp){
+btf:ex1.asm:    p->s.size += bp->s.size;
+btf:ex1.asm:    p->s.ptr = bp->s.ptr;
+btf:ex1.asm:    p->s.ptr = bp;
+btf:ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ex1.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ex1.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr;
+btf:ex1.asm:  if(p + p->s.size == bp){
+btf:ex1.asm:    p->s.size += bp->s.size;
+btf:ex1.asm:    p->s.ptr = bp->s.ptr;
+btf:ex1.asm:    p->s.ptr = bp;
+btf:ex1.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ex1.asm:    bp->s.ptr = p->s.ptr;
+btf:ex1.asm:  if(p + p->s.size == bp){
+btf:ex1.asm:    p->s.size += bp->s.size;
+btf:ex1.asm:    p->s.ptr = bp->s.ptr;
+btf:ex1.asm:    p->s.ptr = bp;
+btf:ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ex1.asm:    if(p->s.size >= nunits){
+btf:ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ex1.asm:    if(p->s.size >= nunits){
+btf:ex1.asm:        p->s.size = nunits;
+btf:ex1.asm:  hp->s.size = nu;
+btf:ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ex1.asm:    if(p->s.size >= nunits){
+btf:ex1.asm:      if(p->s.size == nunits)
+btf:ex1.asm:        prevp->s.ptr = p->s.ptr;
+btf:ex1.asm:        p->s.size -= nunits;
+btf:ex1.asm:        p += p->s.size;
+btf:ex1.asm:        p->s.size = nunits;
+btf:ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ex1.asm:    if(p->s.size >= nunits){
+btf:ex1.asm:      if(p->s.size == nunits)
+btf:ex1.asm:        prevp->s.ptr = p->s.ptr;
+btf:ex1.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ex1.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:fs.c:  memmove(sb, bp->data, sizeof(*sb));
+btf:fs.c:  memset(bp->data, 0, BSIZE);
+btf:fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
+btf:fs.c:  if((bp->data[bi/8] & m) == 0)
+btf:fs.c:  bp->data[bi/8] &= ~m;
+btf:fs.c:// not stored on disk: ip->ref and ip->flags.
+btf:fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
+btf:fs.c://   is set in ip->flags. ilock() reads the inode from
+btf:fs.c://   I_VALID if ip->ref has fallen to zero.
+btf:fs.c://   ... examine and modify ip->xxx ...
+btf:fs.c:// pathname lookup. iget() increments ip->ref so that the inode
+btf:fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
+btf:fs.c:    if(dip->type == 0){  // a free inode
+btf:fs.c:      dip->type = type;
+btf:fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:fs.c:  dip->type = ip->type;
+btf:fs.c:  dip->major = ip->major;
+btf:fs.c:  dip->minor = ip->minor;
+btf:fs.c:  dip->nlink = ip->nlink;
+btf:fs.c:  dip->size = ip->size;
+btf:fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+btf:fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+btf:fs.c:      ip->ref++;
+btf:fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+btf:fs.c:  ip->dev = dev;
+btf:fs.c:  ip->inum = inum;
+btf:fs.c:  ip->ref = 1;
+btf:fs.c:  ip->flags = 0;
+btf:fs.c:  ip->ref++;
+btf:fs.c:  if(ip == 0 || ip->ref < 1)
+btf:fs.c:  acquiresleep(&ip->lock);
+btf:fs.c:  if(!(ip->flags & I_VALID)){
+btf:fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:fs.c:    ip->type = dip->type;
+btf:fs.c:    ip->major = dip->major;
+btf:fs.c:    ip->minor = dip->minor;
+btf:fs.c:    ip->nlink = dip->nlink;
+btf:fs.c:    ip->size = dip->size;
+btf:fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+btf:fs.c:    ip->flags |= I_VALID;
+btf:fs.c:    if(ip->type == 0)
+btf:fs.c:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+btf:fs.c:  releasesleep(&ip->lock);
+btf:fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+btf:fs.c:    ip->type = 0;
+btf:fs.c:    ip->flags = 0;
+btf:fs.c:  ip->ref--;
+btf:fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are
+btf:fs.c:// listed in block ip->addrs[NDIRECT].
+btf:fs.c:    if((addr = ip->addrs[bn]) == 0)
+btf:fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
+btf:fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
+btf:fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+btf:fs.c:    bp = bread(ip->dev, addr);
+btf:fs.c:    a = (uint*)bp->data;
+btf:fs.c:      a[bn] = addr = balloc(ip->dev);
+btf:fs.c:    if(ip->addrs[i]){
+btf:fs.c:      bfree(ip->dev, ip->addrs[i]);
+btf:fs.c:      ip->addrs[i] = 0;
+btf:fs.c:  if(ip->addrs[NDIRECT]){
+btf:fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+btf:fs.c:    a = (uint*)bp->data;
+btf:fs.c:        bfree(ip->dev, a[j]);
+btf:fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
+btf:fs.c:    ip->addrs[NDIRECT] = 0;
+btf:fs.c:  ip->size = 0;
+btf:fs.c:  st->dev = ip->dev;
+btf:fs.c:  st->ino = ip->inum;
+btf:fs.c:  st->type = ip->type;
+btf:fs.c:  st->nlink = ip->nlink;
+btf:fs.c:  st->size = ip->size;
+btf:fs.c:  if(ip->type == T_DEV){
+btf:fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+btf:fs.c:    return devsw[ip->major].read(ip, dst, n);
+btf:fs.c:  if(off > ip->size || off + n < off)
+btf:fs.c:  if(off + n > ip->size)
+btf:fs.c:    n = ip->size - off;
+btf:fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:fs.c:      cprintf("%x ", bp->data[off%BSIZE+j]);
+btf:fs.c:    memmove(dst, bp->data + off%BSIZE, m);
+btf:fs.c:  if(ip->type == T_DEV){
+btf:fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+btf:fs.c:    return devsw[ip->major].write(ip, src, n);
+btf:fs.c:  if(off > ip->size || off + n < off)
+btf:fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:fs.c:    memmove(bp->data + off%BSIZE, src, m);
+btf:fs.c:  if(n > 0 && off > ip->size){
+btf:fs.c:    ip->size = off;
+btf:fs.c:  if(dp->type != T_DIR)
+btf:fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:fs.c:      return iget(dp->dev, inum);
+btf:fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:fs.c:    if(ip->type != T_DIR){
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:grep.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:grep.asm:    bp->s.size += p->s.ptr->s.size;
+btf:grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:grep.asm:    bp->s.ptr = p->s.ptr;
+btf:grep.asm:  if(p + p->s.size == bp){
+btf:grep.asm:    p->s.size += bp->s.size;
+btf:grep.asm:    p->s.ptr = bp->s.ptr;
+btf:grep.asm:    p->s.ptr = bp;
+btf:grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:grep.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:grep.asm:    bp->s.size += p->s.ptr->s.size;
+btf:grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:grep.asm:    bp->s.ptr = p->s.ptr;
+btf:grep.asm:  if(p + p->s.size == bp){
+btf:grep.asm:    p->s.size += bp->s.size;
+btf:grep.asm:    p->s.ptr = bp->s.ptr;
+btf:grep.asm:    p->s.ptr = bp;
+btf:grep.asm:    bp->s.size += p->s.ptr->s.size;
+btf:grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:grep.asm:    bp->s.ptr = p->s.ptr;
+btf:grep.asm:  if(p + p->s.size == bp){
+btf:grep.asm:    p->s.size += bp->s.size;
+btf:grep.asm:    p->s.ptr = bp->s.ptr;
+btf:grep.asm:    p->s.ptr = bp;
+btf:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:grep.asm:    if(p->s.size >= nunits){
+btf:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:grep.asm:    if(p->s.size >= nunits){
+btf:grep.asm:        p->s.size = nunits;
+btf:grep.asm:  hp->s.size = nu;
+btf:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:grep.asm:    if(p->s.size >= nunits){
+btf:grep.asm:      if(p->s.size == nunits)
+btf:grep.asm:        prevp->s.ptr = p->s.ptr;
+btf:grep.asm:        p->s.size -= nunits;
+btf:grep.asm:        p += p->s.size;
+btf:grep.asm:        p->s.size = nunits;
+btf:grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:grep.asm:    if(p->s.size >= nunits){
+btf:grep.asm:      if(p->s.size == nunits)
+btf:grep.asm:        prevp->s.ptr = p->s.ptr;
+btf:grep.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:grep.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:init.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:init.asm:    bp->s.size += p->s.ptr->s.size;
+btf:init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:init.asm:    bp->s.ptr = p->s.ptr;
+btf:init.asm:  if(p + p->s.size == bp){
+btf:init.asm:    p->s.size += bp->s.size;
+btf:init.asm:    p->s.ptr = bp->s.ptr;
+btf:init.asm:    p->s.ptr = bp;
+btf:init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:init.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:init.asm:    bp->s.size += p->s.ptr->s.size;
+btf:init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:init.asm:    bp->s.ptr = p->s.ptr;
+btf:init.asm:  if(p + p->s.size == bp){
+btf:init.asm:    p->s.size += bp->s.size;
+btf:init.asm:    p->s.ptr = bp->s.ptr;
+btf:init.asm:    p->s.ptr = bp;
+btf:init.asm:    bp->s.size += p->s.ptr->s.size;
+btf:init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:init.asm:    bp->s.ptr = p->s.ptr;
+btf:init.asm:  if(p + p->s.size == bp){
+btf:init.asm:    p->s.size += bp->s.size;
+btf:init.asm:    p->s.ptr = bp->s.ptr;
+btf:init.asm:    p->s.ptr = bp;
+btf:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:init.asm:    if(p->s.size >= nunits){
+btf:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:init.asm:    if(p->s.size >= nunits){
+btf:init.asm:        p->s.size = nunits;
+btf:init.asm:  hp->s.size = nu;
+btf:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:init.asm:    if(p->s.size >= nunits){
+btf:init.asm:      if(p->s.size == nunits)
+btf:init.asm:        prevp->s.ptr = p->s.ptr;
+btf:init.asm:        p->s.size -= nunits;
+btf:init.asm:        p += p->s.size;
+btf:init.asm:        p->s.size = nunits;
+btf:init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:init.asm:    if(p->s.size >= nunits){
+btf:init.asm:      if(p->s.size == nunits)
+btf:init.asm:        prevp->s.ptr = p->s.ptr;
+btf:init.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:init.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+btf:kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
+btf:kernel.asm:  memset(bp->data, 0, BSIZE);
+btf:kernel.asm:  memset(bp->data, 0, BSIZE);
+btf:kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+btf:kernel.asm:      ip->ref++;
+btf:kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+btf:kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+btf:kernel.asm:      ip->ref++;
+btf:kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+btf:kernel.asm:      ip->ref++;
+btf:kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+btf:kernel.asm:      ip->ref++;
+btf:kernel.asm:  ip->ref = 1;
+btf:kernel.asm:  ip->flags = 0;
+btf:kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+btf:kernel.asm:  ip->dev = dev;
+btf:kernel.asm:  ip->inum = inum;
+btf:kernel.asm:  ip->ref = 1;
+btf:kernel.asm:  ip->flags = 0;
+btf:kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+btf:kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+btf:kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+btf:kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+btf:kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+btf:kernel.asm:    bp = bread(ip->dev, addr);
+btf:kernel.asm:    a = (uint*)bp->data;
+btf:kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+btf:kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+btf:kernel.asm:    bp = bread(ip->dev, addr);
+btf:kernel.asm:    a = (uint*)bp->data;
+btf:kernel.asm:      a[bn] = addr = balloc(ip->dev);
+btf:kernel.asm:    a = (uint*)bp->data;
+btf:kernel.asm:      a[bn] = addr = balloc(ip->dev);
+btf:kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+btf:kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+btf:kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+btf:kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+btf:kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+btf:kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+btf:kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+btf:kernel.asm:  if((bp->data[bi/8] & m) == 0)
+btf:kernel.asm:  if((bp->data[bi/8] & m) == 0)
+btf:kernel.asm:  bp->data[bi/8] &= ~m;
+btf:kernel.asm:  if((bp->data[bi/8] & m) == 0)
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:    if(dip->type == 0){  // a free inode
+btf:kernel.asm:      dip->type = type;
+btf:kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:  dip->type = ip->type;
+btf:kernel.asm:  dip->major = ip->major;
+btf:kernel.asm:  dip->minor = ip->minor;
+btf:kernel.asm:  dip->nlink = ip->nlink;
+btf:kernel.asm:  dip->size = ip->size;
+btf:kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:  dip->type = ip->type;
+btf:kernel.asm:  dip->major = ip->major;
+btf:kernel.asm:  dip->minor = ip->minor;
+btf:kernel.asm:  dip->nlink = ip->nlink;
+btf:kernel.asm:  dip->size = ip->size;
+btf:kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:  dip->type = ip->type;
+btf:kernel.asm:  dip->major = ip->major;
+btf:kernel.asm:  dip->minor = ip->minor;
+btf:kernel.asm:  dip->nlink = ip->nlink;
+btf:kernel.asm:  dip->size = ip->size;
+btf:kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:  dip->minor = ip->minor;
+btf:kernel.asm:  dip->nlink = ip->nlink;
+btf:kernel.asm:  dip->size = ip->size;
+btf:kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:  ip->ref++;
+btf:kernel.asm:  if(ip == 0 || ip->ref < 1)
+btf:kernel.asm:  acquiresleep(&ip->lock);
+btf:kernel.asm:  if(!(ip->flags & I_VALID)){
+btf:kernel.asm:    ip->flags |= I_VALID;
+btf:kernel.asm:    if(ip->type == 0)
+btf:kernel.asm:  acquiresleep(&ip->lock);
+btf:kernel.asm:  if(!(ip->flags & I_VALID)){
+btf:kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:  acquiresleep(&ip->lock);
+btf:kernel.asm:  if(!(ip->flags & I_VALID)){
+btf:kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:    ip->type = dip->type;
+btf:kernel.asm:    ip->major = dip->major;
+btf:kernel.asm:    ip->minor = dip->minor;
+btf:kernel.asm:    ip->nlink = dip->nlink;
+btf:kernel.asm:    ip->size = dip->size;
+btf:kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:  acquiresleep(&ip->lock);
+btf:kernel.asm:  if(!(ip->flags & I_VALID)){
+btf:kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+btf:kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+btf:kernel.asm:    ip->type = dip->type;
+btf:kernel.asm:    ip->major = dip->major;
+btf:kernel.asm:    ip->minor = dip->minor;
+btf:kernel.asm:    ip->nlink = dip->nlink;
+btf:kernel.asm:    ip->size = dip->size;
+btf:kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+btf:kernel.asm:    ip->flags |= I_VALID;
+btf:kernel.asm:    if(ip->type == 0)
+btf:kernel.asm:  if(ip == 0 || ip->ref < 1)
+btf:kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+btf:kernel.asm:  releasesleep(&ip->lock);
+btf:kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+btf:kernel.asm:  releasesleep(&ip->lock);
+btf:kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+btf:kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+btf:kernel.asm:    ip->type = 0;
+btf:kernel.asm:    ip->flags = 0;
+btf:kernel.asm:  ip->ref--;
+btf:kernel.asm:    ip->flags = 0;
+btf:kernel.asm:  ip->ref--;
+btf:kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+btf:kernel.asm:    if(ip->addrs[i]){
+btf:kernel.asm:      bfree(ip->dev, ip->addrs[i]);
+btf:kernel.asm:      ip->addrs[i] = 0;
+btf:kernel.asm:  if(ip->addrs[NDIRECT]){
+btf:kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+btf:kernel.asm:    ip->addrs[NDIRECT] = 0;
+btf:kernel.asm:  ip->size = 0;
+btf:kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+btf:kernel.asm:    ip->type = 0;
+btf:kernel.asm:    ip->flags = 0;
+btf:kernel.asm:      ip->addrs[i] = 0;
+btf:kernel.asm:  if(ip->addrs[NDIRECT]){
+btf:kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+btf:kernel.asm:    a = (uint*)bp->data;
+btf:kernel.asm:      ip->addrs[i] = 0;
+btf:kernel.asm:  if(ip->addrs[NDIRECT]){
+btf:kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+btf:kernel.asm:    a = (uint*)bp->data;
+btf:kernel.asm:        bfree(ip->dev, a[j]);
+btf:kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+btf:kernel.asm:    ip->addrs[NDIRECT] = 0;
+btf:kernel.asm:  st->dev = ip->dev;
+btf:kernel.asm:  st->ino = ip->inum;
+btf:kernel.asm:  st->type = ip->type;
+btf:kernel.asm:  st->nlink = ip->nlink;
+btf:kernel.asm:  st->size = ip->size;
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+btf:kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:  if(off + n > ip->size)
+btf:kernel.asm:    n = ip->size - off;
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+btf:kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+btf:kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+btf:kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+btf:kernel.asm:    return devsw[ip->major].write(ip, src, n);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+btf:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+btf:kernel.asm:  if(off > ip->size || off + n < off)
+btf:kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+btf:kernel.asm:  if(n > 0 && off > ip->size){
+btf:kernel.asm:    ip->size = off;
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+btf:kernel.asm:    return devsw[ip->major].write(ip, src, n);
+btf:kernel.asm:  if(n > 0 && off > ip->size){
+btf:kernel.asm:    ip->size = off;
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+btf:kernel.asm:    return devsw[ip->major].write(ip, src, n);
+btf:kernel.asm:  if(n > 0 && off > ip->size){
+btf:kernel.asm:    ip->size = off;
+btf:kernel.asm:  if(ip->type == T_DEV){
+btf:kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+btf:kernel.asm:  if(n > 0 && off > ip->size){
+btf:kernel.asm:    ip->size = off;
+btf:kernel.asm:  if(dp->type != T_DIR)
+btf:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:kernel.asm:      return iget(dp->dev, inum);
+btf:kernel.asm:      return iget(dp->dev, inum);
+btf:kernel.asm:  if(dp->type != T_DIR)
+btf:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:kernel.asm:  if(dp->type != T_DIR)
+btf:kernel.asm:  ip->ref++;
+btf:kernel.asm:    if(ip->type != T_DIR){
+btf:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+btf:kernel.asm://   modify bp->data[]
+btf:kernel.asm://   modify bp->data[]
+btf:kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+btf:kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+btf:kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+btf:kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+btf:kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+btf:kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+btf:kernel.asm:  if(mp->imcrp){
+btf:kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+btf:kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+btf:kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+btf:kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+btf:kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+btf:kernel.asm:  p->readopen = 1;
+btf:kernel.asm:  p->writeopen = 1;
+btf:kernel.asm:  p->nwrite = 0;
+btf:kernel.asm:  p->nread = 0;
+btf:kernel.asm:  initlock(&p->lock, "pipe");
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    p->writeopen = 0;
+btf:kernel.asm:    wakeup(&p->nread);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    p->writeopen = 0;
+btf:kernel.asm:    wakeup(&p->nread);
+btf:kernel.asm:    p->readopen = 0;
+btf:kernel.asm:    wakeup(&p->nwrite);
+btf:kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:    p->writeopen = 0;
+btf:kernel.asm:    wakeup(&p->nread);
+btf:kernel.asm:    p->readopen = 0;
+btf:kernel.asm:    wakeup(&p->nwrite);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    p->writeopen = 0;
+btf:kernel.asm:    wakeup(&p->nread);
+btf:kernel.asm:    p->readopen = 0;
+btf:kernel.asm:    wakeup(&p->nwrite);
+btf:kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:    p->readopen = 0;
+btf:kernel.asm:    wakeup(&p->nwrite);
+btf:kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+btf:kernel.asm:    release(&p->lock);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+btf:kernel.asm:      if(p->readopen == 0 || proc->killed){
+btf:kernel.asm:        release(&p->lock);
+btf:kernel.asm:      wakeup(&p->nread);
+btf:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+btf:kernel.asm:      wakeup(&p->nread);
+btf:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+btf:kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:      wakeup(&p->nread);
+btf:kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+btf:kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+btf:kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+btf:kernel.asm:      if(p->readopen == 0 || proc->killed){
+btf:kernel.asm:        release(&p->lock);
+btf:kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+btf:kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:  acquire(&p->lock);
+btf:kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+btf:kernel.asm:    if(p->nread == p->nwrite)
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+btf:kernel.asm:    if(p->nread == p->nwrite)
+btf:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:kernel.asm:      release(&p->lock);
+btf:kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+btf:kernel.asm:    if(p->nread == p->nwrite)
+btf:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+btf:kernel.asm:  release(&p->lock);
+btf:kernel.asm:    if(p->state == UNUSED)
+btf:kernel.asm:  p->state = EMBRYO;
+btf:kernel.asm:  p->alarmTime=-1;
+btf:kernel.asm:  p->pid = nextpid++;
+btf:kernel.asm:  p->state = EMBRYO;
+btf:kernel.asm:  p->alarmTime=-1;
+btf:kernel.asm:  p->pid = nextpid++;
+btf:kernel.asm:  p->state = EMBRYO;
+btf:kernel.asm:  p->alarmTime=-1;
+btf:kernel.asm:  p->pid = nextpid++;
+btf:kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+btf:kernel.asm:  p->alarmTime=-1;
+btf:kernel.asm:  p->pid = nextpid++;
+btf:kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+btf:kernel.asm:  if((p->kstack = kalloc()) == 0){
+btf:kernel.asm:  sp = p->kstack + KSTACKSIZE;
+btf:kernel.asm:  sp -= sizeof *p->tf;
+btf:kernel.asm:  sp -= sizeof *p->context;
+btf:kernel.asm:  sp = p->kstack + KSTACKSIZE;
+btf:kernel.asm:  sp -= sizeof *p->tf;
+btf:kernel.asm:  p->tf = (struct trapframe*)sp;
+btf:kernel.asm:  sp -= sizeof *p->context;
+btf:kernel.asm:  p->context = (struct context*)sp;
+btf:kernel.asm:  memset(p->context, 0, sizeof *p->context);
+btf:kernel.asm:  sp -= sizeof *p->context;
+btf:kernel.asm:  p->context = (struct context*)sp;
+btf:kernel.asm:  memset(p->context, 0, sizeof *p->context);
+btf:kernel.asm:  p->context->eip = (uint)forkret;
+btf:kernel.asm:    if(p->state == UNUSED)
+btf:kernel.asm:  p->context = (struct context*)sp;
+btf:kernel.asm:  memset(p->context, 0, sizeof *p->context);
+btf:kernel.asm:  p->context->eip = (uint)forkret;
+btf:kernel.asm:    if(p->state == UNUSED)
+btf:kernel.asm:  p->context = (struct context*)sp;
+btf:kernel.asm:  memset(p->context, 0, sizeof *p->context);
+btf:kernel.asm:  p->context->eip = (uint)forkret;
+btf:kernel.asm:  if((p->kstack = kalloc()) == 0){
+btf:kernel.asm:    p->state = UNUSED;
+btf:kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+btf:kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+btf:kernel.asm:  p->sz = PGSIZE;
+btf:kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+btf:kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+btf:kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+btf:kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+btf:kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+btf:kernel.asm:  p->sz = PGSIZE;
+btf:kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+btf:kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+btf:kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+btf:kernel.asm:  p->tf->es = p->tf->ds;
+btf:kernel.asm:  p->tf->ss = p->tf->ds;
+btf:kernel.asm:  p->tf->eflags = FL_IF;
+btf:kernel.asm:  p->tf->esp = PGSIZE;
+btf:kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
+btf:kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
+btf:kernel.asm:  p->cwd = namei("/");
+btf:kernel.asm:  // this assignment to p->state lets other cores
+btf:kernel.asm:  p->state = RUNNABLE;
+btf:kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+btf:kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+btf:kernel.asm:    kfree(np->kstack);
+btf:kernel.asm:    np->kstack = 0;
+btf:kernel.asm:    np->state = UNUSED;
+btf:kernel.asm:  np->sz = proc->sz;
+btf:kernel.asm:  np->parent = proc;
+btf:kernel.asm:  *np->tf = *proc->tf;
+btf:kernel.asm:    kfree(np->kstack);
+btf:kernel.asm:    np->kstack = 0;
+btf:kernel.asm:    np->state = UNUSED;
+btf:kernel.asm:  np->sz = proc->sz;
+btf:kernel.asm:  np->parent = proc;
+btf:kernel.asm:  *np->tf = *proc->tf;
+btf:kernel.asm:  np->tf->eax = 0;
+btf:kernel.asm:  np->sz = proc->sz;
+btf:kernel.asm:  np->parent = proc;
+btf:kernel.asm:  *np->tf = *proc->tf;
+btf:kernel.asm:  np->tf->eax = 0;
+btf:kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+btf:kernel.asm:  *np->tf = *proc->tf;
+btf:kernel.asm:  np->tf->eax = 0;
+btf:kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+btf:kernel.asm:  np->cwd = idup(proc->cwd);
+btf:kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+btf:kernel.asm:  pid = np->pid;
+btf:kernel.asm:  np->state = RUNNABLE;
+btf:kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+btf:kernel.asm:    kfree(np->kstack);
+btf:kernel.asm:    np->kstack = 0;
+btf:kernel.asm:    np->state = UNUSED;
+btf:kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+btf:kernel.asm:    kfree(np->kstack);
+btf:kernel.asm:    np->kstack = 0;
+btf:kernel.asm:    np->state = UNUSED;
+btf:kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+btf:kernel.asm:      p->state = RUNNABLE;
+btf:kernel.asm:    if(p->parent == proc){
+btf:kernel.asm:      p->parent = initproc;
+btf:kernel.asm:    if(p->parent == proc){
+btf:kernel.asm:      p->parent = initproc;
+btf:kernel.asm:      if(p->state == ZOMBIE)
+btf:kernel.asm:    if(p->parent == proc){
+btf:kernel.asm:      p->parent = initproc;
+btf:kernel.asm:      if(p->state == ZOMBIE)
+btf:kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+btf:kernel.asm:      p->state = RUNNABLE;
+btf:kernel.asm:  // change p->state and then call sched.
+btf:kernel.asm:      if(p->parent != proc)
+btf:kernel.asm:      if(p->state == ZOMBIE){
+btf:kernel.asm:      if(p->parent != proc)
+btf:kernel.asm:      if(p->state == ZOMBIE){
+btf:kernel.asm:        pid = p->pid;
+btf:kernel.asm:        kfree(p->kstack);
+btf:kernel.asm:      if(p->parent != proc)
+btf:kernel.asm:      if(p->state == ZOMBIE){
+btf:kernel.asm:        pid = p->pid;
+btf:kernel.asm:        kfree(p->kstack);
+btf:kernel.asm:        p->kstack = 0;
+btf:kernel.asm:        freevm(p->pgdir);
+btf:kernel.asm:      if(p->state == ZOMBIE){
+btf:kernel.asm:        pid = p->pid;
+btf:kernel.asm:        kfree(p->kstack);
+btf:kernel.asm:        p->kstack = 0;
+btf:kernel.asm:        freevm(p->pgdir);
+btf:kernel.asm:        p->pid = 0;
+btf:kernel.asm:        p->parent = 0;
+btf:kernel.asm:        p->name[0] = 0;
+btf:kernel.asm:        p->killed = 0;
+btf:kernel.asm:        p->state = UNUSED;
+btf:kernel.asm:        pid = p->pid;
+btf:kernel.asm:        kfree(p->kstack);
+btf:kernel.asm:        p->kstack = 0;
+btf:kernel.asm:        freevm(p->pgdir);
+btf:kernel.asm:        p->pid = 0;
+btf:kernel.asm:        p->parent = 0;
+btf:kernel.asm:        p->name[0] = 0;
+btf:kernel.asm:        p->killed = 0;
+btf:kernel.asm:        p->state = UNUSED;
+btf:kernel.asm:        p->parent = 0;
+btf:kernel.asm:        p->name[0] = 0;
+btf:kernel.asm:        p->killed = 0;
+btf:kernel.asm:        p->state = UNUSED;
+btf:kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+btf:kernel.asm:      p->state = RUNNABLE;
+btf:kernel.asm:    if(p->pid == pid){
+btf:kernel.asm:      p->killed = 1;
+btf:kernel.asm:      if(p->state == SLEEPING)
+btf:kernel.asm:    if(p->pid == pid){
+btf:kernel.asm:      p->killed = 1;
+btf:kernel.asm:      if(p->state == SLEEPING)
+btf:kernel.asm:        p->state = RUNNABLE;
+btf:kernel.asm:      p->killed = 1;
+btf:kernel.asm:      if(p->state == SLEEPING)
+btf:kernel.asm:        p->state = RUNNABLE;
+btf:kernel.asm:    if(p->pid == pid){
+btf:kernel.asm:      p->killed = 1;
+btf:kernel.asm:      if(p->state == SLEEPING)
+btf:kernel.asm:        p->state = RUNNABLE;
+btf:kernel.asm:    if(p->state == SLEEPING){
+btf:kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+btf:kernel.asm:    if(p->state == UNUSED)
+btf:kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+btf:kernel.asm:      state = states[p->state];
+btf:kernel.asm:    if(p->state == UNUSED)
+btf:kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+btf:kernel.asm:      state = states[p->state];
+btf:kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+btf:kernel.asm:    if(p->state == SLEEPING){
+btf:kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+btf:kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+btf:kernel.asm:    if(p->state == SLEEPING){
+btf:kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+btf:kernel.asm:        if(p->pid == pid && (p->state==RUNNING || p->state==RUNNABLE || p->state==SLEEPING)){
+btf:kernel.asm:    p->pending = sigHex | p->pending;
+btf:kernel.asm:    p->pending = sigHex | p->pending;
+btf:kernel.asm:      if(p->state != RUNNABLE)
+btf:kernel.asm:     /* if(p->alarmTime>0){
+btf:kernel.asm:	p->alarmTime -=1;
+btf:kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+btf:kernel.asm:      p->state = RUNNING;
+btf:kernel.asm:      swtch(&cpu->scheduler, p->context);
+btf:kernel.asm:      p->state = RUNNING;
+btf:kernel.asm:      swtch(&cpu->scheduler, p->context);
+btf:kernel.asm:      swtch(&cpu->scheduler, p->context);
+btf:kernel.asm:      // It should have changed its p->state before coming back.
+btf:kernel.asm:      // It should have changed its p->state before coming back.
+btf:kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+btf:kernel.asm:            //p->alarmTime=0; //reset alarmTime
+btf:kernel.asm:            p->alarmTime=-1;
+btf:kernel.asm:            sigsend(p->pid,SIGALRM);
+btf:kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+btf:kernel.asm:            //p->alarmTime=0; //reset alarmTime
+btf:kernel.asm:            p->alarmTime=-1;
+btf:kernel.asm:            sigsend(p->pid,SIGALRM);
+btf:kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+btf:kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+btf:kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+btf:kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+btf:kernel.asm:  ip->major = major;
+btf:kernel.asm:  ip->minor = minor;
+btf:kernel.asm:  ip->nlink = 1;
+btf:kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+btf:kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+btf:kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+btf:kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+btf:kernel.asm:  ip->minor = minor;
+btf:kernel.asm:  ip->nlink = 1;
+btf:kernel.asm:    dp->nlink++;  // for ".."
+btf:kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+btf:kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+btf:kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+btf:kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+btf:kernel.asm:  if(ip->type == T_DIR){
+btf:kernel.asm:  ip->nlink++;
+btf:kernel.asm:  ip->nlink++;
+btf:kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+btf:kernel.asm:  ip->nlink--;
+btf:kernel.asm:  ip->nlink--;
+btf:kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+btf:kernel.asm:  ip->nlink--;
+btf:kernel.asm:  ip->nlink--;
+btf:kernel.asm:  if(ip->nlink < 1)
+btf:kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+btf:kernel.asm:  if(ip->type == T_DIR){
+btf:kernel.asm:    dp->nlink--;
+btf:kernel.asm:  ip->nlink--;
+btf:kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+btf:kernel.asm:  if(ip->nlink < 1)
+btf:kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+btf:kernel.asm:  if(ip->type == T_DIR){
+btf:kernel.asm:    dp->nlink--;
+btf:kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+btf:kernel.asm:  if(ip->nlink < 1)
+btf:kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+btf:kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+btf:kernel.asm:  if(ip->type != T_DIR){
+btf:kernel.asm:  if(ip->type != T_DIR){
+btf:kernel.asm:  if(ip->type != T_DIR){
+btf:kernel.asm:  if(ip->type != T_DIR){
+btf:kernel.asm:  if(p->kstack == 0)
+btf:kernel.asm:  if(p->pgdir == 0)
+btf:kernel.asm:  if(p->pgdir == 0)
+btf:kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+btf:kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+btf:kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+btf:kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+btf:kernel.asm:  if(p->kstack == 0)
+btf:kernel.asm:  if(p->pgdir == 0)
+btf:kernel.asm:  if(p->kstack == 0)
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:kill.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:kill.asm:    bp->s.size += p->s.ptr->s.size;
+btf:kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:kill.asm:    bp->s.ptr = p->s.ptr;
+btf:kill.asm:  if(p + p->s.size == bp){
+btf:kill.asm:    p->s.size += bp->s.size;
+btf:kill.asm:    p->s.ptr = bp->s.ptr;
+btf:kill.asm:    p->s.ptr = bp;
+btf:kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:kill.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:kill.asm:    bp->s.size += p->s.ptr->s.size;
+btf:kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:kill.asm:    bp->s.ptr = p->s.ptr;
+btf:kill.asm:  if(p + p->s.size == bp){
+btf:kill.asm:    p->s.size += bp->s.size;
+btf:kill.asm:    p->s.ptr = bp->s.ptr;
+btf:kill.asm:    p->s.ptr = bp;
+btf:kill.asm:    bp->s.size += p->s.ptr->s.size;
+btf:kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:kill.asm:    bp->s.ptr = p->s.ptr;
+btf:kill.asm:  if(p + p->s.size == bp){
+btf:kill.asm:    p->s.size += bp->s.size;
+btf:kill.asm:    p->s.ptr = bp->s.ptr;
+btf:kill.asm:    p->s.ptr = bp;
+btf:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:kill.asm:    if(p->s.size >= nunits){
+btf:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:kill.asm:    if(p->s.size >= nunits){
+btf:kill.asm:        p->s.size = nunits;
+btf:kill.asm:  hp->s.size = nu;
+btf:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:kill.asm:    if(p->s.size >= nunits){
+btf:kill.asm:      if(p->s.size == nunits)
+btf:kill.asm:        prevp->s.ptr = p->s.ptr;
+btf:kill.asm:        p->s.size -= nunits;
+btf:kill.asm:        p += p->s.size;
+btf:kill.asm:        p->s.size = nunits;
+btf:kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:kill.asm:    if(p->s.size >= nunits){
+btf:kill.asm:      if(p->s.size == nunits)
+btf:kill.asm:        prevp->s.ptr = p->s.ptr;
+btf:kill.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:kill.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ln.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ln.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ln.asm:    bp->s.ptr = p->s.ptr;
+btf:ln.asm:  if(p + p->s.size == bp){
+btf:ln.asm:    p->s.size += bp->s.size;
+btf:ln.asm:    p->s.ptr = bp->s.ptr;
+btf:ln.asm:    p->s.ptr = bp;
+btf:ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ln.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ln.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ln.asm:    bp->s.ptr = p->s.ptr;
+btf:ln.asm:  if(p + p->s.size == bp){
+btf:ln.asm:    p->s.size += bp->s.size;
+btf:ln.asm:    p->s.ptr = bp->s.ptr;
+btf:ln.asm:    p->s.ptr = bp;
+btf:ln.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ln.asm:    bp->s.ptr = p->s.ptr;
+btf:ln.asm:  if(p + p->s.size == bp){
+btf:ln.asm:    p->s.size += bp->s.size;
+btf:ln.asm:    p->s.ptr = bp->s.ptr;
+btf:ln.asm:    p->s.ptr = bp;
+btf:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ln.asm:    if(p->s.size >= nunits){
+btf:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ln.asm:    if(p->s.size >= nunits){
+btf:ln.asm:        p->s.size = nunits;
+btf:ln.asm:  hp->s.size = nu;
+btf:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ln.asm:    if(p->s.size >= nunits){
+btf:ln.asm:      if(p->s.size == nunits)
+btf:ln.asm:        prevp->s.ptr = p->s.ptr;
+btf:ln.asm:        p->s.size -= nunits;
+btf:ln.asm:        p += p->s.size;
+btf:ln.asm:        p->s.size = nunits;
+btf:ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ln.asm:    if(p->s.size >= nunits){
+btf:ln.asm:      if(p->s.size == nunits)
+btf:ln.asm:        prevp->s.ptr = p->s.ptr;
+btf:ln.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ln.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:log.c://   modify bp->data[]
+btf:ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ls.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ls.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ls.asm:    bp->s.ptr = p->s.ptr;
+btf:ls.asm:  if(p + p->s.size == bp){
+btf:ls.asm:    p->s.size += bp->s.size;
+btf:ls.asm:    p->s.ptr = bp->s.ptr;
+btf:ls.asm:    p->s.ptr = bp;
+btf:ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:ls.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:ls.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ls.asm:    bp->s.ptr = p->s.ptr;
+btf:ls.asm:  if(p + p->s.size == bp){
+btf:ls.asm:    p->s.size += bp->s.size;
+btf:ls.asm:    p->s.ptr = bp->s.ptr;
+btf:ls.asm:    p->s.ptr = bp;
+btf:ls.asm:    bp->s.size += p->s.ptr->s.size;
+btf:ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:ls.asm:    bp->s.ptr = p->s.ptr;
+btf:ls.asm:  if(p + p->s.size == bp){
+btf:ls.asm:    p->s.size += bp->s.size;
+btf:ls.asm:    p->s.ptr = bp->s.ptr;
+btf:ls.asm:    p->s.ptr = bp;
+btf:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ls.asm:    if(p->s.size >= nunits){
+btf:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ls.asm:    if(p->s.size >= nunits){
+btf:ls.asm:        p->s.size = nunits;
+btf:ls.asm:  hp->s.size = nu;
+btf:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ls.asm:    if(p->s.size >= nunits){
+btf:ls.asm:      if(p->s.size == nunits)
+btf:ls.asm:        prevp->s.ptr = p->s.ptr;
+btf:ls.asm:        p->s.size -= nunits;
+btf:ls.asm:        p += p->s.size;
+btf:ls.asm:        p->s.size = nunits;
+btf:ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:ls.asm:    if(p->s.size >= nunits){
+btf:ls.asm:      if(p->s.size == nunits)
+btf:ls.asm:        prevp->s.ptr = p->s.ptr;
+btf:ls.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ls.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr;
+btf:mkdir.asm:  if(p + p->s.size == bp){
+btf:mkdir.asm:    p->s.size += bp->s.size;
+btf:mkdir.asm:    p->s.ptr = bp->s.ptr;
+btf:mkdir.asm:    p->s.ptr = bp;
+btf:mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr;
+btf:mkdir.asm:  if(p + p->s.size == bp){
+btf:mkdir.asm:    p->s.size += bp->s.size;
+btf:mkdir.asm:    p->s.ptr = bp->s.ptr;
+btf:mkdir.asm:    p->s.ptr = bp;
+btf:mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:mkdir.asm:    bp->s.ptr = p->s.ptr;
+btf:mkdir.asm:  if(p + p->s.size == bp){
+btf:mkdir.asm:    p->s.size += bp->s.size;
+btf:mkdir.asm:    p->s.ptr = bp->s.ptr;
+btf:mkdir.asm:    p->s.ptr = bp;
+btf:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:mkdir.asm:    if(p->s.size >= nunits){
+btf:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:mkdir.asm:    if(p->s.size >= nunits){
+btf:mkdir.asm:        p->s.size = nunits;
+btf:mkdir.asm:  hp->s.size = nu;
+btf:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:mkdir.asm:    if(p->s.size >= nunits){
+btf:mkdir.asm:      if(p->s.size == nunits)
+btf:mkdir.asm:        prevp->s.ptr = p->s.ptr;
+btf:mkdir.asm:        p->s.size -= nunits;
+btf:mkdir.asm:        p += p->s.size;
+btf:mkdir.asm:        p->s.size = nunits;
+btf:mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:mkdir.asm:    if(p->s.size >= nunits){
+btf:mkdir.asm:      if(p->s.size == nunits)
+btf:mkdir.asm:        prevp->s.ptr = p->s.ptr;
+btf:mkdir.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:mkdir.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:mp.c:    if((mp = mpsearch1(p-1024, 1024)))
+btf:mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+btf:mp.c:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+btf:mp.c:  if(mp->imcrp){
+btf:Notes:blocks and inodes have ad-hoc sleep-locks
+btf:pipe.c:  p->readopen = 1;
+btf:pipe.c:  p->writeopen = 1;
+btf:pipe.c:  p->nwrite = 0;
+btf:pipe.c:  p->nread = 0;
+btf:pipe.c:  initlock(&p->lock, "pipe");
+btf:pipe.c:  acquire(&p->lock);
+btf:pipe.c:    p->writeopen = 0;
+btf:pipe.c:    wakeup(&p->nread);
+btf:pipe.c:    p->readopen = 0;
+btf:pipe.c:    wakeup(&p->nwrite);
+btf:pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
+btf:pipe.c:    release(&p->lock);
+btf:pipe.c:    release(&p->lock);
+btf:pipe.c:  acquire(&p->lock);
+btf:pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+btf:pipe.c:      if(p->readopen == 0 || proc->killed){
+btf:pipe.c:        release(&p->lock);
+btf:pipe.c:      wakeup(&p->nread);
+btf:pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+btf:pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+btf:pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+btf:pipe.c:  release(&p->lock);
+btf:pipe.c:  acquire(&p->lock);
+btf:pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+btf:pipe.c:      release(&p->lock);
+btf:pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+btf:pipe.c:    if(p->nread == p->nwrite)
+btf:pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
+btf:pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+btf:pipe.c:  release(&p->lock);
+btf:proc.c:    if(p->state == UNUSED)
+btf:proc.c:  p->state = EMBRYO;
+btf:proc.c:  p->alarmTime=-1;
+btf:proc.c:  p->pid = nextpid++;
+btf:proc.c:      p->sigFuncs[i] = &defaultHandler;
+btf:proc.c:  if((p->kstack = kalloc()) == 0){
+btf:proc.c:    p->state = UNUSED;
+btf:proc.c:  sp = p->kstack + KSTACKSIZE;
+btf:proc.c:  sp -= sizeof *p->tf;
+btf:proc.c:  p->tf = (struct trapframe*)sp;
+btf:proc.c:  sp -= sizeof *p->context;
+btf:proc.c:  p->context = (struct context*)sp;
+btf:proc.c:  memset(p->context, 0, sizeof *p->context);
+btf:proc.c:  p->context->eip = (uint)forkret;
+btf:proc.c:  if((p->pgdir = setupkvm()) == 0)
+btf:proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+btf:proc.c:  p->sz = PGSIZE;
+btf:proc.c:  memset(p->tf, 0, sizeof(*p->tf));
+btf:proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+btf:proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+btf:proc.c:  p->tf->es = p->tf->ds;
+btf:proc.c:  p->tf->ss = p->tf->ds;
+btf:proc.c:  p->tf->eflags = FL_IF;
+btf:proc.c:  p->tf->esp = PGSIZE;
+btf:proc.c:  p->tf->eip = 0;  // beginning of initcode.S
+btf:proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
+btf:proc.c:  p->cwd = namei("/");
+btf:proc.c:  // this assignment to p->state lets other cores
+btf:proc.c:  p->state = RUNNABLE;
+btf:proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+btf:proc.c:    kfree(np->kstack);
+btf:proc.c:    np->kstack = 0;
+btf:proc.c:    np->state = UNUSED;
+btf:proc.c:  np->sz = proc->sz;
+btf:proc.c:  np->parent = proc;
+btf:proc.c:  *np->tf = *proc->tf;
+btf:proc.c:  np->tf->eax = 0;
+btf:proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
+btf:proc.c:  np->cwd = idup(proc->cwd);
+btf:proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+btf:proc.c:  pid = np->pid;
+btf:proc.c:  np->state = RUNNABLE;
+btf:proc.c:    if(p->parent == proc){
+btf:proc.c:      p->parent = initproc;
+btf:proc.c:      if(p->state == ZOMBIE)
+btf:proc.c:      if(p->parent != proc)
+btf:proc.c:      if(p->state == ZOMBIE){
+btf:proc.c:        pid = p->pid;
+btf:proc.c:        kfree(p->kstack);
+btf:proc.c:        p->kstack = 0;
+btf:proc.c:        freevm(p->pgdir);
+btf:proc.c:        p->pid = 0;
+btf:proc.c:        p->parent = 0;
+btf:proc.c:        p->name[0] = 0;
+btf:proc.c:        p->killed = 0;
+btf:proc.c:        p->state = UNUSED;
+btf:proc.c:      if(p->state != RUNNABLE)
+btf:proc.c:     /* if(p->alarmTime>0){
+btf:proc.c:	p->alarmTime -=1;
+btf:proc.c:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+btf:proc.c:            //p->alarmTime=0; //reset alarmTime
+btf:proc.c:            p->alarmTime=-1;
+btf:proc.c:            sigsend(p->pid,SIGALRM);
+btf:proc.c:      p->state = RUNNING;
+btf:proc.c:      swtch(&cpu->scheduler, p->context);
+btf:proc.c:      // It should have changed its p->state before coming back.
+btf:proc.c:  // change p->state and then call sched.
+btf:proc.c:    if(p->state == SLEEPING && p->chan == chan)
+btf:proc.c:      p->state = RUNNABLE;
+btf:proc.c:    if(p->pid == pid){
+btf:proc.c:      p->killed = 1;
+btf:proc.c:      if(p->state == SLEEPING)
+btf:proc.c:        p->state = RUNNABLE;
+btf:proc.c:    if(p->state == UNUSED)
+btf:proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+btf:proc.c:      state = states[p->state];
+btf:proc.c:    cprintf("%d %s %s", p->pid, state, p->name);
+btf:proc.c:    if(p->state == SLEEPING){
+btf:proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
+btf:proc.c:        if(p->pid == pid && (p->state==RUNNING || p->state==RUNNABLE || p->state==SLEEPING)){
+btf:proc.c:    p->pending = sigHex | p->pending;
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:rm.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:rm.asm:    bp->s.size += p->s.ptr->s.size;
+btf:rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:rm.asm:    bp->s.ptr = p->s.ptr;
+btf:rm.asm:  if(p + p->s.size == bp){
+btf:rm.asm:    p->s.size += bp->s.size;
+btf:rm.asm:    p->s.ptr = bp->s.ptr;
+btf:rm.asm:    p->s.ptr = bp;
+btf:rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:rm.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:rm.asm:    bp->s.size += p->s.ptr->s.size;
+btf:rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:rm.asm:    bp->s.ptr = p->s.ptr;
+btf:rm.asm:  if(p + p->s.size == bp){
+btf:rm.asm:    p->s.size += bp->s.size;
+btf:rm.asm:    p->s.ptr = bp->s.ptr;
+btf:rm.asm:    p->s.ptr = bp;
+btf:rm.asm:    bp->s.size += p->s.ptr->s.size;
+btf:rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:rm.asm:    bp->s.ptr = p->s.ptr;
+btf:rm.asm:  if(p + p->s.size == bp){
+btf:rm.asm:    p->s.size += bp->s.size;
+btf:rm.asm:    p->s.ptr = bp->s.ptr;
+btf:rm.asm:    p->s.ptr = bp;
+btf:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:rm.asm:    if(p->s.size >= nunits){
+btf:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:rm.asm:    if(p->s.size >= nunits){
+btf:rm.asm:        p->s.size = nunits;
+btf:rm.asm:  hp->s.size = nu;
+btf:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:rm.asm:    if(p->s.size >= nunits){
+btf:rm.asm:      if(p->s.size == nunits)
+btf:rm.asm:        prevp->s.ptr = p->s.ptr;
+btf:rm.asm:        p->s.size -= nunits;
+btf:rm.asm:        p += p->s.size;
+btf:rm.asm:        p->s.size = nunits;
+btf:rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:rm.asm:    if(p->s.size >= nunits){
+btf:rm.asm:      if(p->s.size == nunits)
+btf:rm.asm:        prevp->s.ptr = p->s.ptr;
+btf:rm.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:rm.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:sh.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:sh.asm:    bp->s.size += p->s.ptr->s.size;
+btf:sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:sh.asm:    bp->s.ptr = p->s.ptr;
+btf:sh.asm:  if(p + p->s.size == bp){
+btf:sh.asm:    p->s.size += bp->s.size;
+btf:sh.asm:    p->s.ptr = bp->s.ptr;
+btf:sh.asm:    p->s.ptr = bp;
+btf:sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:sh.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:sh.asm:    bp->s.size += p->s.ptr->s.size;
+btf:sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:sh.asm:    bp->s.ptr = p->s.ptr;
+btf:sh.asm:  if(p + p->s.size == bp){
+btf:sh.asm:    p->s.size += bp->s.size;
+btf:sh.asm:    p->s.ptr = bp->s.ptr;
+btf:sh.asm:    p->s.ptr = bp;
+btf:sh.asm:    bp->s.size += p->s.ptr->s.size;
+btf:sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:sh.asm:    bp->s.ptr = p->s.ptr;
+btf:sh.asm:  if(p + p->s.size == bp){
+btf:sh.asm:    p->s.size += bp->s.size;
+btf:sh.asm:    p->s.ptr = bp->s.ptr;
+btf:sh.asm:    p->s.ptr = bp;
+btf:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:sh.asm:    if(p->s.size >= nunits){
+btf:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:sh.asm:    if(p->s.size >= nunits){
+btf:sh.asm:        p->s.size = nunits;
+btf:sh.asm:  hp->s.size = nu;
+btf:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:sh.asm:    if(p->s.size >= nunits){
+btf:sh.asm:      if(p->s.size == nunits)
+btf:sh.asm:        prevp->s.ptr = p->s.ptr;
+btf:sh.asm:        p->s.size -= nunits;
+btf:sh.asm:        p += p->s.size;
+btf:sh.asm:        p->s.size = nunits;
+btf:sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:sh.asm:    if(p->s.size >= nunits){
+btf:sh.asm:      if(p->s.size == nunits)
+btf:sh.asm:        prevp->s.ptr = p->s.ptr;
+btf:sh.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:sh.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr;
+btf:stressfs.asm:  if(p + p->s.size == bp){
+btf:stressfs.asm:    p->s.size += bp->s.size;
+btf:stressfs.asm:    p->s.ptr = bp->s.ptr;
+btf:stressfs.asm:    p->s.ptr = bp;
+btf:stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr;
+btf:stressfs.asm:  if(p + p->s.size == bp){
+btf:stressfs.asm:    p->s.size += bp->s.size;
+btf:stressfs.asm:    p->s.ptr = bp->s.ptr;
+btf:stressfs.asm:    p->s.ptr = bp;
+btf:stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:stressfs.asm:    bp->s.ptr = p->s.ptr;
+btf:stressfs.asm:  if(p + p->s.size == bp){
+btf:stressfs.asm:    p->s.size += bp->s.size;
+btf:stressfs.asm:    p->s.ptr = bp->s.ptr;
+btf:stressfs.asm:    p->s.ptr = bp;
+btf:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:stressfs.asm:    if(p->s.size >= nunits){
+btf:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:stressfs.asm:    if(p->s.size >= nunits){
+btf:stressfs.asm:        p->s.size = nunits;
+btf:stressfs.asm:  hp->s.size = nu;
+btf:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:stressfs.asm:    if(p->s.size >= nunits){
+btf:stressfs.asm:      if(p->s.size == nunits)
+btf:stressfs.asm:        prevp->s.ptr = p->s.ptr;
+btf:stressfs.asm:        p->s.size -= nunits;
+btf:stressfs.asm:        p += p->s.size;
+btf:stressfs.asm:        p->s.size = nunits;
+btf:stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:stressfs.asm:    if(p->s.size >= nunits){
+btf:stressfs.asm:      if(p->s.size == nunits)
+btf:stressfs.asm:        prevp->s.ptr = p->s.ptr;
+btf:stressfs.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:stressfs.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:symlink.patch:     ip = idup(cp->cwd);
+btf:sysfile.c:  if(ip->type == T_DIR){
+btf:sysfile.c:  ip->nlink++;
+btf:sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+btf:sysfile.c:  ip->nlink--;
+btf:sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+btf:sysfile.c:  if(ip->nlink < 1)
+btf:sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
+btf:sysfile.c:  if(ip->type == T_DIR){
+btf:sysfile.c:    dp->nlink--;
+btf:sysfile.c:  ip->nlink--;
+btf:sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
+btf:sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
+btf:sysfile.c:  ip->major = major;
+btf:sysfile.c:  ip->minor = minor;
+btf:sysfile.c:  ip->nlink = 1;
+btf:sysfile.c:    dp->nlink++;  // for ".."
+btf:sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
+btf:sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+btf:sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
+btf:sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
+btf:sysfile.c:  if(ip->type != T_DIR){
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:t2.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:t2.asm:    bp->s.size += p->s.ptr->s.size;
+btf:t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:t2.asm:    bp->s.ptr = p->s.ptr;
+btf:t2.asm:  if(p + p->s.size == bp){
+btf:t2.asm:    p->s.size += bp->s.size;
+btf:t2.asm:    p->s.ptr = bp->s.ptr;
+btf:t2.asm:    p->s.ptr = bp;
+btf:t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:t2.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:t2.asm:    bp->s.size += p->s.ptr->s.size;
+btf:t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:t2.asm:    bp->s.ptr = p->s.ptr;
+btf:t2.asm:  if(p + p->s.size == bp){
+btf:t2.asm:    p->s.size += bp->s.size;
+btf:t2.asm:    p->s.ptr = bp->s.ptr;
+btf:t2.asm:    p->s.ptr = bp;
+btf:t2.asm:    bp->s.size += p->s.ptr->s.size;
+btf:t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:t2.asm:    bp->s.ptr = p->s.ptr;
+btf:t2.asm:  if(p + p->s.size == bp){
+btf:t2.asm:    p->s.size += bp->s.size;
+btf:t2.asm:    p->s.ptr = bp->s.ptr;
+btf:t2.asm:    p->s.ptr = bp;
+btf:t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:t2.asm:    if(p->s.size >= nunits){
+btf:t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:t2.asm:    if(p->s.size >= nunits){
+btf:t2.asm:        p->s.size = nunits;
+btf:t2.asm:  hp->s.size = nu;
+btf:t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:t2.asm:    if(p->s.size >= nunits){
+btf:t2.asm:      if(p->s.size == nunits)
+btf:t2.asm:        prevp->s.ptr = p->s.ptr;
+btf:t2.asm:        p->s.size -= nunits;
+btf:t2.asm:        p += p->s.size;
+btf:t2.asm:        p->s.size = nunits;
+btf:t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:t2.asm:    if(p->s.size >= nunits){
+btf:t2.asm:      if(p->s.size == nunits)
+btf:t2.asm:        prevp->s.ptr = p->s.ptr;
+btf:t2.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:t2.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:thread.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:thread.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:thread.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:thread.asm:    bp->s.size += p->s.ptr->s.size;
+btf:thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:thread.asm:    bp->s.ptr = p->s.ptr;
+btf:thread.asm:  if(p + p->s.size == bp){
+btf:thread.asm:    p->s.size += bp->s.size;
+btf:thread.asm:    p->s.ptr = bp->s.ptr;
+btf:thread.asm:    p->s.ptr = bp;
+btf:thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:thread.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:thread.asm:    bp->s.size += p->s.ptr->s.size;
+btf:thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:thread.asm:    bp->s.ptr = p->s.ptr;
+btf:thread.asm:  if(p + p->s.size == bp){
+btf:thread.asm:    p->s.size += bp->s.size;
+btf:thread.asm:    p->s.ptr = bp->s.ptr;
+btf:thread.asm:    p->s.ptr = bp;
+btf:thread.asm:    bp->s.size += p->s.ptr->s.size;
+btf:thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:thread.asm:    bp->s.ptr = p->s.ptr;
+btf:thread.asm:  if(p + p->s.size == bp){
+btf:thread.asm:    p->s.size += bp->s.size;
+btf:thread.asm:    p->s.ptr = bp->s.ptr;
+btf:thread.asm:    p->s.ptr = bp;
+btf:thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:thread.asm:    if(p->s.size >= nunits){
+btf:thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:thread.asm:    if(p->s.size >= nunits){
+btf:thread.asm:        p->s.size = nunits;
+btf:thread.asm:  hp->s.size = nu;
+btf:thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:thread.asm:    if(p->s.size >= nunits){
+btf:thread.asm:      if(p->s.size == nunits)
+btf:thread.asm:        prevp->s.ptr = p->s.ptr;
+btf:thread.asm:        p->s.size -= nunits;
+btf:thread.asm:        p += p->s.size;
+btf:thread.asm:        p->s.size = nunits;
+btf:thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:thread.asm:    if(p->s.size >= nunits){
+btf:thread.asm:      if(p->s.size == nunits)
+btf:thread.asm:        prevp->s.ptr = p->s.ptr;
+btf:thread.c:    newThread->btf->esp=esp-3*sizeof(int);
+btf:TRICKS:at that point, cp->tf is set to point to a trap frame
+btf:TRICKS:The code in fork needs to read np->pid before
+btf:TRICKS:setting np->state to RUNNABLE.  The following
+btf:TRICKS:	  np->state = RUNNABLE;
+btf:TRICKS:	  return np->pid; // oops
+btf:TRICKS:After setting np->state to RUNNABLE, some other CPU
+btf:TRICKS:"return np->pid". Even saving a copy of np->pid before
+btf:TRICKS:setting np->state isn't safe, since the compiler is
+btf:TRICKS:The real code saves a copy of np->pid, then acquires a lock
+btf:TRICKS:around the write to np->state. The acquire() prevents the
+btf:umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:umalloc.c:  if(bp + bp->s.size == p->s.ptr){
+btf:umalloc.c:    bp->s.size += p->s.ptr->s.size;
+btf:umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:umalloc.c:    bp->s.ptr = p->s.ptr;
+btf:umalloc.c:  if(p + p->s.size == bp){
+btf:umalloc.c:    p->s.size += bp->s.size;
+btf:umalloc.c:    p->s.ptr = bp->s.ptr;
+btf:umalloc.c:    p->s.ptr = bp;
+btf:umalloc.c:  hp->s.size = nu;
+btf:umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:umalloc.c:    if(p->s.size >= nunits){
+btf:umalloc.c:      if(p->s.size == nunits)
+btf:umalloc.c:        prevp->s.ptr = p->s.ptr;
+btf:umalloc.c:        p->s.size -= nunits;
+btf:umalloc.c:        p += p->s.size;
+btf:umalloc.c:        p->s.size = nunits;
+btf:usertests.c:// does chdir() call iput(p->cwd) in a transaction?
+btf:usertests.c:// does exit() call iput(p->cwd) in a transaction?
+btf:vm.c:  if(p->kstack == 0)
+btf:vm.c:  if(p->pgdir == 0)
+btf:vm.c:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+btf:vm.c:  lcr3(V2P(p->pgdir));  // switch to process's address space
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:wc.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:wc.asm:    bp->s.size += p->s.ptr->s.size;
+btf:wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:wc.asm:    bp->s.ptr = p->s.ptr;
+btf:wc.asm:  if(p + p->s.size == bp){
+btf:wc.asm:    p->s.size += bp->s.size;
+btf:wc.asm:    p->s.ptr = bp->s.ptr;
+btf:wc.asm:    p->s.ptr = bp;
+btf:wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:wc.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:wc.asm:    bp->s.size += p->s.ptr->s.size;
+btf:wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:wc.asm:    bp->s.ptr = p->s.ptr;
+btf:wc.asm:  if(p + p->s.size == bp){
+btf:wc.asm:    p->s.size += bp->s.size;
+btf:wc.asm:    p->s.ptr = bp->s.ptr;
+btf:wc.asm:    p->s.ptr = bp;
+btf:wc.asm:    bp->s.size += p->s.ptr->s.size;
+btf:wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:wc.asm:    bp->s.ptr = p->s.ptr;
+btf:wc.asm:  if(p + p->s.size == bp){
+btf:wc.asm:    p->s.size += bp->s.size;
+btf:wc.asm:    p->s.ptr = bp->s.ptr;
+btf:wc.asm:    p->s.ptr = bp;
+btf:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:wc.asm:    if(p->s.size >= nunits){
+btf:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:wc.asm:    if(p->s.size >= nunits){
+btf:wc.asm:        p->s.size = nunits;
+btf:wc.asm:  hp->s.size = nu;
+btf:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:wc.asm:    if(p->s.size >= nunits){
+btf:wc.asm:      if(p->s.size == nunits)
+btf:wc.asm:        prevp->s.ptr = p->s.ptr;
+btf:wc.asm:        p->s.size -= nunits;
+btf:wc.asm:        p += p->s.size;
+btf:wc.asm:        p->s.size = nunits;
+btf:wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:wc.asm:    if(p->s.size >= nunits){
+btf:wc.asm:      if(p->s.size == nunits)
+btf:wc.asm:        prevp->s.ptr = p->s.ptr;
+btf:wc.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:wc.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:zombie.asm:    bp->s.size += p->s.ptr->s.size;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr;
+btf:zombie.asm:  if(p + p->s.size == bp){
+btf:zombie.asm:    p->s.size += bp->s.size;
+btf:zombie.asm:    p->s.ptr = bp->s.ptr;
+btf:zombie.asm:    p->s.ptr = bp;
+btf:zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+btf:zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+btf:zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+btf:zombie.asm:    bp->s.size += p->s.ptr->s.size;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr;
+btf:zombie.asm:  if(p + p->s.size == bp){
+btf:zombie.asm:    p->s.size += bp->s.size;
+btf:zombie.asm:    p->s.ptr = bp->s.ptr;
+btf:zombie.asm:    p->s.ptr = bp;
+btf:zombie.asm:    bp->s.size += p->s.ptr->s.size;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+btf:zombie.asm:    bp->s.ptr = p->s.ptr;
+btf:zombie.asm:  if(p + p->s.size == bp){
+btf:zombie.asm:    p->s.size += bp->s.size;
+btf:zombie.asm:    p->s.ptr = bp->s.ptr;
+btf:zombie.asm:    p->s.ptr = bp;
+btf:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:zombie.asm:    if(p->s.size >= nunits){
+btf:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:zombie.asm:    if(p->s.size >= nunits){
+btf:zombie.asm:        p->s.size = nunits;
+btf:zombie.asm:  hp->s.size = nu;
+btf:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:zombie.asm:    if(p->s.size >= nunits){
+btf:zombie.asm:      if(p->s.size == nunits)
+btf:zombie.asm:        prevp->s.ptr = p->s.ptr;
+btf:zombie.asm:        p->s.size -= nunits;
+btf:zombie.asm:        p += p->s.size;
+btf:zombie.asm:        p->s.size = nunits;
+btf:zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+btf:zombie.asm:    if(p->s.size >= nunits){
+btf:zombie.asm:      if(p->s.size == nunits)
+btf:zombie.asm:        prevp->s.ptr = p->s.ptr;
+btf:zombie.asm:    newThread->btf->esp=esp-3*sizeof(int);
+btf:zombie.asm:    newThread->btf->esp=esp-3*sizeof(int);
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  if(bp + bp->s.size == p->s.ptr){
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm:    p->s.ptr = bp;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  if(bp + bp->s.size == p->s.ptr){
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm:    p->s.ptr = bp;
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm:    p->s.ptr = bp;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:        p->s.size = nunits;
+cat.asm:  hp->s.size = nu;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:      if(p->s.size == nunits)
+cat.asm:        prevp->s.ptr = p->s.ptr;
+cat.asm:        p->s.size -= nunits;
+cat.asm:        p += p->s.size;
+cat.asm:        p->s.size = nunits;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:      if(p->s.size == nunits)
+cat.asm:        prevp->s.ptr = p->s.ptr;
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+csem.asm:  if(bp + bp->s.size == p->s.ptr){
+csem.asm:    bp->s.size += p->s.ptr->s.size;
+csem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+csem.asm:    bp->s.ptr = p->s.ptr;
+csem.asm:  if(p + p->s.size == bp){
+csem.asm:    p->s.size += bp->s.size;
+csem.asm:    p->s.ptr = bp->s.ptr;
+csem.asm:    p->s.ptr = bp;
+csem.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+csem.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+csem.asm:  if(bp + bp->s.size == p->s.ptr){
+csem.asm:    bp->s.size += p->s.ptr->s.size;
+csem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+csem.asm:    bp->s.ptr = p->s.ptr;
+csem.asm:  if(p + p->s.size == bp){
+csem.asm:    p->s.size += bp->s.size;
+csem.asm:    p->s.ptr = bp->s.ptr;
+csem.asm:    p->s.ptr = bp;
+csem.asm:    bp->s.size += p->s.ptr->s.size;
+csem.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+csem.asm:    bp->s.ptr = p->s.ptr;
+csem.asm:  if(p + p->s.size == bp){
+csem.asm:    p->s.size += bp->s.size;
+csem.asm:    p->s.ptr = bp->s.ptr;
+csem.asm:    p->s.ptr = bp;
+csem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+csem.asm:    if(p->s.size >= nunits){
+csem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+csem.asm:    if(p->s.size >= nunits){
+csem.asm:        p->s.size = nunits;
+csem.asm:  hp->s.size = nu;
+csem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+csem.asm:    if(p->s.size >= nunits){
+csem.asm:      if(p->s.size == nunits)
+csem.asm:        prevp->s.ptr = p->s.ptr;
+csem.asm:        p->s.size -= nunits;
+csem.asm:        p += p->s.size;
+csem.asm:        p->s.size = nunits;
+csem.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+csem.asm:    if(p->s.size >= nunits){
+csem.asm:      if(p->s.size == nunits)
+csem.asm:        prevp->s.ptr = p->s.ptr;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  if(bp + bp->s.size == p->s.ptr){
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm:    p->s.ptr = bp;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  if(bp + bp->s.size == p->s.ptr){
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm:    p->s.ptr = bp;
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm:    p->s.ptr = bp;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:        p->s.size = nunits;
+echo.asm:  hp->s.size = nu;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:      if(p->s.size == nunits)
+echo.asm:        prevp->s.ptr = p->s.ptr;
+echo.asm:        p->s.size -= nunits;
+echo.asm:        p += p->s.size;
+echo.asm:        p->s.size = nunits;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:      if(p->s.size == nunits)
+echo.asm:        prevp->s.ptr = p->s.ptr;
+fs.c:  memmove(sb, bp->data, sizeof(*sb));
+fs.c:  memset(bp->data, 0, BSIZE);
+fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
+fs.c:  if((bp->data[bi/8] & m) == 0)
+fs.c:  bp->data[bi/8] &= ~m;
+fs.c:// not stored on disk: ip->ref and ip->flags.
+fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
+fs.c://   is set in ip->flags. ilock() reads the inode from
+fs.c://   I_VALID if ip->ref has fallen to zero.
+fs.c://   ... examine and modify ip->xxx ...
+fs.c:// pathname lookup. iget() increments ip->ref so that the inode
+fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
+fs.c:    if(dip->type == 0){  // a free inode
+fs.c:      dip->type = type;
+fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+fs.c:  dip->type = ip->type;
+fs.c:  dip->major = ip->major;
+fs.c:  dip->minor = ip->minor;
+fs.c:  dip->nlink = ip->nlink;
+fs.c:  dip->size = ip->size;
+fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+fs.c:      ip->ref++;
+fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+fs.c:  ip->dev = dev;
+fs.c:  ip->inum = inum;
+fs.c:  ip->ref = 1;
+fs.c:  ip->flags = 0;
+fs.c:  ip->ref++;
+fs.c:  if(ip == 0 || ip->ref < 1)
+fs.c:  acquiresleep(&ip->lock);
+fs.c:  if(!(ip->flags & I_VALID)){
+fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+fs.c:    ip->type = dip->type;
+fs.c:    ip->major = dip->major;
+fs.c:    ip->minor = dip->minor;
+fs.c:    ip->nlink = dip->nlink;
+fs.c:    ip->size = dip->size;
+fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+fs.c:    ip->flags |= I_VALID;
+fs.c:    if(ip->type == 0)
+fs.c:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+fs.c:  releasesleep(&ip->lock);
+fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+fs.c:    ip->type = 0;
+fs.c:    ip->flags = 0;
+fs.c:  ip->ref--;
+fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are
+fs.c:// listed in block ip->addrs[NDIRECT].
+fs.c:    if((addr = ip->addrs[bn]) == 0)
+fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
+fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
+fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+fs.c:    bp = bread(ip->dev, addr);
+fs.c:    a = (uint*)bp->data;
+fs.c:      a[bn] = addr = balloc(ip->dev);
+fs.c:    if(ip->addrs[i]){
+fs.c:      bfree(ip->dev, ip->addrs[i]);
+fs.c:      ip->addrs[i] = 0;
+fs.c:  if(ip->addrs[NDIRECT]){
+fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+fs.c:    a = (uint*)bp->data;
+fs.c:        bfree(ip->dev, a[j]);
+fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
+fs.c:    ip->addrs[NDIRECT] = 0;
+fs.c:  ip->size = 0;
+fs.c:  st->dev = ip->dev;
+fs.c:  st->ino = ip->inum;
+fs.c:  st->type = ip->type;
+fs.c:  st->nlink = ip->nlink;
+fs.c:  st->size = ip->size;
+fs.c:  if(ip->type == T_DEV){
+fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+fs.c:    return devsw[ip->major].read(ip, dst, n);
+fs.c:  if(off > ip->size || off + n < off)
+fs.c:  if(off + n > ip->size)
+fs.c:    n = ip->size - off;
+fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+fs.c:      cprintf("%x ", bp->data[off%BSIZE+j]);
+fs.c:    memmove(dst, bp->data + off%BSIZE, m);
+fs.c:  if(ip->type == T_DEV){
+fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+fs.c:    return devsw[ip->major].write(ip, src, n);
+fs.c:  if(off > ip->size || off + n < off)
+fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+fs.c:    memmove(bp->data + off%BSIZE, src, m);
+fs.c:  if(n > 0 && off > ip->size){
+fs.c:    ip->size = off;
+fs.c:  if(dp->type != T_DIR)
+fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+fs.c:      return iget(dp->dev, inum);
+fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+fs.c:    if(ip->type != T_DIR){
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  if(bp + bp->s.size == p->s.ptr){
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:    p->s.ptr = bp;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  if(bp + bp->s.size == p->s.ptr){
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:    p->s.ptr = bp;
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:    p->s.ptr = bp;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:        p->s.size = nunits;
+grep.asm:  hp->s.size = nu;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:      if(p->s.size == nunits)
+grep.asm:        prevp->s.ptr = p->s.ptr;
+grep.asm:        p->s.size -= nunits;
+grep.asm:        p += p->s.size;
+grep.asm:        p->s.size = nunits;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:      if(p->s.size == nunits)
+grep.asm:        prevp->s.ptr = p->s.ptr;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  if(bp + bp->s.size == p->s.ptr){
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm:    p->s.ptr = bp;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  if(bp + bp->s.size == p->s.ptr){
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm:    p->s.ptr = bp;
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm:    p->s.ptr = bp;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:        p->s.size = nunits;
+init.asm:  hp->s.size = nu;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:      if(p->s.size == nunits)
+init.asm:        prevp->s.ptr = p->s.ptr;
+init.asm:        p->s.size -= nunits;
+init.asm:        p += p->s.size;
+init.asm:        p->s.size = nunits;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:      if(p->s.size == nunits)
+init.asm:        prevp->s.ptr = p->s.ptr;
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
+kernel.asm:  memset(bp->data, 0, BSIZE);
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:  ip->ref = 1;
+kernel.asm:  ip->flags = 0;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+kernel.asm:  ip->dev = dev;
+kernel.asm:  ip->inum = inum;
+kernel.asm:  ip->ref = 1;
+kernel.asm:  ip->flags = 0;
+kernel.asm:  ip->dev = dev;
+kernel.asm:  ip->inum = inum;
+kernel.asm:  ip->ref = 1;
+kernel.asm:  ip->flags = 0;
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:    bp = bread(ip->dev, addr);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:    bp = bread(ip->dev, addr);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      a[bn] = addr = balloc(ip->dev);
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:    bp = bread(ip->dev, addr);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      a[bn] = addr = balloc(ip->dev);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      a[bn] = addr = balloc(ip->dev);
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  bp->data[bi/8] &= ~m;
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  bp->data[bi/8] &= ~m;
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:      dip->type = type;
+kernel.asm:      dip->type = type;
+kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip->type = ip->type;
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  dip->type = ip->type;
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  dip->type = ip->type;
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  dip->type = ip->type;
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  ip->ref++;
+kernel.asm:  if(ip == 0 || ip->ref < 1)
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    ip->flags |= I_VALID;
+kernel.asm:    if(ip->type == 0)
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:    ip->type = dip->type;
+kernel.asm:    ip->major = dip->major;
+kernel.asm:    ip->minor = dip->minor;
+kernel.asm:    ip->nlink = dip->nlink;
+kernel.asm:    ip->size = dip->size;
+kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:    ip->type = dip->type;
+kernel.asm:    ip->major = dip->major;
+kernel.asm:    ip->minor = dip->minor;
+kernel.asm:    ip->nlink = dip->nlink;
+kernel.asm:    ip->size = dip->size;
+kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:    ip->type = dip->type;
+kernel.asm:    ip->major = dip->major;
+kernel.asm:    ip->minor = dip->minor;
+kernel.asm:    ip->nlink = dip->nlink;
+kernel.asm:    ip->size = dip->size;
+kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+kernel.asm:    ip->flags |= I_VALID;
+kernel.asm:    if(ip->type == 0)
+kernel.asm:  if(ip == 0 || ip->ref < 1)
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  releasesleep(&ip->lock);
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  releasesleep(&ip->lock);
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    ip->type = 0;
+kernel.asm:    ip->flags = 0;
+kernel.asm:  ip->ref--;
+kernel.asm:    ip->flags = 0;
+kernel.asm:  ip->ref--;
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    if(ip->addrs[i]){
+kernel.asm:      bfree(ip->dev, ip->addrs[i]);
+kernel.asm:      ip->addrs[i] = 0;
+kernel.asm:  if(ip->addrs[NDIRECT]){
+kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    ip->addrs[NDIRECT] = 0;
+kernel.asm:  ip->size = 0;
+kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    ip->addrs[NDIRECT] = 0;
+kernel.asm:  ip->size = 0;
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    ip->type = 0;
+kernel.asm:    ip->flags = 0;
+kernel.asm:      ip->addrs[i] = 0;
+kernel.asm:  if(ip->addrs[NDIRECT]){
+kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:        bfree(ip->dev, a[j]);
+kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    ip->addrs[NDIRECT] = 0;
+kernel.asm:  st->dev = ip->dev;
+kernel.asm:  st->ino = ip->inum;
+kernel.asm:  st->type = ip->type;
+kernel.asm:  st->nlink = ip->nlink;
+kernel.asm:  st->size = ip->size;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:      return iget(dp->dev, inum);
+kernel.asm:      return iget(dp->dev, inum);
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:  ip->ref++;
+kernel.asm:    if(ip->type != T_DIR){
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm://   modify bp->data[]
+kernel.asm://   modify bp->data[]
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:  if(mp->imcrp){
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  p->readopen = 1;
+kernel.asm:  p->writeopen = 1;
+kernel.asm:  p->nwrite = 0;
+kernel.asm:  p->nread = 0;
+kernel.asm:  initlock(&p->lock, "pipe");
+kernel.asm:  p->readopen = 1;
+kernel.asm:  p->writeopen = 1;
+kernel.asm:  p->nwrite = 0;
+kernel.asm:  p->nread = 0;
+kernel.asm:  initlock(&p->lock, "pipe");
+kernel.asm:  p->readopen = 1;
+kernel.asm:  p->writeopen = 1;
+kernel.asm:  p->nwrite = 0;
+kernel.asm:  p->nread = 0;
+kernel.asm:  initlock(&p->lock, "pipe");
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:      if(p->readopen == 0 || proc->killed){
+kernel.asm:        release(&p->lock);
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:  acquire(&p->lock);
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:      if(p->readopen == 0 || proc->killed){
+kernel.asm:        release(&p->lock);
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:      release(&p->lock);
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:      release(&p->lock);
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:      release(&p->lock);
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:      release(&p->lock);
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:    if(p->nread == p->nwrite)
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:      release(&p->lock);
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:    if(p->nread == p->nwrite)
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:      release(&p->lock);
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:  p->alarmTime=-1; ///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+kernel.asm:  p->state = EMBRYO;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:  p->alarmTime=-1; ///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+kernel.asm:  p->state = EMBRYO;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+kernel.asm:  if((p->kstack = kalloc()) == 0){
+kernel.asm:  sp = p->kstack + KSTACKSIZE;
+kernel.asm:  sp -= sizeof *p->tf;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  sp = p->kstack + KSTACKSIZE;
+kernel.asm:  sp -= sizeof *p->tf;
+kernel.asm:  p->tf = (struct trapframe*)sp;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:  if((p->kstack = kalloc()) == 0){
+kernel.asm:    p->state = UNUSED;
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+kernel.asm:  p->sz = PGSIZE;
+kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+kernel.asm:  p->sz = PGSIZE;
+kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+kernel.asm:  p->tf->ss = p->tf->ds;
+kernel.asm:  p->tf->eflags = FL_IF;
+kernel.asm:  p->tf->esp = PGSIZE;
+kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
+kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+kernel.asm:  p->sz = PGSIZE;
+kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+kernel.asm:  p->tf->es = p->tf->ds;
+kernel.asm:  p->tf->ss = p->tf->ds;
+kernel.asm:  p->tf->eflags = FL_IF;
+kernel.asm:  p->tf->esp = PGSIZE;
+kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
+kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
+kernel.asm:  p->cwd = namei("/");
+kernel.asm:  // this assignment to p->state lets other cores
+kernel.asm:  p->state = RUNNABLE;
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+kernel.asm:  np->cwd = idup(proc->cwd);
+kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+kernel.asm:  pid = np->pid;
+kernel.asm:  np->state = RUNNABLE;
+kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:      if(p->state != RUNNABLE)
+kernel.asm:      p->state = RUNNING;
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:      p->state = RUNNING;
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:      // It should have changed its p->state before coming back.
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:      // It should have changed its p->state before coming back.
+kernel.asm:      // It should have changed its p->state before coming back.
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:      if(p->state == ZOMBIE)
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:      if(p->state == ZOMBIE)
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:  // change p->state and then call sched.
+kernel.asm:      if(p->parent != proc)
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:      if(p->parent != proc)
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:      if(p->parent != proc)
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:        p->kstack = 0;
+kernel.asm:        freevm(p->pgdir);
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:        p->kstack = 0;
+kernel.asm:        freevm(p->pgdir);
+kernel.asm:        p->pid = 0;
+kernel.asm:        p->parent = 0;
+kernel.asm:        p->name[0] = 0;
+kernel.asm:        p->killed = 0;
+kernel.asm:        p->state = UNUSED;
+kernel.asm:        p->parent = 0;
+kernel.asm:        p->name[0] = 0;
+kernel.asm:        p->killed = 0;
+kernel.asm:        p->state = UNUSED;
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:        p->state = RUNNABLE;
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:        p->state = RUNNABLE;
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+kernel.asm:      state = states[p->state];
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+kernel.asm:      state = states[p->state];
+kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:        if(p->pid == pid) {
+kernel.asm:            p->pending= p->pending | (1 << (signum-1)); //set the signal
+kernel.asm:        if(p->pid == pid) {
+kernel.asm:            p->pending= p->pending | (1 << (signum-1)); //set the signal
+kernel.asm:      if(p->state == RUNNABLE || p->state==RUNNING || p->state==SLEEPING){ //update only on active process
+kernel.asm:        if(p->alarmTime > 0) { //decrease remaining ticks until alarm
+kernel.asm:            p->alarmTime--;
+kernel.asm:        if(p->alarmTime == 1) { //perform the alarm! change pending
+kernel.asm:      if(p->state == RUNNABLE || p->state==RUNNING || p->state==SLEEPING){ //update only on active process
+kernel.asm:        if(p->alarmTime > 0) { //decrease remaining ticks until alarm
+kernel.asm:            p->alarmTime--;
+kernel.asm:        if(p->alarmTime == 1) { //perform the alarm! change pending
+kernel.asm:            p->pending = p->pending | 1 << (SIGALRM - 1);   // enable alarm
+kernel.asm:        if(p->alarmTime == 1) { //perform the alarm! change pending
+kernel.asm:            p->pending = p->pending | 1 << (SIGALRM - 1);   // enable alarm
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+kernel.asm:  ip->major = major;
+kernel.asm:  ip->minor = minor;
+kernel.asm:  ip->nlink = 1;
+kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  ip->minor = minor;
+kernel.asm:  ip->nlink = 1;
+kernel.asm:    dp->nlink++;  // for ".."
+kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:  ip->nlink++;
+kernel.asm:  ip->nlink++;
+kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+kernel.asm:  ip->nlink--;
+kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+kernel.asm:  ip->nlink--;
+kernel.asm:  ip->nlink--;
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    dp->nlink--;
+kernel.asm:  ip->nlink--;
+kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    dp->nlink--;
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    dp->nlink--;
+kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:  if(p->kstack == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+kernel.asm:  if(p->kstack == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  if(p->kstack == 0)
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  if(bp + bp->s.size == p->s.ptr){
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm:    p->s.ptr = bp;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  if(bp + bp->s.size == p->s.ptr){
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm:    p->s.ptr = bp;
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm:    p->s.ptr = bp;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:        p->s.size = nunits;
+kill.asm:  hp->s.size = nu;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:      if(p->s.size == nunits)
+kill.asm:        prevp->s.ptr = p->s.ptr;
+kill.asm:        p->s.size -= nunits;
+kill.asm:        p += p->s.size;
+kill.asm:        p->s.size = nunits;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:      if(p->s.size == nunits)
+kill.asm:        prevp->s.ptr = p->s.ptr;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  if(bp + bp->s.size == p->s.ptr){
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm:    p->s.ptr = bp;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  if(bp + bp->s.size == p->s.ptr){
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm:    p->s.ptr = bp;
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm:    p->s.ptr = bp;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:        p->s.size = nunits;
+ln.asm:  hp->s.size = nu;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:      if(p->s.size == nunits)
+ln.asm:        prevp->s.ptr = p->s.ptr;
+ln.asm:        p->s.size -= nunits;
+ln.asm:        p += p->s.size;
+ln.asm:        p->s.size = nunits;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:      if(p->s.size == nunits)
+ln.asm:        prevp->s.ptr = p->s.ptr;
+log.c://   modify bp->data[]
+ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  if(bp + bp->s.size == p->s.ptr){
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:    p->s.ptr = bp;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  if(bp + bp->s.size == p->s.ptr){
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:    p->s.ptr = bp;
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:    p->s.ptr = bp;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:        p->s.size = nunits;
+ls.asm:  hp->s.size = nu;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:      if(p->s.size == nunits)
+ls.asm:        prevp->s.ptr = p->s.ptr;
+ls.asm:        p->s.size -= nunits;
+ls.asm:        p += p->s.size;
+ls.asm:        p->s.size = nunits;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:      if(p->s.size == nunits)
+ls.asm:        prevp->s.ptr = p->s.ptr;
+ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:        p->s.size = nunits;
+mkdir.asm:  hp->s.size = nu;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:      if(p->s.size == nunits)
+mkdir.asm:        prevp->s.ptr = p->s.ptr;
+mkdir.asm:        p->s.size -= nunits;
+mkdir.asm:        p += p->s.size;
+mkdir.asm:        p->s.size = nunits;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:      if(p->s.size == nunits)
+mkdir.asm:        prevp->s.ptr = p->s.ptr;
+mp.c:    if((mp = mpsearch1(p-1024, 1024)))
+mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+mp.c:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+mp.c:  if(mp->imcrp){
+Notes:blocks and inodes have ad-hoc sleep-locks
+pipe.c:  p->readopen = 1;
+pipe.c:  p->writeopen = 1;
+pipe.c:  p->nwrite = 0;
+pipe.c:  p->nread = 0;
+pipe.c:  initlock(&p->lock, "pipe");
+pipe.c:  acquire(&p->lock);
+pipe.c:    p->writeopen = 0;
+pipe.c:    wakeup(&p->nread);
+pipe.c:    p->readopen = 0;
+pipe.c:    wakeup(&p->nwrite);
+pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
+pipe.c:    release(&p->lock);
+pipe.c:    release(&p->lock);
+pipe.c:  acquire(&p->lock);
+pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+pipe.c:      if(p->readopen == 0 || proc->killed){
+pipe.c:        release(&p->lock);
+pipe.c:      wakeup(&p->nread);
+pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+pipe.c:  release(&p->lock);
+pipe.c:  acquire(&p->lock);
+pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+pipe.c:      release(&p->lock);
+pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+pipe.c:    if(p->nread == p->nwrite)
+pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
+pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+pipe.c:  release(&p->lock);
+proc.c:    if(p->state == UNUSED)
+proc.c:  p->alarmTime=-1; ///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+proc.c:  p->state = EMBRYO;
+proc.c:  p->alarmTime=-1;
+proc.c:  p->pid = nextpid++;
+proc.c:      p->sigFuncs[i] = &defaultHandler;
+proc.c:  if((p->kstack = kalloc()) == 0){
+proc.c:    p->state = UNUSED;
+proc.c:  sp = p->kstack + KSTACKSIZE;
+proc.c:  sp -= sizeof *p->tf;
+proc.c:  p->tf = (struct trapframe*)sp;
+proc.c:  sp -= sizeof *p->context;
+proc.c:  p->context = (struct context*)sp;
+proc.c:  memset(p->context, 0, sizeof *p->context);
+proc.c:  p->context->eip = (uint)forkret;
+proc.c:  if((p->pgdir = setupkvm()) == 0)
+proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+proc.c:  p->sz = PGSIZE;
+proc.c:  memset(p->tf, 0, sizeof(*p->tf));
+proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+proc.c:  p->tf->es = p->tf->ds;
+proc.c:  p->tf->ss = p->tf->ds;
+proc.c:  p->tf->eflags = FL_IF;
+proc.c:  p->tf->esp = PGSIZE;
+proc.c:  p->tf->eip = 0;  // beginning of initcode.S
+proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
+proc.c:  p->cwd = namei("/");
+proc.c:  // this assignment to p->state lets other cores
+proc.c:  p->state = RUNNABLE;
+proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+proc.c:    kfree(np->kstack);
+proc.c:    np->kstack = 0;
+proc.c:    np->state = UNUSED;
+proc.c:  np->sz = proc->sz;
+proc.c:  np->parent = proc;
+proc.c:  *np->tf = *proc->tf;
+proc.c:  np->tf->eax = 0;
+proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
+proc.c:  np->cwd = idup(proc->cwd);
+proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+proc.c:  pid = np->pid;
+proc.c:  np->state = RUNNABLE;
+proc.c:    if(p->parent == proc){
+proc.c:      p->parent = initproc;
+proc.c:      if(p->state == ZOMBIE)
+proc.c:      if(p->parent != proc)
+proc.c:      if(p->state == ZOMBIE){
+proc.c:        pid = p->pid;
+proc.c:        kfree(p->kstack);
+proc.c:        p->kstack = 0;
+proc.c:        freevm(p->pgdir);
+proc.c:        p->pid = 0;
+proc.c:        p->parent = 0;
+proc.c:        p->name[0] = 0;
+proc.c:        p->killed = 0;
+proc.c:        p->state = UNUSED;
+proc.c:      if(p->state != RUNNABLE)
+proc.c:      p->state = RUNNING;
+proc.c:      swtch(&cpu->scheduler, p->context);
+proc.c:      // It should have changed its p->state before coming back.
+proc.c:  // change p->state and then call sched.
+proc.c:    if(p->state == SLEEPING && p->chan == chan)
+proc.c:      p->state = RUNNABLE;
+proc.c:    if(p->pid == pid){
+proc.c:      p->killed = 1;
+proc.c:      if(p->state == SLEEPING)
+proc.c:        p->state = RUNNABLE;
+proc.c:    if(p->state == UNUSED)
+proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+proc.c:      state = states[p->state];
+proc.c:    cprintf("%d %s %s", p->pid, state, p->name);
+proc.c:    if(p->state == SLEEPING){
+proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
+proc.c:        if(p->pid == pid) {
+proc.c:            p->pending= p->pending | (1 << (signum-1)); //set the signal
+proc.c:      if(p->state == RUNNABLE || p->state==RUNNING || p->state==SLEEPING){ //update only on active process
+proc.c:        if(p->alarmTime > 0) { //decrease remaining ticks until alarm
+proc.c:            p->alarmTime--;
+proc.c:        if(p->alarmTime == 1) { //perform the alarm! change pending
+proc.c:            p->pending = p->pending | 1 << (SIGALRM - 1);   // enable alarm
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  if(bp + bp->s.size == p->s.ptr){
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm:    p->s.ptr = bp;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  if(bp + bp->s.size == p->s.ptr){
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm:    p->s.ptr = bp;
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm:    p->s.ptr = bp;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:        p->s.size = nunits;
+rm.asm:  hp->s.size = nu;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:      if(p->s.size == nunits)
+rm.asm:        prevp->s.ptr = p->s.ptr;
+rm.asm:        p->s.size -= nunits;
+rm.asm:        p += p->s.size;
+rm.asm:        p->s.size = nunits;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:      if(p->s.size == nunits)
+rm.asm:        prevp->s.ptr = p->s.ptr;
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sanity.asm:  if(bp + bp->s.size == p->s.ptr){
+sanity.asm:    bp->s.size += p->s.ptr->s.size;
+sanity.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sanity.asm:    bp->s.ptr = p->s.ptr;
+sanity.asm:  if(p + p->s.size == bp){
+sanity.asm:    p->s.size += bp->s.size;
+sanity.asm:    p->s.ptr = bp->s.ptr;
+sanity.asm:    p->s.ptr = bp;
+sanity.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sanity.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sanity.asm:  if(bp + bp->s.size == p->s.ptr){
+sanity.asm:    bp->s.size += p->s.ptr->s.size;
+sanity.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sanity.asm:    bp->s.ptr = p->s.ptr;
+sanity.asm:  if(p + p->s.size == bp){
+sanity.asm:    p->s.size += bp->s.size;
+sanity.asm:    p->s.ptr = bp->s.ptr;
+sanity.asm:    p->s.ptr = bp;
+sanity.asm:    bp->s.size += p->s.ptr->s.size;
+sanity.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sanity.asm:    bp->s.ptr = p->s.ptr;
+sanity.asm:  if(p + p->s.size == bp){
+sanity.asm:    p->s.size += bp->s.size;
+sanity.asm:    p->s.ptr = bp->s.ptr;
+sanity.asm:    p->s.ptr = bp;
+sanity.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sanity.asm:    if(p->s.size >= nunits){
+sanity.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sanity.asm:    if(p->s.size >= nunits){
+sanity.asm:        p->s.size = nunits;
+sanity.asm:  hp->s.size = nu;
+sanity.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sanity.asm:    if(p->s.size >= nunits){
+sanity.asm:      if(p->s.size == nunits)
+sanity.asm:        prevp->s.ptr = p->s.ptr;
+sanity.asm:        p->s.size -= nunits;
+sanity.asm:        p += p->s.size;
+sanity.asm:        p->s.size = nunits;
+sanity.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sanity.asm:    if(p->s.size >= nunits){
+sanity.asm:      if(p->s.size == nunits)
+sanity.asm:        prevp->s.ptr = p->s.ptr;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  if(bp + bp->s.size == p->s.ptr){
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    p->s.ptr = bp;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  if(bp + bp->s.size == p->s.ptr){
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    p->s.ptr = bp;
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    p->s.ptr = bp;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:        p->s.size = nunits;
+sh.asm:  hp->s.size = nu;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:      if(p->s.size == nunits)
+sh.asm:        prevp->s.ptr = p->s.ptr;
+sh.asm:        p->s.size -= nunits;
+sh.asm:        p += p->s.size;
+sh.asm:        p->s.size = nunits;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:      if(p->s.size == nunits)
+sh.asm:        prevp->s.ptr = p->s.ptr;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:        p->s.size = nunits;
+stressfs.asm:  hp->s.size = nu;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:      if(p->s.size == nunits)
+stressfs.asm:        prevp->s.ptr = p->s.ptr;
+stressfs.asm:        p->s.size -= nunits;
+stressfs.asm:        p += p->s.size;
+stressfs.asm:        p->s.size = nunits;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:      if(p->s.size == nunits)
+stressfs.asm:        prevp->s.ptr = p->s.ptr;
+symlink.patch:     ip = idup(cp->cwd);
+sysfile.c:  if(ip->type == T_DIR){
+sysfile.c:  ip->nlink++;
+sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+sysfile.c:  ip->nlink--;
+sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+sysfile.c:  if(ip->nlink < 1)
+sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
+sysfile.c:  if(ip->type == T_DIR){
+sysfile.c:    dp->nlink--;
+sysfile.c:  ip->nlink--;
+sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
+sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
+sysfile.c:  ip->major = major;
+sysfile.c:  ip->minor = minor;
+sysfile.c:  ip->nlink = 1;
+sysfile.c:    dp->nlink++;  // for ".."
+sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
+sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
+sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
+sysfile.c:  if(ip->type != T_DIR){
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  if(bp + bp->s.size == p->s.ptr){
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm:    p->s.ptr = bp;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  if(bp + bp->s.size == p->s.ptr){
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm:    p->s.ptr = bp;
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm:    p->s.ptr = bp;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:        p->s.size = nunits;
+thread.asm:  hp->s.size = nu;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:      if(p->s.size == nunits)
+thread.asm:        prevp->s.ptr = p->s.ptr;
+thread.asm:        p->s.size -= nunits;
+thread.asm:        p += p->s.size;
+thread.asm:        p->s.size = nunits;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:      if(p->s.size == nunits)
+thread.asm:        prevp->s.ptr = p->s.ptr;
+TRICKS:at that point, cp->tf is set to point to a trap frame
+TRICKS:The code in fork needs to read np->pid before
+TRICKS:setting np->state to RUNNABLE.  The following
+TRICKS:	  np->state = RUNNABLE;
+TRICKS:	  return np->pid; // oops
+TRICKS:After setting np->state to RUNNABLE, some other CPU
+TRICKS:"return np->pid". Even saving a copy of np->pid before
+TRICKS:setting np->state isn't safe, since the compiler is
+TRICKS:The real code saves a copy of np->pid, then acquires a lock
+TRICKS:around the write to np->state. The acquire() prevents the
+umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+umalloc.c:  if(bp + bp->s.size == p->s.ptr){
+umalloc.c:    bp->s.size += p->s.ptr->s.size;
+umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
+umalloc.c:    bp->s.ptr = p->s.ptr;
+umalloc.c:  if(p + p->s.size == bp){
+umalloc.c:    p->s.size += bp->s.size;
+umalloc.c:    p->s.ptr = bp->s.ptr;
+umalloc.c:    p->s.ptr = bp;
+umalloc.c:  hp->s.size = nu;
+umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+umalloc.c:    if(p->s.size >= nunits){
+umalloc.c:      if(p->s.size == nunits)
+umalloc.c:        prevp->s.ptr = p->s.ptr;
+umalloc.c:        p->s.size -= nunits;
+umalloc.c:        p += p->s.size;
+umalloc.c:        p->s.size = nunits;
+usertests.c:// does chdir() call iput(p->cwd) in a transaction?
+usertests.c:// does exit() call iput(p->cwd) in a transaction?
+vm.c:  if(p->kstack == 0)
+vm.c:  if(p->pgdir == 0)
+vm.c:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+vm.c:  lcr3(V2P(p->pgdir));  // switch to process's address space
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  if(bp + bp->s.size == p->s.ptr){
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm:    p->s.ptr = bp;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  if(bp + bp->s.size == p->s.ptr){
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm:    p->s.ptr = bp;
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm:    p->s.ptr = bp;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:        p->s.size = nunits;
+wc.asm:  hp->s.size = nu;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:      if(p->s.size == nunits)
+wc.asm:        prevp->s.ptr = p->s.ptr;
+wc.asm:        p->s.size -= nunits;
+wc.asm:        p += p->s.size;
+wc.asm:        p->s.size = nunits;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:      if(p->s.size == nunits)
+wc.asm:        prevp->s.ptr = p->s.ptr;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:        p->s.size = nunits;
+zombie.asm:  hp->s.size = nu;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:      if(p->s.size == nunits)
+zombie.asm:        prevp->s.ptr = p->s.ptr;
+zombie.asm:        p->s.size -= nunits;
+zombie.asm:        p += p->s.size;
+zombie.asm:        p->s.size = nunits;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:      if(p->s.size == nunits)
+zombie.asm:        prevp->s.ptr = p->s.ptr;
diff --git a/asm.h b/asm.h
old mode 100644
new mode 100755
diff --git a/bio.c b/bio.c
old mode 100644
new mode 100755
diff --git a/bootasm.S b/bootasm.S
old mode 100644
new mode 100755
diff --git a/bootmain.c b/bootmain.c
old mode 100644
new mode 100755
diff --git a/bsem.c b/bsem.c
new file mode 100644
index 0000000..7d6a895
--- /dev/null
+++ b/bsem.c
@@ -0,0 +1,72 @@
+#include "bsem.h"
+
+struct bsem* bsems[MAX_BSEM];
+
+//go over the array, the first cell that is unintialized we will put the new binary semaphore!
+int bsem_alloc(){
+    int i = 0;
+    for (i = 0; i < MAX_BSEM; i++){
+        if(bsems[i] == 0){ //meaning the cell is unintialized
+            bsems[i] = malloc(sizeof(struct bsem));
+            bsems[i]->lock = 0;
+            bsems[i]->state = 1;
+            return i;
+        }
+    }
+    return -1;
+}
+
+void bsem_free(int desc){
+    free(bsems[desc]);
+}
+
+void bsem_down(int desc){
+    alarm(0);
+    if(bsems[desc]->lock==1){ //if locked -> sleep
+        getCurrThread()->lockUp=desc;
+        uthread_sleep(1);
+    }
+    bsems[desc]->lock=1; //the thread lock's the semaphore
+    alarm(UTHREAD_QUANTA);
+}
+
+
+
+void bsem_up(int desc){
+    alarm(0);
+    if(bsems[desc]->lock==0){ //if semaphore is already unlocked- just exit!
+        return;
+    }
+    if(bsems[desc]->lock==1){ //if semaphore is locked we can wakeup a thread now!
+       bsem_wakeUp(desc);
+    }
+    bsems[desc]->lock=0; //unlocked!
+    alarm(UTHREAD_QUANTA);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/bsem.h b/bsem.h
new file mode 100644
index 0000000..aaf4b04
--- /dev/null
+++ b/bsem.h
@@ -0,0 +1,18 @@
+#include "types.h"
+#include "user.h"
+#include "x86.h"
+#include "thread.h"
+#define MAX_BSEM 128
+
+struct bsem{
+    int lock;
+    int state;
+};
+
+int bsem_alloc();
+
+void bsem_free(int desc);
+
+void bsem_down(int desc);
+
+void bsem_up(int desc);
\ No newline at end of file
diff --git a/btf b/btf
new file mode 100755
index 0000000..3a1633b
--- /dev/null
+++ b/btf
@@ -0,0 +1,8552 @@
+asm.h:// The 0xC0 means the limit is in 4096-byte units
+asm.h:// and (for executable segments) 32-bit mode.
+asm.h:#define STA_E     0x4       // Expand down (non-executable segments)
+asm.h:#define STA_W     0x2       // Writeable (non-executable segments)
+bio.c:    b->next = bcache.head.next;
+bio.c:    b->prev = &bcache.head;
+bio.c:    initsleeplock(&b->lock, "buffer");
+bio.c:    bcache.head.next->prev = b;
+bio.c:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+bio.c:    if(b->dev == dev && b->blockno == blockno){
+bio.c:      b->refcnt++;
+bio.c:      acquiresleep(&b->lock);
+bio.c:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+bio.c:    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+bio.c:      b->dev = dev;
+bio.c:      b->blockno = blockno;
+bio.c:      b->flags = 0;
+bio.c:      b->refcnt = 1;
+bio.c:      acquiresleep(&b->lock);
+bio.c:  if(!(b->flags & B_VALID)) {
+bio.c:  if(!holdingsleep(&b->lock))
+bio.c:  b->flags |= B_DIRTY;
+bio.c:  if(!holdingsleep(&b->lock))
+bio.c:  releasesleep(&b->lock);
+bio.c:  b->refcnt--;
+bio.c:  if (b->refcnt == 0) {
+bio.c:    b->next->prev = b->prev;
+bio.c:    b->prev->next = b->next;
+bio.c:    b->next = bcache.head.next;
+bio.c:    b->prev = &bcache.head;
+bio.c:    bcache.head.next->prev = b;
+bio.d:bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+Binary file bio.o matches
+Binary file bootasm.o matches
+bootasm.S:# Start the first CPU: switch to 32-bit protected mode, jump into C.
+bootasm.S:.code16                       # Assemble for 16-bit mode
+bootasm.S:  movw    %ax,%ds             # -> Data Segment
+bootasm.S:  movw    %ax,%es             # -> Extra Segment
+bootasm.S:  movw    %ax,%ss             # -> Stack Segment
+bootasm.S:  movb    $0xd1,%al               # 0xd1 -> port 0x64
+bootasm.S:  movb    $0xdf,%al               # 0xdf -> port 0x60
+bootasm.S:  # Complete the transition to 32-bit protected mode by using a long jmp
+bootasm.S:.code32  # Tell assembler to generate 32-bit code now.
+bootasm.S:  # Set up the protected-mode data segment registers
+bootasm.S:  movw    %ax, %ds                # -> DS: Data Segment
+bootasm.S:  movw    %ax, %es                # -> ES: Extra Segment
+bootasm.S:  movw    %ax, %ss                # -> SS: Stack Segment
+bootasm.S:  movw    %ax, %fs                # -> FS
+bootasm.S:  movw    %ax, %gs                # -> GS
+bootasm.S:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+bootasm.S:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+bootasm.S:  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
+bootblock.asm:bootblock.o:     file format elf32-i386
+bootblock.asm:.code16                       # Assemble for 16-bit mode
+bootblock.asm:  movw    %ax,%ds             # -> Data Segment
+bootblock.asm:  movw    %ax,%es             # -> Extra Segment
+bootblock.asm:  movw    %ax,%ss             # -> Stack Segment
+bootblock.asm:  movb    $0xd1,%al               # 0xd1 -> port 0x64
+bootblock.asm:  movb    $0xdf,%al               # 0xdf -> port 0x60
+bootblock.asm:  # Complete the transition to 32-bit protected mode by using a long jmp
+bootblock.asm:.code32  # Tell assembler to generate 32-bit code now.
+bootblock.asm:  # Set up the protected-mode data segment registers
+bootblock.asm:  movw    %ax, %ds                # -> DS: Data Segment
+bootblock.asm:  movw    %ax, %es                # -> ES: Extra Segment
+bootblock.asm:  movw    %ax, %ss                # -> SS: Stack Segment
+bootblock.asm:  movw    %ax, %fs                # -> FS
+bootblock.asm:  movw    %ax, %gs                # -> GS
+bootblock.asm:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+bootblock.asm:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+bootblock.asm:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+bootblock.asm:  pa -= offset % SECTSIZE;
+bootblock.asm:  // We'd write more to memory than asked, but it doesn't matter --
+bootblock.asm:  // We'd write more to memory than asked, but it doesn't matter --
+bootblock.asm:  if(elf->magic != ELF_MAGIC)
+bootblock.asm:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+bootblock.asm:  eph = ph + elf->phnum;
+bootblock.asm:    pa = (uchar*)ph->paddr;
+bootblock.asm:    readseg(pa, ph->filesz, ph->off);
+bootblock.asm:    if(ph->memsz > ph->filesz)
+bootblock.asm:      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+bootblock.asm:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+bootblock.asm:  eph = ph + elf->phnum;
+bootblock.asm:  entry = (void(*)(void))(elf->entry);
+Binary file bootblock.o matches
+bootmain.c:// bootasm.S has put the processor into protected 32-bit mode.
+bootmain.c:  if(elf->magic != ELF_MAGIC)
+bootmain.c:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+bootmain.c:  eph = ph + elf->phnum;
+bootmain.c:    pa = (uchar*)ph->paddr;
+bootmain.c:    readseg(pa, ph->filesz, ph->off);
+bootmain.c:    if(ph->memsz > ph->filesz)
+bootmain.c:      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+bootmain.c:  entry = (void(*)(void))(elf->entry);
+bootmain.c:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+bootmain.c:  pa -= offset % SECTSIZE;
+bootmain.c:  // We'd write more to memory than asked, but it doesn't matter --
+Binary file bootmain.o matches
+BUGS:	can't always runcmd in child -- breaks cd.
+BUGS:	maybe should hard-code PATH=/ ?
+Binary file _cat matches
+cat.asm:_cat:     file format elf32-i386
+cat.asm: 133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+cat.asm: 13c:	88 5a ff             	mov    %bl,-0x1(%edx)
+cat.asm:  return (uchar)*p - (uchar)*q;
+cat.asm:  return (uchar)*p - (uchar)*q;
+cat.asm: 23b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+cat.asm: 25c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+cat.asm: 267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+cat.asm:    return -1;
+cat.asm:    return -1;
+cat.asm:    return -1;
+cat.asm: 2ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+cat.asm:    n = n*10 + *s++ - '0';
+cat.asm: 2fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+cat.asm: 305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+cat.asm:    n = n*10 + *s++ - '0';
+cat.asm:  while(n-- > 0)
+cat.asm:  while(n-- > 0)
+cat.asm:  while(n-- > 0)
+cat.asm:    x = -xx;
+cat.asm: 42d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+cat.asm: 434:	89 75 c0             	mov    %esi,-0x40(%ebp)
+cat.asm:    x = -xx;
+cat.asm: 43b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+cat.asm: 457:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+cat.asm: 45c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+cat.asm:    buf[i++] = '-';
+cat.asm: 466:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+cat.asm:  while(--i >= 0)
+cat.asm: 46b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+cat.asm: 470:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+cat.asm: 487:	88 45 d7             	mov    %al,-0x29(%ebp)
+cat.asm:    buf[i++] = '-';
+cat.asm:  while(--i >= 0)
+cat.asm:    x = -xx;
+cat.asm: 4a4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+cat.asm: 4c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+cat.asm: 4e1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+cat.asm: 4f3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+cat.asm: 4fe:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+cat.asm: 548:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+cat.asm: 55f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+cat.asm: 562:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+cat.asm: 56b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+cat.asm: 56e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+cat.asm: 580:	88 55 e7             	mov    %dl,-0x19(%ebp)
+cat.asm: 588:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+cat.asm: 5b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+cat.asm: 5ca:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+cat.asm: 5d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+cat.asm: 5db:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+cat.asm: 5f8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+cat.asm: 5fb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+cat.asm: 628:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+cat.asm: 63c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+cat.asm: 650:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+cat.asm: 66b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+cat.asm: 674:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+cat.asm: 686:	88 45 e4             	mov    %al,-0x1c(%ebp)
+cat.asm: 689:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+cat.asm: 695:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm: 6b0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  if(bp + bp->s.size == p->s.ptr){
+cat.asm: 6d0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm: 6da:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm:    p->s.ptr = bp;
+cat.asm:  bp = (Header*)ap - 1;
+cat.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+cat.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+cat.asm:  if(bp + bp->s.size == p->s.ptr){
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm: 6fb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm: 702:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm: 70f:	03 4b fc             	add    -0x4(%ebx),%ecx
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm:    p->s.ptr = bp;
+cat.asm:    bp->s.size += p->s.ptr->s.size;
+cat.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+cat.asm:    bp->s.ptr = p->s.ptr;
+cat.asm:  if(p + p->s.size == bp){
+cat.asm:    p->s.size += bp->s.size;
+cat.asm:    p->s.ptr = bp->s.ptr;
+cat.asm: 71a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+cat.asm:    p->s.ptr = bp;
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm: 768:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:        p->s.size = nunits;
+cat.asm: 783:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+cat.asm:  if(p == (char*)-1)
+cat.asm:  hp->s.size = nu;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:      if(p->s.size == nunits)
+cat.asm:        prevp->s.ptr = p->s.ptr;
+cat.asm:        p->s.size -= nunits;
+cat.asm:        p += p->s.size;
+cat.asm:        p->s.size = nunits;
+cat.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+cat.asm:    if(p->s.size >= nunits){
+cat.asm:      if(p->s.size == nunits)
+cat.asm:        prevp->s.ptr = p->s.ptr;
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+cat.asm:    return newThread->tid;
+cat.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+cat.asm:    return newThread->tid;
+cat.asm:    thread->state=RUNNABLE;
+cat.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+cat.asm:    thread->state=RUNNABLE;
+cat.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+cat.asm:	ttable.threads[i]->state=RUNNABLE;
+cat.asm:    thread->state=RUNNABLE;
+cat.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+cat.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+cat.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+cat.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+cat.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+cat.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+cat.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+cat.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+cat.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+cat.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+cat.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+cat.asm:  //1. store tf in the thread->btf
+cat.asm:  *thread->btf = tf;
+cat.asm:  if(nextThread->isFirstRun==1){
+cat.asm:    //move the tf that is stored in nextThread->btf to the stack
+cat.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+cat.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+cat.asm:  nextThread->state=RUNNING;
+cat.asm:  nextThread->isFirstRun=0;
+cat.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+cat.asm:  nextThread->state=RUNNING;
+cat.asm:  nextThread->isFirstRun=0;
+cat.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+cat.asm:    thread->state=RUNNABLE;
+cat.asm:  *thread->btf = tf;
+cat.asm:  if(nextThread->isFirstRun==1){
+cat.asm: 9d3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+cat.asm: 9db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+cat.asm:    ntf->esp=nextThread->btf->esp;
+cat.asm:    ntf->eip=nextThread->btf->eip;
+cat.asm:      //ttable.threads[i]->utstack=0;
+cat.asm:      //ttable.threads[i]->tid=0;
+cat.asm:      //ttable.threads[i]->esp=0;
+cat.asm:      //ttable.threads[i]->ebp=0;
+cat.asm:      //ttable.threads[i]->eip=0;
+cat.asm:      ttable.threads[i]->state=EMPTY;
+cat.asm:      //ttable.threads[i]->sleepTime=0
+cat.asm:      //ttable.threads[i]->sleepInit=0;
+cat.asm:      ttable.threads[i]->isFirstRun=1;
+cat.asm:      //ttable.threads[i]->btf=0;
+cat.asm:      //ttable.threads[i]->waitingExitTid=0;
+cat.asm:    thread->tid = threadTidCounter;
+cat.asm:    thread->state = RUNNING;
+cat.asm:      //ttable.threads[i]->btf=0;
+cat.asm:      //ttable.threads[i]->waitingExitTid=0;
+cat.asm:    thread->tid = threadTidCounter;
+cat.asm:    thread->state = RUNNING;
+cat.asm:    thread->tid = threadTidCounter;
+cat.asm:    thread->state = RUNNING;
+cat.asm:        return -1;*/
+cat.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+cat.asm:      //ttable.threads[i]->btf=0;
+cat.asm:      //ttable.threads[i]->waitingExitTid=0;
+cat.asm:    thread->tid = threadTidCounter;
+cat.asm:    thread->state = RUNNING;
+cat.asm:        return -1;*/
+cat.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+cat.asm:      return -1;
+cat.asm:        return -1;*/
+cat.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+cat.asm:      return -1;
+cat.asm:    if (threadNum == MAX_UTHREADS - 1) 
+cat.asm:        return -1;
+cat.asm:      if(ttable.threads[i]->state==EMPTY){
+cat.asm:    newThread->tid = threadTidCounter;
+cat.asm:    newThread->tid = threadTidCounter;
+cat.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+cat.asm:    newThread->tid = threadTidCounter;
+cat.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+cat.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+cat.asm:    esp -= 4;
+cat.asm:    newThread->tid = threadTidCounter;
+cat.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+cat.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+cat.asm:    esp -= 4;
+cat.asm:    esp -= 4;
+cat.asm:    newThread->btf->esp=esp-3*sizeof(int);
+cat.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+cat.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+cat.asm:    esp -= 4;
+cat.asm:    esp -= 4;
+cat.asm:    newThread->btf->esp=esp-3*sizeof(int);
+cat.asm:    newThread->btf->eip=(int)start_func;
+cat.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+cat.asm:    newThread->eip=(int)start_func;//
+cat.asm:    newThread->state = RUNNABLE;
+cat.asm:    return newThread->tid;
+cat.asm:    if (threadNum == MAX_UTHREADS - 1) 
+cat.asm:        return -1;
+cat.asm:    return thread->tid;
+cat.asm:    return thread->tid;
+cat.asm:    return thread->tid;
+cat.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+cat.asm:    return thread->tid;
+cat.asm:      if(ttable.threads[i]->tid==tid){
+cat.asm:      return -1; 
+cat.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+cat.asm:      return -1; 
+cat.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+cat.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+cat.asm:    thread->waitingExitTid=tid;
+cat.asm:    thread->state=BLOCKED;
+cat.asm:      return -1; 
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:	return -1;
+cat.asm:    thread->state=BLOCKED;
+cat.asm:    thread->sleepInit=uptime();
+cat.asm:    thread->sleepTime=ticks;
+cat.asm:	return -1;
+cat.asm:    thread->state=BLOCKED;
+cat.asm:    thread->sleepInit=uptime();
+cat.asm:    thread->sleepTime=ticks;
+cat.asm:	return -1;
+cat.asm:    free(th->utstack);
+cat.asm:    th->tid=0;
+cat.asm:    th->esp=0;
+cat.asm:    th->ebp=0;
+cat.asm:    th->eip=0;
+cat.asm:    th->state=EMPTY;
+cat.asm:    th->sleepTime=0;
+cat.asm:    th->sleepInit=0;
+cat.asm:    th->isFirstRun=1;
+cat.asm:    th->btf=0;
+cat.asm:    th->waitingExitTid=0;
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:    th->isFirstRun=1;
+cat.asm:    th->btf=0;
+cat.asm:    th->waitingExitTid=0;
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+cat.asm:      if(ttable.threads[i]->state==RUNNABLE){
+cat.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+cat.asm:	ttable.threads[i]->state=RUNNABLE;
+cat.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+cat.asm:	ttable.threads[i]->state=RUNNABLE;
+cat.asm:    threadsCounter--;
+cat.asm:    threadsCounter--;
+cat.d:cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file cat.o matches
+console.c:    x = -xx;
+console.c:    buf[i++] = '-';
+console.c:  while(--i >= 0)
+console.c:  cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+console.c:    pos += 80 - pos%80;
+console.c:    if(pos > 0) --pos;
+console.c:    pos -= 80;
+console.c:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+console.c:#define C(x)  ((x)-'@')  // Control-x
+console.c:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+console.c:        input.e--;
+console.c:        input.e--;
+console.c:      if(c != 0 && input.e-input.r < INPUT_BUF){
+console.c:      if(proc->killed){
+console.c:        return -1;
+console.c:        // caller gets a 0-byte result.
+console.c:        input.r--;
+console.c:    --n;
+console.c:  return target - n;
+console.d:console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file console.o matches
+cuth:	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+cuth:	for($j=@lines-1; $j>=0; $j--){
+cuth:			$lines[$j] = "/* CUT-H */\n";
+cuth:			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+cuth:	writefile($file, grep {!/CUT-H/} @lines);
+defs.h:// number of elements in fixed-size array
+dot-bochsrc:# version is only available when you use "--with-wx" on the configure 
+dot-bochsrc:# different platforms.  If you run configure with multiple --with-* options, 
+dot-bochsrc:#   macintosh      use MacOS pre-10
+dot-bochsrc:# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+dot-bochsrc:romimage: file=$BXSHARE/BIOS-bochs-latest
+dot-bochsrc:# This defines cpu-related parameters inside Bochs:
+dot-bochsrc:#  --enable-show-ips option enabled, to find your workstation's capability.
+dot-bochsrc:#  IPS is used to calibrate many time-dependent events within the bochs 
+dot-bochsrc:#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+dot-bochsrc:#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+dot-bochsrc:# OPTROMIMAGE[1-4]:
+dot-bochsrc:# read-only area, typically between C8000 and EFFFF. These optional
+dot-bochsrc:# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+dot-bochsrc:#vgaromimage: file=bios/VGABIOS-elpin-2.40
+dot-bochsrc:vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+dot-bochsrc:#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+dot-bochsrc:# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+dot-bochsrc:# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+dot-bochsrc:# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+dot-bochsrc:#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+dot-bochsrc:#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+dot-bochsrc:#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+dot-bochsrc:#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+dot-bochsrc:#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+dot-bochsrc:#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+dot-bochsrc:#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+dot-bochsrc:#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+dot-bochsrc:ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+dot-bochsrc:ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+dot-bochsrc:#ata0-slave: type=cdrom, path=D:, status=inserted
+dot-bochsrc:#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+dot-bochsrc:#ata0-slave: type=cdrom, path="drive", status=inserted
+dot-bochsrc:#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+dot-bochsrc:# '-' the output is written to the console. If you really don't want it,
+dot-bochsrc:#   logprefix: %t-%e-@%i-%d
+dot-bochsrc:# If you really don't want it, make it /dev/null or '-'. :^(
+dot-bochsrc:debugger_log: -
+dot-bochsrc:# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+dot-bochsrc:# construction for win32), 'mouse' (standard serial mouse - requires
+dot-bochsrc:#      non-continuous sound.  750000 is usually a good value.  This needs a
+dot-bochsrc:# of emulated instructions-per-second your workstation can do, for this
+dot-bochsrc:# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+dot-bochsrc:# connected with the 'mouse' device - requires PCI and USB support).
+dot-bochsrc:#                   non-shared colormap.  This colormap will be used
+dot-bochsrc:#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+dot-bochsrc:#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+dot-bochsrc:# exception is french macs, that do have a "at"-like keyboard.
+dot-bochsrc:# 3 key names (listed below) separated with a '-' character. The old-style
+dot-bochsrc:# syntax (without the '-') still works for the key combinations supported
+dot-bochsrc:#   user_shortcut: keys=ctrl-alt-del
+dot-bochsrc:#user_shortcut: keys=ctrl-alt-del
+dot-bochsrc:# have a 3-button USB mouse.
+dot-bochsrc:#-------------------------
+dot-bochsrc:#-------------------------
+dot-bochsrc:# vgaromimage: :bios:VGABIOS-elpin-2.40
+dot-bochsrc:# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+Binary file _echo matches
+echo.asm:_echo:     file format elf32-i386
+echo.asm:  28:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+echo.asm:  53:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
+echo.asm:  93:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+echo.asm:  9c:	88 5a ff             	mov    %bl,-0x1(%edx)
+echo.asm:  return (uchar)*p - (uchar)*q;
+echo.asm:  return (uchar)*p - (uchar)*q;
+echo.asm: 19b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+echo.asm: 1bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+echo.asm: 1c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+echo.asm:    return -1;
+echo.asm:    return -1;
+echo.asm:    return -1;
+echo.asm: 24a:	8d 42 d0             	lea    -0x30(%edx),%eax
+echo.asm:    n = n*10 + *s++ - '0';
+echo.asm: 25e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+echo.asm: 265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+echo.asm:    n = n*10 + *s++ - '0';
+echo.asm:  while(n-- > 0)
+echo.asm:  while(n-- > 0)
+echo.asm:  while(n-- > 0)
+echo.asm:    x = -xx;
+echo.asm: 38d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+echo.asm: 394:	89 75 c0             	mov    %esi,-0x40(%ebp)
+echo.asm:    x = -xx;
+echo.asm: 39b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+echo.asm: 3b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+echo.asm: 3bc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+echo.asm:    buf[i++] = '-';
+echo.asm: 3c6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+echo.asm:  while(--i >= 0)
+echo.asm: 3cb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+echo.asm: 3d0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+echo.asm: 3e7:	88 45 d7             	mov    %al,-0x29(%ebp)
+echo.asm:    buf[i++] = '-';
+echo.asm:  while(--i >= 0)
+echo.asm:    x = -xx;
+echo.asm: 404:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+echo.asm: 424:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+echo.asm: 441:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+echo.asm: 453:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+echo.asm: 45e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+echo.asm: 4a8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+echo.asm: 4bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+echo.asm: 4c2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+echo.asm: 4cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+echo.asm: 4ce:	8d 45 e7             	lea    -0x19(%ebp),%eax
+echo.asm: 4e0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+echo.asm: 4e8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+echo.asm: 510:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+echo.asm: 52a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+echo.asm: 538:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+echo.asm: 53b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+echo.asm: 558:	88 45 e3             	mov    %al,-0x1d(%ebp)
+echo.asm: 55b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+echo.asm: 588:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+echo.asm: 59c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+echo.asm: 5b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+echo.asm: 5cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+echo.asm: 5d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+echo.asm: 5e6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+echo.asm: 5e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+echo.asm: 5f5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm: 610:	8d 53 f8             	lea    -0x8(%ebx),%edx
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  if(bp + bp->s.size == p->s.ptr){
+echo.asm: 630:	8b 73 fc             	mov    -0x4(%ebx),%esi
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm: 63a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm:    p->s.ptr = bp;
+echo.asm:  bp = (Header*)ap - 1;
+echo.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+echo.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+echo.asm:  if(bp + bp->s.size == p->s.ptr){
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm: 65b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm: 662:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm: 66f:	03 4b fc             	add    -0x4(%ebx),%ecx
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm:    p->s.ptr = bp;
+echo.asm:    bp->s.size += p->s.ptr->s.size;
+echo.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+echo.asm:    bp->s.ptr = p->s.ptr;
+echo.asm:  if(p + p->s.size == bp){
+echo.asm:    p->s.size += bp->s.size;
+echo.asm:    p->s.ptr = bp->s.ptr;
+echo.asm: 67a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+echo.asm:    p->s.ptr = bp;
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm: 6c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:        p->s.size = nunits;
+echo.asm: 6e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+echo.asm:  if(p == (char*)-1)
+echo.asm:  hp->s.size = nu;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:      if(p->s.size == nunits)
+echo.asm:        prevp->s.ptr = p->s.ptr;
+echo.asm:        p->s.size -= nunits;
+echo.asm:        p += p->s.size;
+echo.asm:        p->s.size = nunits;
+echo.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+echo.asm:    if(p->s.size >= nunits){
+echo.asm:      if(p->s.size == nunits)
+echo.asm:        prevp->s.ptr = p->s.ptr;
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+echo.asm:    return newThread->tid;
+echo.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+echo.asm:    return newThread->tid;
+echo.asm:    thread->state=RUNNABLE;
+echo.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+echo.asm:    thread->state=RUNNABLE;
+echo.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+echo.asm:	ttable.threads[i]->state=RUNNABLE;
+echo.asm:    thread->state=RUNNABLE;
+echo.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+echo.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+echo.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+echo.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+echo.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+echo.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+echo.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+echo.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+echo.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+echo.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+echo.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+echo.asm:  //1. store tf in the thread->btf
+echo.asm:  *thread->btf = tf;
+echo.asm:  if(nextThread->isFirstRun==1){
+echo.asm:    //move the tf that is stored in nextThread->btf to the stack
+echo.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+echo.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+echo.asm:  nextThread->state=RUNNING;
+echo.asm:  nextThread->isFirstRun=0;
+echo.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+echo.asm:  nextThread->state=RUNNING;
+echo.asm:  nextThread->isFirstRun=0;
+echo.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+echo.asm:    thread->state=RUNNABLE;
+echo.asm:  *thread->btf = tf;
+echo.asm:  if(nextThread->isFirstRun==1){
+echo.asm: 933:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+echo.asm: 93b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+echo.asm:    ntf->esp=nextThread->btf->esp;
+echo.asm:    ntf->eip=nextThread->btf->eip;
+echo.asm:      //ttable.threads[i]->utstack=0;
+echo.asm:      //ttable.threads[i]->tid=0;
+echo.asm:      //ttable.threads[i]->esp=0;
+echo.asm:      //ttable.threads[i]->ebp=0;
+echo.asm:      //ttable.threads[i]->eip=0;
+echo.asm:      ttable.threads[i]->state=EMPTY;
+echo.asm:      //ttable.threads[i]->sleepTime=0
+echo.asm:      //ttable.threads[i]->sleepInit=0;
+echo.asm:      ttable.threads[i]->isFirstRun=1;
+echo.asm:      //ttable.threads[i]->btf=0;
+echo.asm:      //ttable.threads[i]->waitingExitTid=0;
+echo.asm:    thread->tid = threadTidCounter;
+echo.asm:    thread->state = RUNNING;
+echo.asm:      //ttable.threads[i]->btf=0;
+echo.asm:      //ttable.threads[i]->waitingExitTid=0;
+echo.asm:    thread->tid = threadTidCounter;
+echo.asm:    thread->state = RUNNING;
+echo.asm:    thread->tid = threadTidCounter;
+echo.asm:    thread->state = RUNNING;
+echo.asm:        return -1;*/
+echo.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+echo.asm:      //ttable.threads[i]->btf=0;
+echo.asm:      //ttable.threads[i]->waitingExitTid=0;
+echo.asm:    thread->tid = threadTidCounter;
+echo.asm:    thread->state = RUNNING;
+echo.asm:        return -1;*/
+echo.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+echo.asm:      return -1;
+echo.asm:        return -1;*/
+echo.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+echo.asm:      return -1;
+echo.asm:    if (threadNum == MAX_UTHREADS - 1) 
+echo.asm:        return -1;
+echo.asm:      if(ttable.threads[i]->state==EMPTY){
+echo.asm:    newThread->tid = threadTidCounter;
+echo.asm:    newThread->tid = threadTidCounter;
+echo.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+echo.asm:    newThread->tid = threadTidCounter;
+echo.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+echo.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+echo.asm:    esp -= 4;
+echo.asm:    newThread->tid = threadTidCounter;
+echo.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+echo.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+echo.asm:    esp -= 4;
+echo.asm:    esp -= 4;
+echo.asm:    newThread->btf->esp=esp-3*sizeof(int);
+echo.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+echo.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+echo.asm:    esp -= 4;
+echo.asm:    esp -= 4;
+echo.asm:    newThread->btf->esp=esp-3*sizeof(int);
+echo.asm:    newThread->btf->eip=(int)start_func;
+echo.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+echo.asm:    newThread->eip=(int)start_func;//
+echo.asm:    newThread->state = RUNNABLE;
+echo.asm:    return newThread->tid;
+echo.asm:    if (threadNum == MAX_UTHREADS - 1) 
+echo.asm:        return -1;
+echo.asm:    return thread->tid;
+echo.asm:    return thread->tid;
+echo.asm:    return thread->tid;
+echo.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+echo.asm:    return thread->tid;
+echo.asm:      if(ttable.threads[i]->tid==tid){
+echo.asm:      return -1; 
+echo.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+echo.asm:      return -1; 
+echo.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+echo.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+echo.asm:    thread->waitingExitTid=tid;
+echo.asm:    thread->state=BLOCKED;
+echo.asm:      return -1; 
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:	return -1;
+echo.asm:    thread->state=BLOCKED;
+echo.asm:    thread->sleepInit=uptime();
+echo.asm:    thread->sleepTime=ticks;
+echo.asm:	return -1;
+echo.asm:    thread->state=BLOCKED;
+echo.asm:    thread->sleepInit=uptime();
+echo.asm:    thread->sleepTime=ticks;
+echo.asm:	return -1;
+echo.asm:    free(th->utstack);
+echo.asm:    th->tid=0;
+echo.asm:    th->esp=0;
+echo.asm:    th->ebp=0;
+echo.asm:    th->eip=0;
+echo.asm:    th->state=EMPTY;
+echo.asm:    th->sleepTime=0;
+echo.asm:    th->sleepInit=0;
+echo.asm:    th->isFirstRun=1;
+echo.asm:    th->btf=0;
+echo.asm:    th->waitingExitTid=0;
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:    th->isFirstRun=1;
+echo.asm:    th->btf=0;
+echo.asm:    th->waitingExitTid=0;
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+echo.asm:      if(ttable.threads[i]->state==RUNNABLE){
+echo.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+echo.asm:	ttable.threads[i]->state=RUNNABLE;
+echo.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+echo.asm:	ttable.threads[i]->state=RUNNABLE;
+echo.asm:    threadsCounter--;
+echo.asm:    threadsCounter--;
+echo.d:echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file echo.o matches
+entryother.asm:bootblockother.o:     file format elf32-i386
+entryother.asm:  # Complete the transition to 32-bit protected mode by using a long jmp
+entryother.asm:.code32  # Tell assembler to generate 32-bit code now.
+entryother.asm:  # Set up the protected-mode data segment registers
+entryother.asm:  movw    %ax, %ds                # -> DS: Data Segment
+entryother.asm:  movw    %ax, %es                # -> ES: Extra Segment
+entryother.asm:  movw    %ax, %ss                # -> SS: Stack Segment
+entryother.asm:  movw    %ax, %fs                # -> FS
+entryother.asm:  movw    %ax, %gs                # -> GS
+entryother.asm:  movl    (start-12), %eax
+entryother.asm:  movl    (start-4), %esp
+entryother.asm:  call	 *(start-8)
+entryother.S:# Each non-boot CPU ("AP") is started up in response to a STARTUP
+entryother.S:# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
+entryother.S:# set to XY00:0000, where XY is an 8-bit value sent with the
+entryother.S:# STARTUP. Thus this code must start at a 4096-byte boundary.
+entryother.S:# a newly allocated per-core stack in start-4,the address of the
+entryother.S:# place to jump to (mpenter) in start-8, and the physical address
+entryother.S:# of entrypgdir in start-12.
+entryother.S:  # Complete the transition to 32-bit protected mode by using a long jmp
+entryother.S:.code32  # Tell assembler to generate 32-bit code now.
+entryother.S:  # Set up the protected-mode data segment registers
+entryother.S:  movw    %ax, %ds                # -> DS: Data Segment
+entryother.S:  movw    %ax, %es                # -> ES: Extra Segment
+entryother.S:  movw    %ax, %ss                # -> SS: Stack Segment
+entryother.S:  movw    %ax, %fs                # -> FS
+entryother.S:  movw    %ax, %gs                # -> GS
+entryother.S:  movl    (start-12), %eax
+entryother.S:  movl    (start-4), %esp
+entryother.S:  call	 *(start-8)
+entryother.S:  .word   (gdtdesc - gdt - 1)
+entry.S:  .long (-magic-flags)
+entry.S:  # the assembler produces a PC-relative instruction
+Binary file _ex1 matches
+ex1.asm:_ex1:     file format elf32-i386
+ex1.asm:printf(1,"------------------TestEx1----------------- \n");
+ex1.asm:printf(1,"------------------TestEx1----------------- \n");
+ex1.asm:printf(1,"------------------TestEx1----------------- \n");
+ex1.asm:printf(1,"------------------TestEx1----------------- \n");
+ex1.asm: 103:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+ex1.asm: 10c:	88 5a ff             	mov    %bl,-0x1(%edx)
+ex1.asm:  return (uchar)*p - (uchar)*q;
+ex1.asm:  return (uchar)*p - (uchar)*q;
+ex1.asm: 20b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+ex1.asm: 22c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ex1.asm: 237:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+ex1.asm:    return -1;
+ex1.asm:    return -1;
+ex1.asm:    return -1;
+ex1.asm: 2ba:	8d 42 d0             	lea    -0x30(%edx),%eax
+ex1.asm:    n = n*10 + *s++ - '0';
+ex1.asm: 2ce:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+ex1.asm: 2d5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+ex1.asm:    n = n*10 + *s++ - '0';
+ex1.asm:  while(n-- > 0)
+ex1.asm:  while(n-- > 0)
+ex1.asm:  while(n-- > 0)
+ex1.asm:    x = -xx;
+ex1.asm: 3fd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+ex1.asm: 404:	89 75 c0             	mov    %esi,-0x40(%ebp)
+ex1.asm:    x = -xx;
+ex1.asm: 40b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+ex1.asm: 427:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ex1.asm: 42c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+ex1.asm:    buf[i++] = '-';
+ex1.asm: 436:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+ex1.asm:  while(--i >= 0)
+ex1.asm: 43b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+ex1.asm: 440:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+ex1.asm: 457:	88 45 d7             	mov    %al,-0x29(%ebp)
+ex1.asm:    buf[i++] = '-';
+ex1.asm:  while(--i >= 0)
+ex1.asm:    x = -xx;
+ex1.asm: 474:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+ex1.asm: 494:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+ex1.asm: 4b1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+ex1.asm: 4c3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+ex1.asm: 4ce:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ex1.asm: 518:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+ex1.asm: 52f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+ex1.asm: 532:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+ex1.asm: 53b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+ex1.asm: 53e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ex1.asm: 550:	88 55 e7             	mov    %dl,-0x19(%ebp)
+ex1.asm: 558:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ex1.asm: 580:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ex1.asm: 59a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ex1.asm: 5a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ex1.asm: 5ab:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ex1.asm: 5c8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+ex1.asm: 5cb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+ex1.asm: 5f8:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+ex1.asm: 60c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+ex1.asm: 620:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ex1.asm: 63b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ex1.asm: 644:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ex1.asm: 656:	88 45 e4             	mov    %al,-0x1c(%ebp)
+ex1.asm: 659:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+ex1.asm: 665:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm: 680:	8d 53 f8             	lea    -0x8(%ebx),%edx
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ex1.asm:  if(bp + bp->s.size == p->s.ptr){
+ex1.asm: 6a0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ex1.asm:    bp->s.size += p->s.ptr->s.size;
+ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ex1.asm:    bp->s.ptr = p->s.ptr;
+ex1.asm: 6aa:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ex1.asm:  if(p + p->s.size == bp){
+ex1.asm:    p->s.size += bp->s.size;
+ex1.asm:    p->s.ptr = bp->s.ptr;
+ex1.asm:    p->s.ptr = bp;
+ex1.asm:  bp = (Header*)ap - 1;
+ex1.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ex1.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ex1.asm:  if(bp + bp->s.size == p->s.ptr){
+ex1.asm:    bp->s.size += p->s.ptr->s.size;
+ex1.asm: 6cb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ex1.asm: 6d2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ex1.asm:    bp->s.ptr = p->s.ptr;
+ex1.asm:  if(p + p->s.size == bp){
+ex1.asm:    p->s.size += bp->s.size;
+ex1.asm: 6df:	03 4b fc             	add    -0x4(%ebx),%ecx
+ex1.asm:    p->s.ptr = bp->s.ptr;
+ex1.asm:    p->s.ptr = bp;
+ex1.asm:    bp->s.size += p->s.ptr->s.size;
+ex1.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ex1.asm:    bp->s.ptr = p->s.ptr;
+ex1.asm:  if(p + p->s.size == bp){
+ex1.asm:    p->s.size += bp->s.size;
+ex1.asm:    p->s.ptr = bp->s.ptr;
+ex1.asm: 6ea:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ex1.asm:    p->s.ptr = bp;
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ex1.asm:    if(p->s.size >= nunits){
+ex1.asm: 738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ex1.asm:    if(p->s.size >= nunits){
+ex1.asm:        p->s.size = nunits;
+ex1.asm: 753:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ex1.asm:  if(p == (char*)-1)
+ex1.asm:  hp->s.size = nu;
+ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ex1.asm:    if(p->s.size >= nunits){
+ex1.asm:      if(p->s.size == nunits)
+ex1.asm:        prevp->s.ptr = p->s.ptr;
+ex1.asm:        p->s.size -= nunits;
+ex1.asm:        p += p->s.size;
+ex1.asm:        p->s.size = nunits;
+ex1.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ex1.asm:    if(p->s.size >= nunits){
+ex1.asm:      if(p->s.size == nunits)
+ex1.asm:        prevp->s.ptr = p->s.ptr;
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ex1.asm:    return newThread->tid;
+ex1.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ex1.asm:    return newThread->tid;
+ex1.asm:    thread->state=RUNNABLE;
+ex1.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ex1.asm:    thread->state=RUNNABLE;
+ex1.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ex1.asm:	ttable.threads[i]->state=RUNNABLE;
+ex1.asm:    thread->state=RUNNABLE;
+ex1.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ex1.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ex1.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ex1.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ex1.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ex1.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ex1.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ex1.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ex1.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ex1.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+ex1.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+ex1.asm:  //1. store tf in the thread->btf
+ex1.asm:  *thread->btf = tf;
+ex1.asm:  if(nextThread->isFirstRun==1){
+ex1.asm:    //move the tf that is stored in nextThread->btf to the stack
+ex1.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+ex1.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ex1.asm:  nextThread->state=RUNNING;
+ex1.asm:  nextThread->isFirstRun=0;
+ex1.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ex1.asm:  nextThread->state=RUNNING;
+ex1.asm:  nextThread->isFirstRun=0;
+ex1.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ex1.asm:    thread->state=RUNNABLE;
+ex1.asm:  *thread->btf = tf;
+ex1.asm:  if(nextThread->isFirstRun==1){
+ex1.asm: 9a3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+ex1.asm: 9ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+ex1.asm:    ntf->esp=nextThread->btf->esp;
+ex1.asm:    ntf->eip=nextThread->btf->eip;
+ex1.asm:      //ttable.threads[i]->utstack=0;
+ex1.asm:      //ttable.threads[i]->tid=0;
+ex1.asm:      //ttable.threads[i]->esp=0;
+ex1.asm:      //ttable.threads[i]->ebp=0;
+ex1.asm:      //ttable.threads[i]->eip=0;
+ex1.asm:      ttable.threads[i]->state=EMPTY;
+ex1.asm:      //ttable.threads[i]->sleepTime=0
+ex1.asm:      //ttable.threads[i]->sleepInit=0;
+ex1.asm:      ttable.threads[i]->isFirstRun=1;
+ex1.asm:      //ttable.threads[i]->btf=0;
+ex1.asm:      //ttable.threads[i]->waitingExitTid=0;
+ex1.asm:    thread->tid = threadTidCounter;
+ex1.asm:    thread->state = RUNNING;
+ex1.asm:      //ttable.threads[i]->btf=0;
+ex1.asm:      //ttable.threads[i]->waitingExitTid=0;
+ex1.asm:    thread->tid = threadTidCounter;
+ex1.asm:    thread->state = RUNNING;
+ex1.asm:    thread->tid = threadTidCounter;
+ex1.asm:    thread->state = RUNNING;
+ex1.asm:        return -1;*/
+ex1.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ex1.asm:      //ttable.threads[i]->btf=0;
+ex1.asm:      //ttable.threads[i]->waitingExitTid=0;
+ex1.asm:    thread->tid = threadTidCounter;
+ex1.asm:    thread->state = RUNNING;
+ex1.asm:        return -1;*/
+ex1.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ex1.asm:      return -1;
+ex1.asm:        return -1;*/
+ex1.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ex1.asm:      return -1;
+ex1.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ex1.asm:        return -1;
+ex1.asm:      if(ttable.threads[i]->state==EMPTY){
+ex1.asm:    newThread->tid = threadTidCounter;
+ex1.asm:    newThread->tid = threadTidCounter;
+ex1.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ex1.asm:    newThread->tid = threadTidCounter;
+ex1.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ex1.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ex1.asm:    esp -= 4;
+ex1.asm:    newThread->tid = threadTidCounter;
+ex1.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ex1.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ex1.asm:    esp -= 4;
+ex1.asm:    esp -= 4;
+ex1.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ex1.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ex1.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ex1.asm:    esp -= 4;
+ex1.asm:    esp -= 4;
+ex1.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ex1.asm:    newThread->btf->eip=(int)start_func;
+ex1.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+ex1.asm:    newThread->eip=(int)start_func;//
+ex1.asm:    newThread->state = RUNNABLE;
+ex1.asm:    return newThread->tid;
+ex1.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ex1.asm:        return -1;
+ex1.asm:    return thread->tid;
+ex1.asm:    return thread->tid;
+ex1.asm:    return thread->tid;
+ex1.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+ex1.asm:    return thread->tid;
+ex1.asm:      if(ttable.threads[i]->tid==tid){
+ex1.asm:      return -1; 
+ex1.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ex1.asm:      return -1; 
+ex1.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ex1.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ex1.asm:    thread->waitingExitTid=tid;
+ex1.asm:    thread->state=BLOCKED;
+ex1.asm:      return -1; 
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:	return -1;
+ex1.asm:    thread->state=BLOCKED;
+ex1.asm:    thread->sleepInit=uptime();
+ex1.asm:    thread->sleepTime=ticks;
+ex1.asm:	return -1;
+ex1.asm:    thread->state=BLOCKED;
+ex1.asm:    thread->sleepInit=uptime();
+ex1.asm:    thread->sleepTime=ticks;
+ex1.asm:	return -1;
+ex1.asm:    free(th->utstack);
+ex1.asm:    th->tid=0;
+ex1.asm:    th->esp=0;
+ex1.asm:    th->ebp=0;
+ex1.asm:    th->eip=0;
+ex1.asm:    th->state=EMPTY;
+ex1.asm:    th->sleepTime=0;
+ex1.asm:    th->sleepInit=0;
+ex1.asm:    th->isFirstRun=1;
+ex1.asm:    th->btf=0;
+ex1.asm:    th->waitingExitTid=0;
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:    th->isFirstRun=1;
+ex1.asm:    th->btf=0;
+ex1.asm:    th->waitingExitTid=0;
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ex1.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ex1.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ex1.asm:	ttable.threads[i]->state=RUNNABLE;
+ex1.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ex1.asm:	ttable.threads[i]->state=RUNNABLE;
+ex1.asm:    threadsCounter--;
+ex1.asm:    threadsCounter--;
+Binary file _ex1basicTest matches
+ex1.c:printf(1,"------------------TestEx1----------------- \n");
+ex1.d:ex1.o: ex1.c /usr/include/stdc-predef.h types.h user.h stat.h
+Binary file ex1.o matches
+exec.c:    return -1;
+exec.c:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+exec.c:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+exec.c:  ustack[2] = sp - (argc+1)*4;  // argv pointer
+exec.c:  sp -= (3+argc+1) * 4;
+exec.c:  safestrcpy(proc->name, last, sizeof(proc->name));
+exec.c:  oldpgdir = proc->pgdir;
+exec.c:  proc->pgdir = pgdir;
+exec.c:  proc->sz = sz;
+exec.c:  proc->tf->eip = elf.entry;  // main
+exec.c:  proc->tf->esp = sp;
+exec.c:  return -1;
+exec.d:exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
+Binary file exec.o matches
+file.c:    if(f->ref == 0){
+file.c:      f->ref = 1;
+file.c:  if(f->ref < 1)
+file.c:  f->ref++;
+file.c:  if(f->ref < 1)
+file.c:  if(--f->ref > 0){
+file.c:  f->ref = 0;
+file.c:  f->type = FD_NONE;
+file.c:  if(f->type == FD_INODE){
+file.c:    ilock(f->ip);
+file.c:    stati(f->ip, st);
+file.c:    iunlock(f->ip);
+file.c:  return -1;
+file.c:  if(f->readable == 0)
+file.c:    return -1;
+file.c:  if(f->type == FD_PIPE)
+file.c:    return piperead(f->pipe, addr, n);
+file.c:  if(f->type == FD_INODE){
+file.c:    ilock(f->ip);
+file.c:    if((r = readi(f->ip, addr, f->off, n)) > 0)
+file.c:      f->off += r;
+file.c:    iunlock(f->ip);
+file.c:  if(f->writable == 0)
+file.c:    return -1;
+file.c:  if(f->type == FD_PIPE)
+file.c:    return pipewrite(f->pipe, addr, n);
+file.c:  if(f->type == FD_INODE){
+file.c:    // i-node, indirect block, allocation blocks,
+file.c:    // and 2 blocks of slop for non-aligned writes.
+file.c:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+file.c:      int n1 = n - i;
+file.c:      ilock(f->ip);
+file.c:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+file.c:        f->off += r;
+file.c:      iunlock(f->ip);
+file.c:    return i == n ? n : -1;
+file.d:file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
+file.h:// in-memory copy of an inode
+Binary file file.o matches
+Binary file _forktest matches
+forktest.asm:_forktest:     file format elf32-i386
+forktest.asm:  for(; n > 0; n--){
+forktest.asm:  for(; n > 0; n--){
+forktest.asm:  if(wait() != -1){
+forktest.asm:  for(; n > 0; n--){
+forktest.asm:  if(wait() != -1){
+forktest.asm: 133:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+forktest.asm: 13c:	88 5a ff             	mov    %bl,-0x1(%edx)
+forktest.asm:  return (uchar)*p - (uchar)*q;
+forktest.asm:  return (uchar)*p - (uchar)*q;
+forktest.asm: 23b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+forktest.asm: 25c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+forktest.asm: 267:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+forktest.asm:    return -1;
+forktest.asm:    return -1;
+forktest.asm:    return -1;
+forktest.asm: 2ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+forktest.asm:    n = n*10 + *s++ - '0';
+forktest.asm: 2fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+forktest.asm: 305:	8d 5a d0             	lea    -0x30(%edx),%ebx
+forktest.asm:    n = n*10 + *s++ - '0';
+forktest.asm:  while(n-- > 0)
+forktest.asm:  while(n-- > 0)
+forktest.asm:  while(n-- > 0)
+forktest.c:  for(; n > 0; n--){
+forktest.c:  if(wait() != -1){
+forktest.d:forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file forktest.o matches
+fs.c://   + Log: crash recovery for multi-step updates.
+fs.c:// This file contains the low-level file system manipulation
+fs.c:// routines.  The (higher-level) system call implementations
+fs.c:  memmove(sb, bp->data, sizeof(*sb));
+fs.c:  memset(bp->data, 0, BSIZE);
+fs.c:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+fs.c:        bp->data[bi/8] |= m;  // Mark block in use.
+fs.c:  if((bp->data[bi/8] & m) == 0)
+fs.c:  bp->data[bi/8] &= ~m;
+fs.c:// The kernel keeps a cache of in-use inodes in memory
+fs.c:// inodes include book-keeping information that is
+fs.c:// not stored on disk: ip->ref and ip->flags.
+fs.c:// An inode and its in-memory represtative go through a
+fs.c://   is non-zero. ialloc() allocates, iput() frees if
+fs.c://   is free if ip->ref is zero. Otherwise ip->ref tracks
+fs.c://   the number of in-memory pointers to the entry (open
+fs.c://   is set in ip->flags. ilock() reads the inode from
+fs.c://   I_VALID if ip->ref has fallen to zero.
+fs.c://   ... examine and modify ip->xxx ...
+fs.c:// get a long-term reference to an inode (as for an open file)
+fs.c:// pathname lookup. iget() increments ip->ref so that the inode
+fs.c:// multi-step atomic operations.
+fs.c:    dip = (struct dinode*)bp->data + inum%IPB;
+fs.c:    if(dip->type == 0){  // a free inode
+fs.c:      dip->type = type;
+fs.c:// Copy a modified in-memory inode to disk.
+fs.c:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+fs.c:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+fs.c:  dip->type = ip->type;
+fs.c:  dip->major = ip->major;
+fs.c:  dip->minor = ip->minor;
+fs.c:  dip->nlink = ip->nlink;
+fs.c:  dip->size = ip->size;
+fs.c:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+fs.c:// and return the in-memory copy. Does not lock
+fs.c:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+fs.c:      ip->ref++;
+fs.c:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+fs.c:  ip->dev = dev;
+fs.c:  ip->inum = inum;
+fs.c:  ip->ref = 1;
+fs.c:  ip->flags = 0;
+fs.c:  ip->ref++;
+fs.c:  if(ip == 0 || ip->ref < 1)
+fs.c:  acquiresleep(&ip->lock);
+fs.c:  if(!(ip->flags & I_VALID)){
+fs.c:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+fs.c:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+fs.c:    ip->type = dip->type;
+fs.c:    ip->major = dip->major;
+fs.c:    ip->minor = dip->minor;
+fs.c:    ip->nlink = dip->nlink;
+fs.c:    ip->size = dip->size;
+fs.c:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+fs.c:    ip->flags |= I_VALID;
+fs.c:    if(ip->type == 0)
+fs.c:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+fs.c:  releasesleep(&ip->lock);
+fs.c:// Drop a reference to an in-memory inode.
+fs.c:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+fs.c:    ip->type = 0;
+fs.c:    ip->flags = 0;
+fs.c:  ip->ref--;
+fs.c:// are listed in ip->addrs[].  The next NINDIRECT blocks are
+fs.c:// listed in block ip->addrs[NDIRECT].
+fs.c:    if((addr = ip->addrs[bn]) == 0)
+fs.c:      ip->addrs[bn] = addr = balloc(ip->dev);
+fs.c:  bn -= NDIRECT;
+fs.c:    if((addr = ip->addrs[NDIRECT]) == 0)
+fs.c:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+fs.c:    bp = bread(ip->dev, addr);
+fs.c:    a = (uint*)bp->data;
+fs.c:      a[bn] = addr = balloc(ip->dev);
+fs.c:// and has no in-memory reference to it (is
+fs.c:    if(ip->addrs[i]){
+fs.c:      bfree(ip->dev, ip->addrs[i]);
+fs.c:      ip->addrs[i] = 0;
+fs.c:  if(ip->addrs[NDIRECT]){
+fs.c:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+fs.c:    a = (uint*)bp->data;
+fs.c:        bfree(ip->dev, a[j]);
+fs.c:    bfree(ip->dev, ip->addrs[NDIRECT]);
+fs.c:    ip->addrs[NDIRECT] = 0;
+fs.c:  ip->size = 0;
+fs.c:  st->dev = ip->dev;
+fs.c:  st->ino = ip->inum;
+fs.c:  st->type = ip->type;
+fs.c:  st->nlink = ip->nlink;
+fs.c:  st->size = ip->size;
+fs.c:  if(ip->type == T_DEV){
+fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+fs.c:      return -1;
+fs.c:    return devsw[ip->major].read(ip, dst, n);
+fs.c:  if(off > ip->size || off + n < off)
+fs.c:    return -1;
+fs.c:  if(off + n > ip->size)
+fs.c:    n = ip->size - off;
+fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+fs.c:    m = min(n - tot, BSIZE - off%BSIZE);
+fs.c:      cprintf("%x ", bp->data[off%BSIZE+j]);
+fs.c:    memmove(dst, bp->data + off%BSIZE, m);
+fs.c:  if(ip->type == T_DEV){
+fs.c:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+fs.c:      return -1;
+fs.c:    return devsw[ip->major].write(ip, src, n);
+fs.c:  if(off > ip->size || off + n < off)
+fs.c:    return -1;
+fs.c:    return -1;
+fs.c:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+fs.c:    m = min(n - tot, BSIZE - off%BSIZE);
+fs.c:    memmove(bp->data + off%BSIZE, src, m);
+fs.c:  if(n > 0 && off > ip->size){
+fs.c:    ip->size = off;
+fs.c:  if(dp->type != T_DIR)
+fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+fs.c:      return iget(dp->dev, inum);
+fs.c:    return -1;
+fs.c:  for(off = 0; off < dp->size; off += sizeof(de)){
+fs.c:  len = path - s;
+fs.c:    ip = idup(proc->cwd);
+fs.c:    if(ip->type != T_DIR){
+fs.d:fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
+fs.h:// On-disk file system format.
+fs.h:#define ROOTINO 1  // root i-number
+fs.h:// On-disk inode structure
+Binary file fs.img matches
+Binary file fs.o matches
+gdbutil:# -*- gdb-script -*-
+gdbutil:# Utility functions to pretty-print x86 segment/interrupt descriptors.
+gdbutil:# IA32 2007, Volume 3A, Table 3-2
+gdbutil:# IA32 2007, Volume 3A, Table 3-1
+gdbutil:# xv6-specific
+gdbutil:  # IA32 2007, Voume 3A, Figure 5-2
+gdbutil:  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
+gdbutil:        printf "16-bit (0)"
+gdbutil:        printf "32-bit (1)"
+Binary file _grep matches
+grep.asm:_grep:     file format elf32-i386
+grep.asm:     1cb:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
+grep.asm:     20c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+grep.asm:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+grep.asm:     218:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+grep.asm:     244:	01 45 e4             	add    %eax,-0x1c(%ebp)
+grep.asm:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+grep.asm:     24c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+grep.asm:        write(1, p, q+1 - p);
+grep.asm:     2b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+grep.asm:      m -= p - buf;
+grep.asm:     2ca:	01 45 e4             	add    %eax,-0x1c(%ebp)
+grep.asm:     2cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+grep.asm:        write(1, p, q+1 - p);
+grep.asm:     2f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+grep.asm:      m -= p - buf;
+grep.asm:     323:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+grep.asm:     32c:	88 5a ff             	mov    %bl,-0x1(%edx)
+grep.asm:  return (uchar)*p - (uchar)*q;
+grep.asm:  return (uchar)*p - (uchar)*q;
+grep.asm:     42b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+grep.asm:     44c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+grep.asm:     457:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+grep.asm:    return -1;
+grep.asm:    return -1;
+grep.asm:    return -1;
+grep.asm:     4da:	8d 42 d0             	lea    -0x30(%edx),%eax
+grep.asm:    n = n*10 + *s++ - '0';
+grep.asm:     4ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+grep.asm:     4f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+grep.asm:    n = n*10 + *s++ - '0';
+grep.asm:  while(n-- > 0)
+grep.asm:  while(n-- > 0)
+grep.asm:  while(n-- > 0)
+grep.asm:    x = -xx;
+grep.asm:     61d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+grep.asm:     624:	89 75 c0             	mov    %esi,-0x40(%ebp)
+grep.asm:    x = -xx;
+grep.asm:     62b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+grep.asm:     647:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+grep.asm:     64c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+grep.asm:    buf[i++] = '-';
+grep.asm:     656:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+grep.asm:  while(--i >= 0)
+grep.asm:     65b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+grep.asm:     660:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+grep.asm:     677:	88 45 d7             	mov    %al,-0x29(%ebp)
+grep.asm:    buf[i++] = '-';
+grep.asm:  while(--i >= 0)
+grep.asm:    x = -xx;
+grep.asm:     694:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+grep.asm:     6b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+grep.asm:     6d1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+grep.asm:     6e3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+grep.asm:     6ee:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+grep.asm:     738:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+grep.asm:     74f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+grep.asm:     752:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+grep.asm:     75b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+grep.asm:     75e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+grep.asm:     770:	88 55 e7             	mov    %dl,-0x19(%ebp)
+grep.asm:     778:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+grep.asm:     7a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+grep.asm:     7ba:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+grep.asm:     7c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+grep.asm:     7cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+grep.asm:     7e8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+grep.asm:     7eb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+grep.asm:     818:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+grep.asm:     82c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+grep.asm:     840:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+grep.asm:     85b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+grep.asm:     864:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+grep.asm:     876:	88 45 e4             	mov    %al,-0x1c(%ebp)
+grep.asm:     879:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+grep.asm:     885:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:     8a0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  if(bp + bp->s.size == p->s.ptr){
+grep.asm:     8c0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:     8ca:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:    p->s.ptr = bp;
+grep.asm:  bp = (Header*)ap - 1;
+grep.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+grep.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+grep.asm:  if(bp + bp->s.size == p->s.ptr){
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:     8eb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:     8f2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:     8ff:	03 4b fc             	add    -0x4(%ebx),%ecx
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:    p->s.ptr = bp;
+grep.asm:    bp->s.size += p->s.ptr->s.size;
+grep.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+grep.asm:    bp->s.ptr = p->s.ptr;
+grep.asm:  if(p + p->s.size == bp){
+grep.asm:    p->s.size += bp->s.size;
+grep.asm:    p->s.ptr = bp->s.ptr;
+grep.asm:     90a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+grep.asm:    p->s.ptr = bp;
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:     958:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:        p->s.size = nunits;
+grep.asm:     973:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+grep.asm:  if(p == (char*)-1)
+grep.asm:  hp->s.size = nu;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:      if(p->s.size == nunits)
+grep.asm:        prevp->s.ptr = p->s.ptr;
+grep.asm:        p->s.size -= nunits;
+grep.asm:        p += p->s.size;
+grep.asm:        p->s.size = nunits;
+grep.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+grep.asm:    if(p->s.size >= nunits){
+grep.asm:      if(p->s.size == nunits)
+grep.asm:        prevp->s.ptr = p->s.ptr;
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+grep.asm:    return newThread->tid;
+grep.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+grep.asm:    return newThread->tid;
+grep.asm:    thread->state=RUNNABLE;
+grep.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+grep.asm:    thread->state=RUNNABLE;
+grep.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+grep.asm:	ttable.threads[i]->state=RUNNABLE;
+grep.asm:    thread->state=RUNNABLE;
+grep.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+grep.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+grep.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+grep.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+grep.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+grep.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+grep.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+grep.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+grep.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+grep.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+grep.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+grep.asm:  //1. store tf in the thread->btf
+grep.asm:  *thread->btf = tf;
+grep.asm:  if(nextThread->isFirstRun==1){
+grep.asm:    //move the tf that is stored in nextThread->btf to the stack
+grep.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+grep.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+grep.asm:  nextThread->state=RUNNING;
+grep.asm:  nextThread->isFirstRun=0;
+grep.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+grep.asm:  nextThread->state=RUNNING;
+grep.asm:  nextThread->isFirstRun=0;
+grep.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+grep.asm:    thread->state=RUNNABLE;
+grep.asm:  *thread->btf = tf;
+grep.asm:  if(nextThread->isFirstRun==1){
+grep.asm:     bc3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+grep.asm:     bcb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+grep.asm:    ntf->esp=nextThread->btf->esp;
+grep.asm:    ntf->eip=nextThread->btf->eip;
+grep.asm:      //ttable.threads[i]->utstack=0;
+grep.asm:      //ttable.threads[i]->tid=0;
+grep.asm:      //ttable.threads[i]->esp=0;
+grep.asm:      //ttable.threads[i]->ebp=0;
+grep.asm:      //ttable.threads[i]->eip=0;
+grep.asm:      ttable.threads[i]->state=EMPTY;
+grep.asm:      //ttable.threads[i]->sleepTime=0
+grep.asm:      //ttable.threads[i]->sleepInit=0;
+grep.asm:      ttable.threads[i]->isFirstRun=1;
+grep.asm:      //ttable.threads[i]->btf=0;
+grep.asm:      //ttable.threads[i]->waitingExitTid=0;
+grep.asm:    thread->tid = threadTidCounter;
+grep.asm:    thread->state = RUNNING;
+grep.asm:      //ttable.threads[i]->btf=0;
+grep.asm:      //ttable.threads[i]->waitingExitTid=0;
+grep.asm:    thread->tid = threadTidCounter;
+grep.asm:    thread->state = RUNNING;
+grep.asm:    thread->tid = threadTidCounter;
+grep.asm:    thread->state = RUNNING;
+grep.asm:        return -1;*/
+grep.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+grep.asm:      //ttable.threads[i]->btf=0;
+grep.asm:      //ttable.threads[i]->waitingExitTid=0;
+grep.asm:    thread->tid = threadTidCounter;
+grep.asm:    thread->state = RUNNING;
+grep.asm:        return -1;*/
+grep.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+grep.asm:      return -1;
+grep.asm:        return -1;*/
+grep.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+grep.asm:      return -1;
+grep.asm:    if (threadNum == MAX_UTHREADS - 1) 
+grep.asm:        return -1;
+grep.asm:      if(ttable.threads[i]->state==EMPTY){
+grep.asm:    newThread->tid = threadTidCounter;
+grep.asm:    newThread->tid = threadTidCounter;
+grep.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+grep.asm:    newThread->tid = threadTidCounter;
+grep.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+grep.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+grep.asm:    esp -= 4;
+grep.asm:    newThread->tid = threadTidCounter;
+grep.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+grep.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+grep.asm:    esp -= 4;
+grep.asm:    esp -= 4;
+grep.asm:    newThread->btf->esp=esp-3*sizeof(int);
+grep.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+grep.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+grep.asm:    esp -= 4;
+grep.asm:    esp -= 4;
+grep.asm:    newThread->btf->esp=esp-3*sizeof(int);
+grep.asm:    newThread->btf->eip=(int)start_func;
+grep.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+grep.asm:    newThread->eip=(int)start_func;//
+grep.asm:    newThread->state = RUNNABLE;
+grep.asm:    return newThread->tid;
+grep.asm:    if (threadNum == MAX_UTHREADS - 1) 
+grep.asm:        return -1;
+grep.asm:    return thread->tid;
+grep.asm:    return thread->tid;
+grep.asm:    return thread->tid;
+grep.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+grep.asm:    return thread->tid;
+grep.asm:      if(ttable.threads[i]->tid==tid){
+grep.asm:      return -1; 
+grep.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+grep.asm:      return -1; 
+grep.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+grep.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+grep.asm:    thread->waitingExitTid=tid;
+grep.asm:    thread->state=BLOCKED;
+grep.asm:      return -1; 
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:	return -1;
+grep.asm:    thread->state=BLOCKED;
+grep.asm:    thread->sleepInit=uptime();
+grep.asm:    thread->sleepTime=ticks;
+grep.asm:	return -1;
+grep.asm:    thread->state=BLOCKED;
+grep.asm:    thread->sleepInit=uptime();
+grep.asm:    thread->sleepTime=ticks;
+grep.asm:	return -1;
+grep.asm:    free(th->utstack);
+grep.asm:    th->tid=0;
+grep.asm:    th->esp=0;
+grep.asm:    th->ebp=0;
+grep.asm:    th->eip=0;
+grep.asm:    th->state=EMPTY;
+grep.asm:    th->sleepTime=0;
+grep.asm:    th->sleepInit=0;
+grep.asm:    th->isFirstRun=1;
+grep.asm:    th->btf=0;
+grep.asm:    th->waitingExitTid=0;
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:    th->isFirstRun=1;
+grep.asm:    th->btf=0;
+grep.asm:    th->waitingExitTid=0;
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+grep.asm:      if(ttable.threads[i]->state==RUNNABLE){
+grep.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+grep.asm:	ttable.threads[i]->state=RUNNABLE;
+grep.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+grep.asm:	ttable.threads[i]->state=RUNNABLE;
+grep.asm:    threadsCounter--;
+grep.asm:    threadsCounter--;
+grep.c:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+grep.c:        write(1, p, q+1 - p);
+grep.c:      m -= p - buf;
+grep.d:grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file grep.o matches
+ide.c:// Simple PIO-based (non-DMA) IDE driver code.
+ide.c:// idequeue->qnext points to the next buf to be processed.
+ide.c:    return -1;
+ide.c:  ioapicenable(IRQ_IDE, ncpu - 1);
+ide.c:  if(b->blockno >= FSSIZE)
+ide.c:  int sector = b->blockno * sector_per_block;
+ide.c:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+ide.c:  if(b->flags & B_DIRTY){
+ide.c:    outsl(0x1f0, b->data, BSIZE/4);
+ide.c:  idequeue = b->qnext;
+ide.c:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+ide.c:    insl(0x1f0, b->data, BSIZE/4);
+ide.c:  b->flags |= B_VALID;
+ide.c:  b->flags &= ~B_DIRTY;
+ide.c:  if(!holdingsleep(&b->lock))
+ide.c:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+ide.c:  if(b->dev != 0 && !havedisk1)
+ide.c:  acquire(&idelock);  //DOC:acquire-lock
+ide.c:  b->qnext = 0;
+ide.c:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+ide.c:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+ide.d:ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file ide.o matches
+Binary file _init matches
+init.asm:_init:     file format elf32-i386
+init.asm: 123:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+init.asm: 12c:	88 5a ff             	mov    %bl,-0x1(%edx)
+init.asm:  return (uchar)*p - (uchar)*q;
+init.asm:  return (uchar)*p - (uchar)*q;
+init.asm: 22b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+init.asm: 24c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+init.asm: 257:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+init.asm:    return -1;
+init.asm:    return -1;
+init.asm:    return -1;
+init.asm: 2da:	8d 42 d0             	lea    -0x30(%edx),%eax
+init.asm:    n = n*10 + *s++ - '0';
+init.asm: 2ee:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+init.asm: 2f5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+init.asm:    n = n*10 + *s++ - '0';
+init.asm:  while(n-- > 0)
+init.asm:  while(n-- > 0)
+init.asm:  while(n-- > 0)
+init.asm:    x = -xx;
+init.asm: 41d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+init.asm: 424:	89 75 c0             	mov    %esi,-0x40(%ebp)
+init.asm:    x = -xx;
+init.asm: 42b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+init.asm: 447:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+init.asm: 44c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+init.asm:    buf[i++] = '-';
+init.asm: 456:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+init.asm:  while(--i >= 0)
+init.asm: 45b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+init.asm: 460:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+init.asm: 477:	88 45 d7             	mov    %al,-0x29(%ebp)
+init.asm:    buf[i++] = '-';
+init.asm:  while(--i >= 0)
+init.asm:    x = -xx;
+init.asm: 494:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+init.asm: 4b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+init.asm: 4d1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+init.asm: 4e3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+init.asm: 4ee:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+init.asm: 538:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+init.asm: 54f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+init.asm: 552:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+init.asm: 55b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+init.asm: 55e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+init.asm: 570:	88 55 e7             	mov    %dl,-0x19(%ebp)
+init.asm: 578:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+init.asm: 5a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+init.asm: 5ba:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+init.asm: 5c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+init.asm: 5cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+init.asm: 5e8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+init.asm: 5eb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+init.asm: 618:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+init.asm: 62c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+init.asm: 640:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+init.asm: 65b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+init.asm: 664:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+init.asm: 676:	88 45 e4             	mov    %al,-0x1c(%ebp)
+init.asm: 679:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+init.asm: 685:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+init.asm:  bp = (Header*)ap - 1;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:  bp = (Header*)ap - 1;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  bp = (Header*)ap - 1;
+init.asm: 6a0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  bp = (Header*)ap - 1;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  bp = (Header*)ap - 1;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  if(bp + bp->s.size == p->s.ptr){
+init.asm: 6c0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm: 6ca:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm:    p->s.ptr = bp;
+init.asm:  bp = (Header*)ap - 1;
+init.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+init.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+init.asm:  if(bp + bp->s.size == p->s.ptr){
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm: 6eb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm: 6f2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm: 6ff:	03 4b fc             	add    -0x4(%ebx),%ecx
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm:    p->s.ptr = bp;
+init.asm:    bp->s.size += p->s.ptr->s.size;
+init.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+init.asm:    bp->s.ptr = p->s.ptr;
+init.asm:  if(p + p->s.size == bp){
+init.asm:    p->s.size += bp->s.size;
+init.asm:    p->s.ptr = bp->s.ptr;
+init.asm: 70a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+init.asm:    p->s.ptr = bp;
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm: 758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:        p->s.size = nunits;
+init.asm: 773:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+init.asm:  if(p == (char*)-1)
+init.asm:  hp->s.size = nu;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:      if(p->s.size == nunits)
+init.asm:        prevp->s.ptr = p->s.ptr;
+init.asm:        p->s.size -= nunits;
+init.asm:        p += p->s.size;
+init.asm:        p->s.size = nunits;
+init.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+init.asm:    if(p->s.size >= nunits){
+init.asm:      if(p->s.size == nunits)
+init.asm:        prevp->s.ptr = p->s.ptr;
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+init.asm:    return newThread->tid;
+init.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+init.asm:    return newThread->tid;
+init.asm:    thread->state=RUNNABLE;
+init.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+init.asm:    thread->state=RUNNABLE;
+init.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+init.asm:	ttable.threads[i]->state=RUNNABLE;
+init.asm:    thread->state=RUNNABLE;
+init.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+init.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+init.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+init.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+init.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+init.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+init.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+init.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+init.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+init.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+init.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+init.asm:  //1. store tf in the thread->btf
+init.asm:  *thread->btf = tf;
+init.asm:  if(nextThread->isFirstRun==1){
+init.asm:    //move the tf that is stored in nextThread->btf to the stack
+init.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+init.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+init.asm:  nextThread->state=RUNNING;
+init.asm:  nextThread->isFirstRun=0;
+init.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+init.asm:  nextThread->state=RUNNING;
+init.asm:  nextThread->isFirstRun=0;
+init.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+init.asm:    thread->state=RUNNABLE;
+init.asm:  *thread->btf = tf;
+init.asm:  if(nextThread->isFirstRun==1){
+init.asm: 9c3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+init.asm: 9cb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+init.asm:    ntf->esp=nextThread->btf->esp;
+init.asm:    ntf->eip=nextThread->btf->eip;
+init.asm:      //ttable.threads[i]->utstack=0;
+init.asm:      //ttable.threads[i]->tid=0;
+init.asm:      //ttable.threads[i]->esp=0;
+init.asm:      //ttable.threads[i]->ebp=0;
+init.asm:      //ttable.threads[i]->eip=0;
+init.asm:      ttable.threads[i]->state=EMPTY;
+init.asm:      //ttable.threads[i]->sleepTime=0
+init.asm:      //ttable.threads[i]->sleepInit=0;
+init.asm:      ttable.threads[i]->isFirstRun=1;
+init.asm:      //ttable.threads[i]->btf=0;
+init.asm:      //ttable.threads[i]->waitingExitTid=0;
+init.asm:    thread->tid = threadTidCounter;
+init.asm:    thread->state = RUNNING;
+init.asm:      //ttable.threads[i]->btf=0;
+init.asm:      //ttable.threads[i]->waitingExitTid=0;
+init.asm:    thread->tid = threadTidCounter;
+init.asm:    thread->state = RUNNING;
+init.asm:    thread->tid = threadTidCounter;
+init.asm:    thread->state = RUNNING;
+init.asm:        return -1;*/
+init.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+init.asm:      //ttable.threads[i]->btf=0;
+init.asm:      //ttable.threads[i]->waitingExitTid=0;
+init.asm:    thread->tid = threadTidCounter;
+init.asm:    thread->state = RUNNING;
+init.asm:        return -1;*/
+init.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+init.asm:      return -1;
+init.asm:        return -1;*/
+init.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+init.asm:      return -1;
+init.asm:    if (threadNum == MAX_UTHREADS - 1) 
+init.asm:        return -1;
+init.asm:      if(ttable.threads[i]->state==EMPTY){
+init.asm:    newThread->tid = threadTidCounter;
+init.asm:    newThread->tid = threadTidCounter;
+init.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+init.asm:    newThread->tid = threadTidCounter;
+init.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+init.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+init.asm:    esp -= 4;
+init.asm:    newThread->tid = threadTidCounter;
+init.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+init.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+init.asm:    esp -= 4;
+init.asm:    esp -= 4;
+init.asm:    newThread->btf->esp=esp-3*sizeof(int);
+init.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+init.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+init.asm:    esp -= 4;
+init.asm:    esp -= 4;
+init.asm:    newThread->btf->esp=esp-3*sizeof(int);
+init.asm:    newThread->btf->eip=(int)start_func;
+init.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+init.asm:    newThread->eip=(int)start_func;//
+init.asm:    newThread->state = RUNNABLE;
+init.asm:    return newThread->tid;
+init.asm:    if (threadNum == MAX_UTHREADS - 1) 
+init.asm:        return -1;
+init.asm:    return thread->tid;
+init.asm:    return thread->tid;
+init.asm:    return thread->tid;
+init.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+init.asm:    return thread->tid;
+init.asm:      if(ttable.threads[i]->tid==tid){
+init.asm:      return -1; 
+init.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+init.asm:      return -1; 
+init.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+init.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+init.asm:    thread->waitingExitTid=tid;
+init.asm:    thread->state=BLOCKED;
+init.asm:      return -1; 
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:	return -1;
+init.asm:    thread->state=BLOCKED;
+init.asm:    thread->sleepInit=uptime();
+init.asm:    thread->sleepTime=ticks;
+init.asm:	return -1;
+init.asm:    thread->state=BLOCKED;
+init.asm:    thread->sleepInit=uptime();
+init.asm:    thread->sleepTime=ticks;
+init.asm:	return -1;
+init.asm:    free(th->utstack);
+init.asm:    th->tid=0;
+init.asm:    th->esp=0;
+init.asm:    th->ebp=0;
+init.asm:    th->eip=0;
+init.asm:    th->state=EMPTY;
+init.asm:    th->sleepTime=0;
+init.asm:    th->sleepInit=0;
+init.asm:    th->isFirstRun=1;
+init.asm:    th->btf=0;
+init.asm:    th->waitingExitTid=0;
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:    th->isFirstRun=1;
+init.asm:    th->btf=0;
+init.asm:    th->waitingExitTid=0;
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+init.asm:      if(ttable.threads[i]->state==RUNNABLE){
+init.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+init.asm:	ttable.threads[i]->state=RUNNABLE;
+init.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+init.asm:	ttable.threads[i]->state=RUNNABLE;
+init.asm:    threadsCounter--;
+init.asm:    threadsCounter--;
+init.c:// init: The initial user-level program
+initcode.asm:initcode.o:     file format elf32-i386
+init.d:init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
+Binary file init.o matches
+ioapic.c:#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
+ioapic.c:  ioapic->reg = reg;
+ioapic.c:  return ioapic->data;
+ioapic.c:  ioapic->reg = reg;
+ioapic.c:  ioapic->data = data;
+ioapic.c:  // Mark all interrupts edge-triggered, active high, disabled,
+ioapic.c:  // Mark interrupt edge-triggered, active high,
+ioapic.d:ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
+Binary file ioapic.o matches
+kalloc.c:// and pipe buffers. Allocates 4096-byte pages.
+kalloc.c:  r->next = kmem.freelist;
+kalloc.c:// Allocate one 4096-byte page of physical memory.
+kalloc.c:    kmem.freelist = r->next;
+kalloc.d:kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file kalloc.o matches
+kbd.c:    return -1;
+kbd.c:      c += 'A' - 'a';
+kbd.c:      c += 'a' - 'A';
+kbd.d:kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
+kbd.h:// C('A') == Control-A
+kbd.h:#define C(x) (x - '@')
+kbd.h:  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+kbd.h:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+kbd.h:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+Binary file kbd.o matches
+Binary file kernel matches
+kernel.asm:kernel:     file format elf32-i386
+kernel.asm:  # the assembler produces a PC-relative instruction
+kernel.asm:    b->next = bcache.head.next;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:    initsleeplock(&b->lock, "buffer");
+kernel.asm:    bcache.head.next->prev = b;
+kernel.asm:    b->next = bcache.head.next;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:    initsleeplock(&b->lock, "buffer");
+kernel.asm:    bcache.head.next->prev = b;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:    initsleeplock(&b->lock, "buffer");
+kernel.asm:    bcache.head.next->prev = b;
+kernel.asm:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+kernel.asm:    if(b->dev == dev && b->blockno == blockno){
+kernel.asm:      b->refcnt++;
+kernel.asm:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+kernel.asm:    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+kernel.asm:      b->dev = dev;
+kernel.asm:      b->blockno = blockno;
+kernel.asm:      b->flags = 0;
+kernel.asm:      b->refcnt = 1;
+kernel.asm:      acquiresleep(&b->lock);
+kernel.asm:  if(!(b->flags & B_VALID)) {
+kernel.asm:      acquiresleep(&b->lock);
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  b->flags |= B_DIRTY;
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  b->flags |= B_DIRTY;
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  releasesleep(&b->lock);
+kernel.asm:  b->refcnt--;
+kernel.asm:  if (b->refcnt == 0) {
+kernel.asm:    b->next->prev = b->prev;
+kernel.asm:    b->prev->next = b->next;
+kernel.asm:    b->next = bcache.head.next;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:  b->refcnt--;
+kernel.asm:  if (b->refcnt == 0) {
+kernel.asm:    b->next->prev = b->prev;
+kernel.asm:    b->prev->next = b->next;
+kernel.asm:    b->next = bcache.head.next;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:    bcache.head.next->prev = b;
+kernel.asm:    b->prev = &bcache.head;
+kernel.asm:    bcache.head.next->prev = b;
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:      if(proc->killed){
+kernel.asm:        return -1;
+kernel.asm:        return -1;
+kernel.asm:801002e4:	0f b6 8a 40 ff 10 80 	movzbl -0x7fef00c0(%edx),%ecx
+kernel.asm:        // caller gets a 0-byte result.
+kernel.asm:        input.r--;
+kernel.asm:    --n;
+kernel.asm:        // caller gets a 0-byte result.
+kernel.asm:        input.r--;
+kernel.asm:801002fc:	88 4e ff             	mov    %cl,-0x1(%esi)
+kernel.asm:    --n;
+kernel.asm:    --n;
+kernel.asm:8010030f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:8010031f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:  return target - n;
+kernel.asm:      if(proc->killed){
+kernel.asm:        return -1;
+kernel.asm:  return target - n;
+kernel.asm:        // caller gets a 0-byte result.
+kernel.asm:        input.r--;
+kernel.asm:  cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+kernel.asm:8010036f:	8d 5d d0             	lea    -0x30(%ebp),%ebx
+kernel.asm:8010037c:	8d 75 f8             	lea    -0x8(%ebp),%esi
+kernel.asm:  cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+kernel.asm:  cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+kernel.asm:    pos += 80 - pos%80;
+kernel.asm:    if(pos > 0) --pos;
+kernel.asm:80100457:	66 89 9c 09 00 80 0b 	mov    %bx,-0x7ff48000(%ecx,%ecx,1)
+kernel.asm:8010047c:	8d 8c 3f 00 80 0b 80 	lea    -0x7ff48000(%edi,%edi,1),%ecx
+kernel.asm:    pos -= 80;
+kernel.asm:801004e3:	8d 5f b0             	lea    -0x50(%edi),%ebx
+kernel.asm:    pos -= 80;
+kernel.asm:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+kernel.asm:801004ee:	8d b4 1b 00 80 0b 80 	lea    -0x7ff48000(%ebx,%ebx,1),%esi
+kernel.asm:    pos -= 80;
+kernel.asm:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+kernel.asm:    if(pos > 0) --pos;
+kernel.asm:    pos += 80 - pos%80;
+kernel.asm:    if(pos > 0) --pos;
+kernel.asm:80100538:	8d 79 ff             	lea    -0x1(%ecx),%edi
+kernel.asm:    pos += 80 - pos%80;
+kernel.asm:    x = -xx;
+kernel.asm:80100599:	0f b6 92 18 72 10 80 	movzbl -0x7fef8de8(%edx),%edx
+kernel.asm:801005a2:	88 54 1d d7          	mov    %dl,-0x29(%ebp,%ebx,1)
+kernel.asm:    buf[i++] = '-';
+kernel.asm:801005b1:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+kernel.asm:  while(--i >= 0)
+kernel.asm:801005c0:	0f be 44 1d d8       	movsbl -0x28(%ebp,%ebx,1),%eax
+kernel.asm:    buf[i++] = '-';
+kernel.asm:  while(--i >= 0)
+kernel.asm:    buf[i++] = '-';
+kernel.asm:  while(--i >= 0)
+kernel.asm:    x = -xx;
+kernel.asm:  return target - n;
+kernel.asm:  return target - n;
+kernel.asm:80100660:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:801006b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:801006c2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+kernel.asm:801006e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:8010070f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:8010071e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+kernel.asm:8010072d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:80100735:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:8010075d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:80100787:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+kernel.asm:#define C(x)  ((x)-'@')  // Control-x
+kernel.asm:#define C(x)  ((x)-'@')  // Control-x
+kernel.asm:        input.e--;
+kernel.asm:        input.e--;
+kernel.asm:        input.e--;
+kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
+kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
+kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
+kernel.asm:80100876:	88 88 40 ff 10 80    	mov    %cl,-0x7fef00c0(%eax)
+kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
+kernel.asm:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+kernel.asm:        input.e--;
+kernel.asm:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+kernel.asm:80100900:	80 ba 40 ff 10 80 0a 	cmpb   $0xa,-0x7fef00c0(%edx)
+kernel.asm:      if(c != 0 && input.e-input.r < INPUT_BUF){
+kernel.asm:8010092c:	c6 80 40 ff 10 80 0a 	movb   $0xa,-0x7fef00c0(%eax)
+kernel.asm:    return -1;
+kernel.asm:801009da:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
+kernel.asm:  return -1;
+kernel.asm:80100a20:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
+kernel.asm:80100a33:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
+kernel.asm:80100a3b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
+kernel.asm:80100a43:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
+kernel.asm:80100a49:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+kernel.asm:80100a60:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
+kernel.asm:80100a75:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
+kernel.asm:80100a9c:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
+kernel.asm:80100aa5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
+kernel.asm:80100aab:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
+kernel.asm:80100ab3:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
+kernel.asm:80100abf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+kernel.asm:80100ac9:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:80100ad9:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
+kernel.asm:80100ae1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
+kernel.asm:80100aee:	8b 95 14 ff ff ff    	mov    -0xec(%ebp),%edx
+kernel.asm:80100af8:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:80100b06:	8b 95 08 ff ff ff    	mov    -0xf8(%ebp),%edx
+kernel.asm:80100b20:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:80100b45:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+kernel.asm:80100b5f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:80100b73:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
+kernel.asm:80100b7b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:  return -1;
+kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+kernel.asm:80100b93:	8b 9d ec fe ff ff    	mov    -0x114(%ebp),%ebx
+kernel.asm:80100ba4:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+kernel.asm:80100be3:	89 8d f0 fe ff ff    	mov    %ecx,-0x110(%ebp)
+kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+kernel.asm:80100c10:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+kernel.asm:80100c26:	8b 8d f0 fe ff ff    	mov    -0x110(%ebp),%ecx
+kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+kernel.asm:80100c2c:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
+kernel.asm:80100c32:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
+kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+kernel.asm:  ustack[2] = sp - (argc+1)*4;  // argv pointer
+kernel.asm:  sp -= (3+argc+1) * 4;
+kernel.asm:80100c5a:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+kernel.asm:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+kernel.asm:80100c68:	c7 84 b5 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%esi,4)
+kernel.asm:  ustack[2] = sp - (argc+1)*4;  // argv pointer
+kernel.asm:  sp -= (3+argc+1) * 4;
+kernel.asm:80100c76:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
+kernel.asm:80100c80:	89 b5 5c ff ff ff    	mov    %esi,-0xa4(%ebp)
+kernel.asm:  ustack[2] = sp - (argc+1)*4;  // argv pointer
+kernel.asm:80100c86:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%ebp)
+kernel.asm:  sp -= (3+argc+1) * 4;
+kernel.asm:  sp -= (3+argc+1) * 4;
+kernel.asm:  sp -= (3+argc+1) * 4;
+kernel.asm:  safestrcpy(proc->name, last, sizeof(proc->name));
+kernel.asm:  oldpgdir = proc->pgdir;
+kernel.asm:  proc->pgdir = pgdir;
+kernel.asm:80100ce2:	8b 8d f4 fe ff ff    	mov    -0x10c(%ebp),%ecx
+kernel.asm:  safestrcpy(proc->name, last, sizeof(proc->name));
+kernel.asm:  oldpgdir = proc->pgdir;
+kernel.asm:  proc->pgdir = pgdir;
+kernel.asm:  proc->sz = sz;
+kernel.asm:80100cee:	8b 8d ec fe ff ff    	mov    -0x114(%ebp),%ecx
+kernel.asm:  proc->tf->eip = elf.entry;  // main
+kernel.asm:80100cfc:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
+kernel.asm:  proc->tf->esp = sp;
+kernel.asm:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+kernel.asm:80100d25:	8b 9d ec fe ff ff    	mov    -0x114(%ebp),%ebx
+kernel.asm:80100d2d:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
+kernel.asm:    if(f->ref == 0){
+kernel.asm:      f->ref = 1;
+kernel.asm:    if(f->ref == 0){
+kernel.asm:      f->ref = 1;
+kernel.asm:    if(f->ref == 0){
+kernel.asm:      f->ref = 1;
+kernel.asm:      f->ref = 1;
+kernel.asm:  if(f->ref < 1)
+kernel.asm:  f->ref++;
+kernel.asm:  if(f->ref < 1)
+kernel.asm:  if(f->ref < 1)
+kernel.asm:  if(--f->ref > 0){
+kernel.asm:  if(f->ref < 1)
+kernel.asm:  if(--f->ref > 0){
+kernel.asm:  f->ref = 0;
+kernel.asm:  f->type = FD_NONE;
+kernel.asm:  if(--f->ref > 0){
+kernel.asm:80100e6f:	88 45 e7             	mov    %al,-0x19(%ebp)
+kernel.asm:  f->ref = 0;
+kernel.asm:  f->type = FD_NONE;
+kernel.asm:  if(--f->ref > 0){
+kernel.asm:80100e7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:  f->ref = 0;
+kernel.asm:  f->type = FD_NONE;
+kernel.asm:  f->ref = 0;
+kernel.asm:  f->type = FD_NONE;
+kernel.asm:80100e98:	0f be 75 e7          	movsbl -0x19(%ebp),%esi
+kernel.asm:80100eb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:  if(f->ref < 1)
+kernel.asm:  if(f->type == FD_INODE){
+kernel.asm:    ilock(f->ip);
+kernel.asm:    stati(f->ip, st);
+kernel.asm:    iunlock(f->ip);
+kernel.asm:  return -1;
+kernel.asm:  if(f->type == FD_INODE){
+kernel.asm:    ilock(f->ip);
+kernel.asm:    stati(f->ip, st);
+kernel.asm:    iunlock(f->ip);
+kernel.asm:  return -1;
+kernel.asm:    ilock(f->ip);
+kernel.asm:    stati(f->ip, st);
+kernel.asm:    iunlock(f->ip);
+kernel.asm:  return -1;
+kernel.asm:  if(f->readable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return piperead(f->pipe, addr, n);
+kernel.asm:  if(f->type == FD_INODE){
+kernel.asm:    ilock(f->ip);
+kernel.asm:    if((r = readi(f->ip, addr, f->off, n)) > 0)
+kernel.asm:      f->off += r;
+kernel.asm:    iunlock(f->ip);
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return piperead(f->pipe, addr, n);
+kernel.asm:  if(f->type == FD_INODE){
+kernel.asm:    ilock(f->ip);
+kernel.asm:    if((r = readi(f->ip, addr, f->off, n)) > 0)
+kernel.asm:      f->off += r;
+kernel.asm:    iunlock(f->ip);
+kernel.asm:  if(f->readable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return piperead(f->pipe, addr, n);
+kernel.asm:      f->off += r;
+kernel.asm:    iunlock(f->ip);
+kernel.asm:  if(f->readable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return piperead(f->pipe, addr, n);
+kernel.asm:  if(f->readable == 0)
+kernel.asm:    return -1;
+kernel.asm:    if((r = readi(f->ip, addr, f->off, n)) > 0)
+kernel.asm:      f->off += r;
+kernel.asm:    iunlock(f->ip);
+kernel.asm:80100fdf:	89 45 dc             	mov    %eax,-0x24(%ebp)
+kernel.asm:  if(f->writable == 0)
+kernel.asm:80100fe9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:  if(f->writable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return pipewrite(f->pipe, addr, n);
+kernel.asm:  if(f->type == FD_INODE){
+kernel.asm:    // and 2 blocks of slop for non-aligned writes.
+kernel.asm:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+kernel.asm:80101006:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:      ilock(f->ip);
+kernel.asm:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+kernel.asm:        f->off += r;
+kernel.asm:      iunlock(f->ip);
+kernel.asm:      ilock(f->ip);
+kernel.asm:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+kernel.asm:        f->off += r;
+kernel.asm:8010101e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:      iunlock(f->ip);
+kernel.asm:8010102e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:    // and 2 blocks of slop for non-aligned writes.
+kernel.asm:    int max = ((LOGSIZE-1-1-2) / 2) * 512;
+kernel.asm:8010103b:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
+kernel.asm:      int n1 = n - i;
+kernel.asm:80101040:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+kernel.asm:      ilock(f->ip);
+kernel.asm:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+kernel.asm:8010106e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+kernel.asm:        f->off += r;
+kernel.asm:      iunlock(f->ip);
+kernel.asm:80101089:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:80101099:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:    return i == n ? n : -1;
+kernel.asm:  if(f->writable == 0)
+kernel.asm:    return -1;
+kernel.asm:    return i == n ? n : -1;
+kernel.asm:    return i == n ? n : -1;
+kernel.asm:801010b0:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+kernel.asm:  if(f->writable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return pipewrite(f->pipe, addr, n);
+kernel.asm:    return i == n ? n : -1;
+kernel.asm:  if(f->writable == 0)
+kernel.asm:    return -1;
+kernel.asm:  if(f->type == FD_PIPE)
+kernel.asm:    return pipewrite(f->pipe, addr, n);
+kernel.asm:    return i == n ? n : -1;
+kernel.asm:801010f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
+kernel.asm:80101109:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+kernel.asm:80101110:	8b 75 dc             	mov    -0x24(%ebp),%esi
+kernel.asm:80101122:	8b 45 d8             	mov    -0x28(%ebp),%eax
+kernel.asm:8010112d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:80101135:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:80101140:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:8010116f:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+kernel.asm:80101174:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:8010117f:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
+kernel.asm:80101186:	8b 45 dc             	mov    -0x24(%ebp),%eax
+kernel.asm:      if((bp->data[bi/8] & m) == 0){  // Is block free?
+kernel.asm:        bp->data[bi/8] |= m;  // Mark block in use.
+kernel.asm:801011aa:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+kernel.asm:801011c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+kernel.asm:  memset(bp->data, 0, BSIZE);
+kernel.asm:  memset(bp->data, 0, BSIZE);
+kernel.asm:// and return the in-memory copy. Does not lock
+kernel.asm:// and return the in-memory copy. Does not lock
+kernel.asm:// and return the in-memory copy. Does not lock
+kernel.asm:// and return the in-memory copy. Does not lock
+kernel.asm:80101229:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:80101231:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+kernel.asm:      ip->ref++;
+kernel.asm:  ip->ref = 1;
+kernel.asm:  ip->flags = 0;
+kernel.asm:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+kernel.asm:  ip->dev = dev;
+kernel.asm:  ip->inum = inum;
+kernel.asm:  ip->ref = 1;
+kernel.asm:  ip->flags = 0;
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+kernel.asm:  bn -= NDIRECT;
+kernel.asm:801012f8:	8d 72 f4             	lea    -0xc(%edx),%esi
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:    bp = bread(ip->dev, addr);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:    bp = bread(ip->dev, addr);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      a[bn] = addr = balloc(ip->dev);
+kernel.asm:80101326:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:8010132e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      a[bn] = addr = balloc(ip->dev);
+kernel.asm:    if((addr = ip->addrs[bn]) == 0)
+kernel.asm:      ip->addrs[bn] = addr = balloc(ip->dev);
+kernel.asm:  bn -= NDIRECT;
+kernel.asm:    if((addr = ip->addrs[NDIRECT]) == 0)
+kernel.asm:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+kernel.asm:  memmove(sb, bp->data, sizeof(*sb));
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:  bp->data[bi/8] &= ~m;
+kernel.asm:  if((bp->data[bi/8] & m) == 0)
+kernel.asm:80101536:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:      dip->type = type;
+kernel.asm:      dip->type = type;
+kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:801015a3:	89 55 dc             	mov    %edx,-0x24(%ebp)
+kernel.asm:801015a6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+kernel.asm:      dip->type = type;
+kernel.asm:801015ae:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+kernel.asm:801015b2:	8b 55 dc             	mov    -0x24(%ebp),%edx
+kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:801015b5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+kernel.asm:801015b8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:    dip = (struct dinode*)bp->data + inum%IPB;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:801015c6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:    if(dip->type == 0){  // a free inode
+kernel.asm:      dip->type = type;
+kernel.asm:// Copy a modified in-memory inode to disk.
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip->type = ip->type;
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:8010160e:	8b 43 a4             	mov    -0x5c(%ebx),%eax
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:80101619:	8b 53 a8             	mov    -0x58(%ebx),%edx
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  dip->type = ip->type;
+kernel.asm:80101628:	0f b7 43 f4          	movzwl -0xc(%ebx),%eax
+kernel.asm:  dip->major = ip->major;
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:  dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  dip->type = ip->type;
+kernel.asm:8010162f:	66 89 42 f4          	mov    %ax,-0xc(%edx)
+kernel.asm:  dip->major = ip->major;
+kernel.asm:80101633:	0f b7 43 f6          	movzwl -0xa(%ebx),%eax
+kernel.asm:80101637:	66 89 42 f6          	mov    %ax,-0xa(%edx)
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:8010163b:	0f b7 43 f8          	movzwl -0x8(%ebx),%eax
+kernel.asm:8010163f:	66 89 42 f8          	mov    %ax,-0x8(%edx)
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:80101643:	0f b7 43 fa          	movzwl -0x6(%ebx),%eax
+kernel.asm:80101647:	66 89 42 fa          	mov    %ax,-0x6(%edx)
+kernel.asm:  dip->size = ip->size;
+kernel.asm:8010164b:	8b 43 fc             	mov    -0x4(%ebx),%eax
+kernel.asm:8010164e:	89 42 fc             	mov    %eax,-0x4(%edx)
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  dip->minor = ip->minor;
+kernel.asm:  dip->nlink = ip->nlink;
+kernel.asm:  dip->size = ip->size;
+kernel.asm:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+kernel.asm:  ip->ref++;
+kernel.asm:  if(ip == 0 || ip->ref < 1)
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    ip->flags |= I_VALID;
+kernel.asm:    if(ip->type == 0)
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:    ip->type = dip->type;
+kernel.asm:    ip->major = dip->major;
+kernel.asm:    ip->minor = dip->minor;
+kernel.asm:    ip->nlink = dip->nlink;
+kernel.asm:    ip->size = dip->size;
+kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+kernel.asm:  acquiresleep(&ip->lock);
+kernel.asm:  if(!(ip->flags & I_VALID)){
+kernel.asm:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+kernel.asm:    dip = (struct dinode*)bp->data + ip->inum%IPB;
+kernel.asm:    ip->type = dip->type;
+kernel.asm:    ip->major = dip->major;
+kernel.asm:8010171b:	0f b7 42 f6          	movzwl -0xa(%edx),%eax
+kernel.asm:    ip->minor = dip->minor;
+kernel.asm:80101723:	0f b7 42 f8          	movzwl -0x8(%edx),%eax
+kernel.asm:    ip->nlink = dip->nlink;
+kernel.asm:8010172b:	0f b7 42 fa          	movzwl -0x6(%edx),%eax
+kernel.asm:    ip->size = dip->size;
+kernel.asm:80101733:	8b 42 fc             	mov    -0x4(%edx),%eax
+kernel.asm:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+kernel.asm:    ip->flags |= I_VALID;
+kernel.asm:    if(ip->type == 0)
+kernel.asm:  if(ip == 0 || ip->ref < 1)
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  releasesleep(&ip->lock);
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  releasesleep(&ip->lock);
+kernel.asm:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    ip->type = 0;
+kernel.asm:    ip->flags = 0;
+kernel.asm:  ip->ref--;
+kernel.asm:    ip->flags = 0;
+kernel.asm:  ip->ref--;
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    if(ip->addrs[i]){
+kernel.asm:      bfree(ip->dev, ip->addrs[i]);
+kernel.asm:      ip->addrs[i] = 0;
+kernel.asm:  if(ip->addrs[NDIRECT]){
+kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    ip->addrs[NDIRECT] = 0;
+kernel.asm:  ip->size = 0;
+kernel.asm:  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+kernel.asm:    ip->type = 0;
+kernel.asm:    ip->flags = 0;
+kernel.asm:      ip->addrs[i] = 0;
+kernel.asm:  if(ip->addrs[NDIRECT]){
+kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:      ip->addrs[i] = 0;
+kernel.asm:  if(ip->addrs[NDIRECT]){
+kernel.asm:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:80101898:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:    a = (uint*)bp->data;
+kernel.asm:        bfree(ip->dev, a[j]);
+kernel.asm:801018c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:    bfree(ip->dev, ip->addrs[NDIRECT]);
+kernel.asm:    ip->addrs[NDIRECT] = 0;
+kernel.asm:  st->dev = ip->dev;
+kernel.asm:  st->ino = ip->inum;
+kernel.asm:  st->type = ip->type;
+kernel.asm:  st->nlink = ip->nlink;
+kernel.asm:  st->size = ip->size;
+kernel.asm:80101952:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:8010195d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:80101971:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:8010198b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+kernel.asm:80101990:	89 7d d8             	mov    %edi,-0x28(%ebp)
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:80101998:	8b 5d d8             	mov    -0x28(%ebp),%ebx
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:801019ba:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:801019d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:      cprintf("%x ", bp->data[off%BSIZE+j]);
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:801019e2:	89 55 dc             	mov    %edx,-0x24(%ebp)
+kernel.asm:801019ed:	8b 55 dc             	mov    -0x24(%ebp),%edx
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    return -1;
+kernel.asm:  if(off + n > ip->size)
+kernel.asm:    n = ip->size - off;
+kernel.asm:801019f8:	01 5d e0             	add    %ebx,-0x20(%ebp)
+kernel.asm:801019fb:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:80101a00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:80101a1a:	8b 04 c5 80 09 11 80 	mov    -0x7feef680(,%eax,8),%eax
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:80101a25:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+kernel.asm:    memmove(dst, bp->data + off%BSIZE, m);
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].read(ip, dst, n);
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+kernel.asm:      return -1;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:80101a57:	89 75 dc             	mov    %esi,-0x24(%ebp)
+kernel.asm:80101a5d:	89 45 d8             	mov    %eax,-0x28(%ebp)
+kernel.asm:80101a60:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:80101a69:	8b 45 d8             	mov    -0x28(%ebp),%eax
+kernel.asm:80101a75:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:80101a8f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:80101a98:	8b 7d d8             	mov    -0x28(%ebp),%edi
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:80101aba:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+kernel.asm:80101abd:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:80101ac0:	8b 55 dc             	mov    -0x24(%ebp),%edx
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+kernel.asm:    m = min(n - tot, BSIZE - off%BSIZE);
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(off > ip->size || off + n < off)
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:80101af9:	01 5d e4             	add    %ebx,-0x1c(%ebp)
+kernel.asm:80101afc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:80101aff:	01 5d dc             	add    %ebx,-0x24(%ebp)
+kernel.asm:80101b02:	39 45 e0             	cmp    %eax,-0x20(%ebp)
+kernel.asm:    memmove(bp->data + off%BSIZE, src, m);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:80101b07:	8b 45 d8             	mov    -0x28(%ebp),%eax
+kernel.asm:    ip->size = off;
+kernel.asm:80101b0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:80101b2a:	8b 04 c5 84 09 11 80 	mov    -0x7feef67c(,%eax,8),%eax
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:      return -1;
+kernel.asm:    return devsw[ip->major].write(ip, src, n);
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:80101b48:	8b 45 d8             	mov    -0x28(%ebp),%eax
+kernel.asm:  if(ip->type == T_DEV){
+kernel.asm:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+kernel.asm:      return -1;
+kernel.asm:  if(n > 0 && off > ip->size){
+kernel.asm:    ip->size = off;
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:80101bbc:	8d 75 d8             	lea    -0x28(%ebp),%esi
+kernel.asm:80101bed:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+kernel.asm:80101bf4:	8d 45 da             	lea    -0x26(%ebp),%eax
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:80101c1e:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
+kernel.asm:      return iget(dp->dev, inum);
+kernel.asm:      return iget(dp->dev, inum);
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:  if(dp->type != T_DIR)
+kernel.asm:80101c70:	89 55 e0             	mov    %edx,-0x20(%ebp)
+kernel.asm:    ip = idup(proc->cwd);
+kernel.asm:  ip->ref++;
+kernel.asm:  len = path - s;
+kernel.asm:80101cf8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:80101d00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:    ip = idup(proc->cwd);
+kernel.asm:    if(ip->type != T_DIR){
+kernel.asm:80101d2b:	8b 55 e0             	mov    -0x20(%ebp),%edx
+kernel.asm:80101d56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:80101d66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:  len = path - s;
+kernel.asm:80101d83:	89 55 dc             	mov    %edx,-0x24(%ebp)
+kernel.asm:80101d86:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+kernel.asm:80101d8e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+kernel.asm:80101d91:	8b 55 dc             	mov    -0x24(%ebp),%edx
+kernel.asm:80101d9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:80101e30:	8d 75 d8             	lea    -0x28(%ebp),%esi
+kernel.asm:80101e67:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+kernel.asm:80101e7d:	8d 45 da             	lea    -0x26(%ebp),%eax
+kernel.asm:80101e9e:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
+kernel.asm:    return -1;
+kernel.asm:  for(off = 0; off < dp->size; off += sizeof(de)){
+kernel.asm:80101eeb:	8d 4d ea             	lea    -0x16(%ebp),%ecx
+kernel.asm:  if(b->blockno >= FSSIZE)
+kernel.asm:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+kernel.asm:  if(b->flags & B_DIRTY){
+kernel.asm:    outsl(0x1f0, b->data, BSIZE/4);
+kernel.asm:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+kernel.asm:  if(b->flags & B_DIRTY){
+kernel.asm:    outsl(0x1f0, b->data, BSIZE/4);
+kernel.asm:  if(b->blockno >= FSSIZE)
+kernel.asm:  ioapicenable(IRQ_IDE, ncpu - 1);
+kernel.asm:  ioapicenable(IRQ_IDE, ncpu - 1);
+kernel.asm:  idequeue = b->qnext;
+kernel.asm:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+kernel.asm:    insl(0x1f0, b->data, BSIZE/4);
+kernel.asm:  b->flags |= B_VALID;
+kernel.asm:  b->flags &= ~B_DIRTY;
+kernel.asm:  idequeue = b->qnext;
+kernel.asm:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+kernel.asm:    insl(0x1f0, b->data, BSIZE/4);
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+kernel.asm:  if(b->dev != 0 && !havedisk1)
+kernel.asm:  acquire(&idelock);  //DOC:acquire-lock
+kernel.asm:  b->qnext = 0;
+kernel.asm:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+kernel.asm:  acquire(&idelock);  //DOC:acquire-lock
+kernel.asm:  b->qnext = 0;
+kernel.asm:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+kernel.asm:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+kernel.asm:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+kernel.asm:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+kernel.asm:  acquire(&idelock);  //DOC:acquire-lock
+kernel.asm:  b->qnext = 0;
+kernel.asm:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+kernel.asm:  if(b->dev != 0 && !havedisk1)
+kernel.asm:  if(!holdingsleep(&b->lock))
+kernel.asm:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+kernel.asm:  ioapic->data = data;
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  return ioapic->data;
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  return ioapic->data;
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  return ioapic->data;
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
+kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark all interrupts edge-triggered, active high, disabled,
+kernel.asm:  // Mark interrupt edge-triggered, active high,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark interrupt edge-triggered, active high,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark interrupt edge-triggered, active high,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark interrupt edge-triggered, active high,
+kernel.asm:  ioapic->reg = reg;
+kernel.asm:  ioapic->data = data;
+kernel.asm:  // Mark interrupt edge-triggered, active high,
+kernel.asm:801022fa:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+kernel.asm:  r->next = kmem.freelist;
+kernel.asm:  r->next = kmem.freelist;
+kernel.asm:  r->next = kmem.freelist;
+kernel.asm:  r->next = kmem.freelist;
+kernel.asm:// Allocate one 4096-byte page of physical memory.
+kernel.asm:    kmem.freelist = r->next;
+kernel.asm:    return -1;
+kernel.asm:80102524:	0f b6 81 20 75 10 80 	movzbl -0x7fef8ae0(%ecx),%eax
+kernel.asm:80102558:	0f b6 91 20 75 10 80 	movzbl -0x7fef8ae0(%ecx),%edx
+kernel.asm:8010255f:	0f b6 81 20 74 10 80 	movzbl -0x7fef8be0(%ecx),%eax
+kernel.asm:8010256f:	8b 04 85 00 74 10 80 	mov    -0x7fef8c00(,%eax,4),%eax
+kernel.asm:80102585:	8d 50 9f             	lea    -0x61(%eax),%edx
+kernel.asm:      c += 'A' - 'a';
+kernel.asm:      c += 'a' - 'A';
+kernel.asm:    return -1;
+kernel.asm:      c += 'A' - 'a';
+kernel.asm:801025a8:	8d 48 bf             	lea    -0x41(%eax),%ecx
+kernel.asm:      c += 'a' - 'A';
+kernel.asm:    return -1;
+kernel.asm:  r->minute = cmos_read(MINS);
+kernel.asm:  r->hour   = cmos_read(HOURS);
+kernel.asm:  r->day    = cmos_read(DAY);
+kernel.asm:  r->month  = cmos_read(MONTH);
+kernel.asm:  r->year   = cmos_read(YEAR);
+kernel.asm:  // Send an Init Level De-Assert to synchronise arbitration ID's.
+kernel.asm:  // Send INIT (level-triggered) interrupt to reset other CPU.
+kernel.asm:  r->year   = cmos_read(YEAR);
+kernel.asm:// qemu seems to use 24-hour GWT and the values are BCD encoded
+kernel.asm:801028c7:	88 45 b7             	mov    %al,-0x49(%ebp)
+kernel.asm:801028ca:	8d 5d b8             	lea    -0x48(%ebp),%ebx
+kernel.asm:801028cd:	80 65 b7 04          	andb   $0x4,-0x49(%ebp)
+kernel.asm:801028d1:	8d 7d d0             	lea    -0x30(%ebp),%edi
+kernel.asm:80102915:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
+kernel.asm:8010291b:	8b 45 b8             	mov    -0x48(%ebp),%eax
+kernel.asm:8010292c:	89 45 b8             	mov    %eax,-0x48(%ebp)
+kernel.asm:8010292f:	8b 45 bc             	mov    -0x44(%ebp),%eax
+kernel.asm:80102940:	89 45 bc             	mov    %eax,-0x44(%ebp)
+kernel.asm:80102943:	8b 45 c0             	mov    -0x40(%ebp),%eax
+kernel.asm:80102954:	89 45 c0             	mov    %eax,-0x40(%ebp)
+kernel.asm:80102957:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+kernel.asm:80102968:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+kernel.asm:8010296b:	8b 45 c8             	mov    -0x38(%ebp),%eax
+kernel.asm:8010297c:	89 45 c8             	mov    %eax,-0x38(%ebp)
+kernel.asm:8010297f:	8b 45 cc             	mov    -0x34(%ebp),%eax
+kernel.asm:80102990:	89 45 cc             	mov    %eax,-0x34(%ebp)
+kernel.asm:80102996:	8b 45 b8             	mov    -0x48(%ebp),%eax
+kernel.asm:8010299b:	8b 45 bc             	mov    -0x44(%ebp),%eax
+kernel.asm:801029a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
+kernel.asm:801029a7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+kernel.asm:801029ad:	8b 45 c8             	mov    -0x38(%ebp),%eax
+kernel.asm:801029b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
+kernel.asm:  r->year += 2000;
+kernel.asm:80102a05:	8b 04 9d ec 26 11 80 	mov    -0x7feed914(,%ebx,4),%eax
+kernel.asm:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+kernel.asm:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+kernel.asm:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+kernel.asm:// Write in-memory log header to disk.
+kernel.asm:  struct logheader *hb = (struct logheader *) (buf->data);
+kernel.asm:  hb->n = log.lh.n;
+kernel.asm:  struct logheader *hb = (struct logheader *) (buf->data);
+kernel.asm:  hb->n = log.lh.n;
+kernel.asm:    hb->block[i] = log.lh.block[i];
+kernel.asm:80102aa8:	8b 0c 95 ec 26 11 80 	mov    -0x7feed914(,%edx,4),%ecx
+kernel.asm:  struct logheader *hb = (struct logheader *) (buf->data);
+kernel.asm:  hb->n = log.lh.n;
+kernel.asm:    hb->block[i] = log.lh.block[i];
+kernel.asm:80102aff:	8d 45 dc             	lea    -0x24(%ebp),%eax
+kernel.asm:80102b0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+kernel.asm:80102b11:	8b 55 e8             	mov    -0x18(%ebp),%edx
+kernel.asm:// Read the log header from disk into the in-memory log header
+kernel.asm:// Read the log header from disk into the in-memory log header
+kernel.asm:// Read the log header from disk into the in-memory log header
+kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
+kernel.asm:  log.lh.n = lh->n;
+kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
+kernel.asm:  log.lh.n = lh->n;
+kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
+kernel.asm:  log.lh.n = lh->n;
+kernel.asm:    log.lh.block[i] = lh->block[i];
+kernel.asm:80102b4c:	89 0c 95 ec 26 11 80 	mov    %ecx,-0x7feed914(,%edx,4)
+kernel.asm:  struct logheader *lh = (struct logheader *) (buf->data);
+kernel.asm:  log.lh.n = lh->n;
+kernel.asm:    log.lh.block[i] = lh->block[i];
+kernel.asm:  log.outstanding -= 1;
+kernel.asm:  log.outstanding -= 1;
+kernel.asm:  log.outstanding -= 1;
+kernel.asm:  log.outstanding -= 1;
+kernel.asm:80102c6d:	8b 04 9d ec 26 11 80 	mov    -0x7feed914(,%ebx,4),%eax
+kernel.asm:    memmove(to->data, from->data, BSIZE);
+kernel.asm:    memmove(to->data, from->data, BSIZE);
+kernel.asm:    write_head();    // Write header to disk -- the real commit
+kernel.asm:  log.outstanding -= 1;
+kernel.asm://   modify bp->data[]
+kernel.asm:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+kernel.asm://   modify bp->data[]
+kernel.asm:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+kernel.asm:80102d3e:	8d 51 ff             	lea    -0x1(%ecx),%edx
+kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
+kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
+kernel.asm:80102d80:	39 0c 85 ec 26 11 80 	cmp    %ecx,-0x7feed914(,%eax,4)
+kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
+kernel.asm:  log.lh.block[i] = b->blockno;
+kernel.asm:80102d90:	89 0c 95 ec 26 11 80 	mov    %ecx,-0x7feed914(,%edx,4)
+kernel.asm:  b->flags |= B_DIRTY; // prevent eviction
+kernel.asm:  log.lh.block[i] = b->blockno;
+kernel.asm:  b->flags |= B_DIRTY; // prevent eviction
+kernel.asm:    if (log.lh.block[i] == b->blockno)   // log absorbtion
+kernel.asm:  log.lh.block[i] = b->blockno;
+kernel.asm:80102db8:	89 0c 85 ec 26 11 80 	mov    %ecx,-0x7feed914(,%eax,4)
+kernel.asm:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+kernel.asm:  xchg(&cpu->started, 1); // tell startothers() we're up
+kernel.asm:  // The + in "+m" denotes a read-modify-write operand.
+kernel.asm:    *(void**)(code-4) = stack + KSTACKSIZE;
+kernel.asm:    *(void**)(code-8) = mpenter;
+kernel.asm:    *(int**)(code-12) = (void *) V2P(entrypgdir);
+kernel.asm:    *(void**)(code-4) = stack + KSTACKSIZE;
+kernel.asm:    *(void**)(code-8) = mpenter;
+kernel.asm:    *(int**)(code-12) = (void *) V2P(entrypgdir);
+kernel.asm:    lapicstartap(c->apicid, V2P(code));
+kernel.asm:    while(c->started == 0)
+kernel.asm:80102fb4:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:8010307d:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:80103096:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:  if(conf->version != 1 && conf->version != 4)
+kernel.asm:801030a6:	0f b6 86 06 00 00 80 	movzbl -0x7ffffffa(%esi),%eax
+kernel.asm:  if(sum((uchar*)conf, conf->length) != 0)
+kernel.asm:801030b5:	0f b7 86 04 00 00 80 	movzwl -0x7ffffffc(%esi),%eax
+kernel.asm:801030c8:	0f b6 9c 16 00 00 00 	movzbl -0x80000000(%esi,%edx,1),%ebx
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:  if(conf->version != 1 && conf->version != 4)
+kernel.asm:  if(sum((uchar*)conf, conf->length) != 0)
+kernel.asm:801030dd:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+kernel.asm:  lapic = (uint*)conf->lapicaddr;
+kernel.asm:801030ee:	8b 86 24 00 00 80    	mov    -0x7fffffdc(%esi),%eax
+kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+kernel.asm:801030f9:	0f b7 8e 04 00 00 80 	movzwl -0x7ffffffc(%esi),%ecx
+kernel.asm:80103100:	8d 86 2c 00 00 80    	lea    -0x7fffffd4(%esi),%eax
+kernel.asm:80103118:	ff 24 95 d4 76 10 80 	jmp    *-0x7fef892c(,%edx,4)
+kernel.asm:  lapic = (uint*)conf->lapicaddr;
+kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+kernel.asm:  lapic = (uint*)conf->lapicaddr;
+kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+kernel.asm:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+kernel.asm:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+kernel.asm:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+kernel.asm:80103174:	88 9a a0 27 11 80    	mov    %bl,-0x7feed860(%edx)
+kernel.asm:      ioapicid = ioapic->apicno;
+kernel.asm:      ioapicid = ioapic->apicno;
+kernel.asm:  if(mp->imcrp){
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:    if((mp = mpsearch1(p-1024, 1024)))
+kernel.asm:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+kernel.asm:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+kernel.asm:  if(conf->version != 1 && conf->version != 4)
+kernel.asm:  p->readopen = 1;
+kernel.asm:  p->writeopen = 1;
+kernel.asm:  p->nwrite = 0;
+kernel.asm:  p->nread = 0;
+kernel.asm:  initlock(&p->lock, "pipe");
+kernel.asm:  (*f0)->type = FD_PIPE;
+kernel.asm:  (*f0)->readable = 1;
+kernel.asm:  (*f0)->writable = 0;
+kernel.asm:  (*f0)->pipe = p;
+kernel.asm:  (*f1)->type = FD_PIPE;
+kernel.asm:  (*f1)->readable = 0;
+kernel.asm:  (*f1)->writable = 1;
+kernel.asm:  (*f1)->pipe = p;
+kernel.asm:  (*f0)->writable = 0;
+kernel.asm:  (*f0)->pipe = p;
+kernel.asm:  (*f1)->type = FD_PIPE;
+kernel.asm:  (*f1)->readable = 0;
+kernel.asm:  (*f1)->writable = 1;
+kernel.asm:  (*f1)->pipe = p;
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    p->writeopen = 0;
+kernel.asm:    wakeup(&p->nread);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:    release(&p->lock);
+kernel.asm:    p->readopen = 0;
+kernel.asm:    wakeup(&p->nwrite);
+kernel.asm:  if(p->readopen == 0 && p->writeopen == 0){
+kernel.asm:    release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:80103464:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:8010346a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:      if(p->readopen == 0 || proc->killed){
+kernel.asm:        release(&p->lock);
+kernel.asm:        return -1;
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:        return -1;
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:801034e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:801034fa:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+kernel.asm:  acquire(&p->lock);
+kernel.asm:80103505:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:80103508:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+kernel.asm:      wakeup(&p->nread);
+kernel.asm:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:      if(p->readopen == 0 || proc->killed){
+kernel.asm:        release(&p->lock);
+kernel.asm:        return -1;
+kernel.asm:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+kernel.asm:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:    if(proc->killed){
+kernel.asm:      release(&p->lock);
+kernel.asm:      return -1;
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:    if(proc->killed){
+kernel.asm:      release(&p->lock);
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:  acquire(&p->lock);
+kernel.asm:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+kernel.asm:    if(proc->killed){
+kernel.asm:      release(&p->lock);
+kernel.asm:      return -1;
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:      release(&p->lock);
+kernel.asm:      return -1;
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:  for(i = 0; i < n; i++){  //DOC: piperead-copy
+kernel.asm:    if(p->nread == p->nwrite)
+kernel.asm:      release(&p->lock);
+kernel.asm:      return -1;
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:  for(i = 0; i < n; i++){  //DOC: piperead-copy
+kernel.asm:    if(p->nread == p->nwrite)
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:      release(&p->lock);
+kernel.asm:      return -1;
+kernel.asm:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+kernel.asm:  for(i = 0; i < n; i++){  //DOC: piperead-copy
+kernel.asm:    if(p->nread == p->nwrite)
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:    addr[i] = p->data[p->nread++ % PIPESIZE];
+kernel.asm:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+kernel.asm:  release(&p->lock);
+kernel.asm:    cprintf("SIG RETURN AFTER what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:    cprintf("A signal %d was accepted by process %d", sig, proc->pid);
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:  p->state = EMBRYO;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:  p->state = EMBRYO;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:  p->state = EMBRYO;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+kernel.asm:  p->alarmTime=-1;
+kernel.asm:  p->pid = nextpid++;
+kernel.asm:      p->sigFuncs[i] = &defaultHandler;
+kernel.asm:  if((p->kstack = kalloc()) == 0){
+kernel.asm:  sp = p->kstack + KSTACKSIZE;
+kernel.asm:  sp -= sizeof *p->tf;
+kernel.asm:  sp -= 4;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  sp = p->kstack + KSTACKSIZE;
+kernel.asm:  sp -= sizeof *p->tf;
+kernel.asm:  p->tf = (struct trapframe*)sp;
+kernel.asm:  sp -= 4;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  sp -= 4;
+kernel.asm:  sp -= sizeof *p->context;
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:  p->context = (struct context*)sp;
+kernel.asm:  memset(p->context, 0, sizeof *p->context);
+kernel.asm:  p->context->eip = (uint)forkret;
+kernel.asm:  if((p->kstack = kalloc()) == 0){
+kernel.asm:    p->state = UNUSED;
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+kernel.asm:  p->sz = PGSIZE;
+kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+kernel.asm:  p->sz = PGSIZE;
+kernel.asm:  memset(p->tf, 0, sizeof(*p->tf));
+kernel.asm:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+kernel.asm:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+kernel.asm:  p->tf->es = p->tf->ds;
+kernel.asm:  p->tf->ss = p->tf->ds;
+kernel.asm:  p->tf->eflags = FL_IF;
+kernel.asm:  p->tf->esp = PGSIZE;
+kernel.asm:  p->tf->eip = 0;  // beginning of initcode.S
+kernel.asm:  safestrcpy(p->name, "initcode", sizeof(p->name));
+kernel.asm:  p->cwd = namei("/");
+kernel.asm:  // this assignment to p->state lets other cores
+kernel.asm:  p->state = RUNNABLE;
+kernel.asm:  if((p->pgdir = setupkvm()) == 0)
+kernel.asm:// Return 0 on success, -1 on failure.
+kernel.asm:  sz = proc->sz;
+kernel.asm:// Return 0 on success, -1 on failure.
+kernel.asm:  sz = proc->sz;
+kernel.asm:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+kernel.asm:      return -1;
+kernel.asm:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+kernel.asm:      return -1;
+kernel.asm:  proc->sz = sz;
+kernel.asm:  sz = proc->sz;
+kernel.asm:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+kernel.asm:      return -1;
+kernel.asm:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+kernel.asm:  sz = proc->sz;
+kernel.asm:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:  proc->sz = sz;
+kernel.asm:    return -1;
+kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:    return -1;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:    return -1;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:  np->sz = proc->sz;
+kernel.asm:  np->parent = proc;
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:    if(proc->ofile[i])
+kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+kernel.asm:  *np->tf = *proc->tf;
+kernel.asm:  np->tf->eax = 0;
+kernel.asm:    if(proc->ofile[i])
+kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
+kernel.asm:  np->cwd = idup(proc->cwd);
+kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+kernel.asm:  pid = np->pid;
+kernel.asm:  np->state = RUNNABLE;
+kernel.asm:    return -1;
+kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:    return -1;
+kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+kernel.asm:    kfree(np->kstack);
+kernel.asm:    np->kstack = 0;
+kernel.asm:    np->state = UNUSED;
+kernel.asm:    return -1;
+kernel.asm:// be proc->intena and proc->ncli, but that would
+kernel.asm:  if(cpu->ncli != 1)
+kernel.asm:  if(proc->state == RUNNING)
+kernel.asm:  intena = cpu->intena;
+kernel.asm:  swtch(&proc->context, cpu->scheduler);
+kernel.asm:  cpu->intena = intena;
+kernel.asm:  if(cpu->ncli != 1)
+kernel.asm:  if(proc->state == RUNNING)
+kernel.asm:  if(cpu->ncli != 1)
+kernel.asm:  if(proc->state == RUNNING)
+kernel.asm:  if(cpu->ncli != 1)
+kernel.asm:    if(proc->ofile[fd]){
+kernel.asm:      fileclose(proc->ofile[fd]);
+kernel.asm:      proc->ofile[fd] = 0;
+kernel.asm:      fileclose(proc->ofile[fd]);
+kernel.asm:      proc->ofile[fd] = 0;
+kernel.asm:  iput(proc->cwd);
+kernel.asm:  proc->cwd = 0;
+kernel.asm:  wakeup1(proc->parent);
+kernel.asm:  proc->cwd = 0;
+kernel.asm:  wakeup1(proc->parent);
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:  wakeup1(proc->parent);
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:  wakeup1(proc->parent);
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:      if(p->state == ZOMBIE)
+kernel.asm:  wakeup1(proc->parent);
+kernel.asm:    if(p->parent == proc){
+kernel.asm:      p->parent = initproc;
+kernel.asm:      if(p->state == ZOMBIE)
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:  proc->state = ZOMBIE;
+kernel.asm:  proc->state = RUNNABLE;
+kernel.asm:  // change p->state and then call sched.
+kernel.asm:  proc->chan = chan;
+kernel.asm:  proc->state = SLEEPING;
+kernel.asm:  proc->chan = 0;
+kernel.asm:  proc->chan = 0;
+kernel.asm:  proc->chan = chan;
+kernel.asm:  proc->state = SLEEPING;
+kernel.asm:  proc->chan = 0;
+kernel.asm:// Return -1 if this process has no children.
+kernel.asm:      if(p->parent != proc)
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:      if(p->parent != proc)
+kernel.asm:    if(!havekids || proc->killed){
+kernel.asm:      return -1;
+kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:      if(p->parent != proc)
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:        p->kstack = 0;
+kernel.asm:        freevm(p->pgdir);
+kernel.asm:      if(p->state == ZOMBIE){
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:        p->kstack = 0;
+kernel.asm:        freevm(p->pgdir);
+kernel.asm:        p->pid = 0;
+kernel.asm:        p->parent = 0;
+kernel.asm:        p->name[0] = 0;
+kernel.asm:        p->killed = 0;
+kernel.asm:        p->state = UNUSED;
+kernel.asm:        pid = p->pid;
+kernel.asm:        kfree(p->kstack);
+kernel.asm:        p->kstack = 0;
+kernel.asm:        freevm(p->pgdir);
+kernel.asm:        p->pid = 0;
+kernel.asm:        p->parent = 0;
+kernel.asm:        p->name[0] = 0;
+kernel.asm:        p->killed = 0;
+kernel.asm:        p->state = UNUSED;
+kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+kernel.asm:        p->parent = 0;
+kernel.asm:        p->name[0] = 0;
+kernel.asm:        p->killed = 0;
+kernel.asm:        p->state = UNUSED;
+kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+kernel.asm:    if(!havekids || proc->killed){
+kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+kernel.asm:    if(!havekids || proc->killed){
+kernel.asm:      return -1;
+kernel.asm:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+kernel.asm:    if(p->state == SLEEPING && p->chan == chan)
+kernel.asm:      p->state = RUNNABLE;
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:        p->state = RUNNABLE;
+kernel.asm:  return -1;
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:        p->state = RUNNABLE;
+kernel.asm:  return -1;
+kernel.asm:    if(p->pid == pid){
+kernel.asm:      p->killed = 1;
+kernel.asm:      if(p->state == SLEEPING)
+kernel.asm:        p->state = RUNNABLE;
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:80103f5e:	8d 75 e8             	lea    -0x18(%ebp),%esi
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:80103f86:	8b 43 9c             	mov    -0x64(%ebx),%eax
+kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+kernel.asm:      state = states[p->state];
+kernel.asm:    if(p->state == UNUSED)
+kernel.asm:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+kernel.asm:80103f97:	8b 14 85 9c 78 10 80 	mov    -0x7fef8764(,%eax,4),%edx
+kernel.asm:      state = states[p->state];
+kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+kernel.asm:80103fa8:	8b 43 a0             	mov    -0x60(%ebx),%eax
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:80103fc3:	83 7b 9c 02          	cmpl   $0x2,-0x64(%ebx)
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:80103fc9:	8d 45 c0             	lea    -0x40(%ebp),%eax
+kernel.asm:80103fd0:	8b 43 b0             	mov    -0x50(%ebx),%eax
+kernel.asm:80103fd3:	8d 7d c0             	lea    -0x40(%ebp),%edi
+kernel.asm:    cprintf("%d %s %s", p->pid, state, p->name);
+kernel.asm:    if(p->state == SLEEPING){
+kernel.asm:      getcallerpcs((uint*)p->context->ebp+2, pc);
+kernel.asm:        return (sighandler_t) -1;
+kernel.asm:        return (sighandler_t) -1;
+kernel.asm:    sighandler_t oldHandler = proc->sigFuncs[signum];
+kernel.asm:    proc->sigFuncs[signum] = handler;
+kernel.asm:        return (sighandler_t) -1;
+kernel.asm:    sighandler_t oldHandler = proc->sigFuncs[signum];
+kernel.asm:    proc->sigFuncs[signum] = handler;
+kernel.asm:    //if fail --> -1 [need to add case!]
+kernel.asm:        return -1; struct proc *p; int found=0; for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+kernel.asm:        if(p->pid == pid && (p->state==RUNNING || p->state==RUNNABLE || p->state==SLEEPING)){
+kernel.asm:    for(i = signum-1; i>0; i--){
+kernel.asm:80104084:	8d 53 ff             	lea    -0x1(%ebx),%edx
+kernel.asm:        return -1;
+kernel.asm:    for(i = signum-1; i>0; i--){
+kernel.asm:    for(i = signum-1; i>0; i--){
+kernel.asm:    p->pending = sigHex | p->pending;
+kernel.asm:    //if fail --> -1 [need to add case!]
+kernel.asm:        return -1; struct proc *p; int found=0; for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+kernel.asm:    p->pending = sigHex | p->pending;
+kernel.asm://  - swtch to start running that process
+kernel.asm://  - eventually that process transfers control
+kernel.asm:      if(p->state != RUNNABLE)
+kernel.asm:     /* if(p->alarmTime>0){
+kernel.asm:	p->alarmTime -=1;
+kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+kernel.asm:      p->state = RUNNING;
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:80104112:	8b 83 14 ff ff ff    	mov    -0xec(%ebx),%eax
+kernel.asm:      p->state = RUNNING;
+kernel.asm:80104118:	c7 83 00 ff ff ff 04 	movl   $0x4,-0x100(%ebx)
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:      swtch(&cpu->scheduler, p->context);
+kernel.asm:      // It should have changed its p->state before coming back.
+kernel.asm:      // It should have changed its p->state before coming back.
+kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+kernel.asm:            //p->alarmTime=0; //reset alarmTime
+kernel.asm:            p->alarmTime=-1;
+kernel.asm:            sigsend(p->pid,SIGALRM);
+kernel.asm:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+kernel.asm:            //p->alarmTime=0; //reset alarmTime
+kernel.asm:            p->alarmTime=-1;
+kernel.asm:            sigsend(p->pid,SIGALRM);
+kernel.asm:    *proc->tf = *(struct trapframe*)proc->tf->esp;
+kernel.asm:    cprintf("SIG RETURN BEFORE what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:    ////////////// should be *proc->tf=proc->tf->esp+4;
+kernel.asm:    proc->tf->esp +=sizeof(uint);
+kernel.asm:    proc->tf->esp += sizeof(int);
+kernel.asm:    int length = endInvokeSignal - invokeSignal;
+kernel.asm:    proc->tf->esp += length;
+kernel.asm:    cprintf("SIG RETURN BEFORE what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:    ////////////// should be *proc->tf=proc->tf->esp+4;
+kernel.asm:    proc->tf->esp +=sizeof(uint);
+kernel.asm:    proc->tf->esp += sizeof(int);
+kernel.asm:    int length = endInvokeSignal - invokeSignal;
+kernel.asm:    proc->tf->esp += length;
+kernel.asm:    //proc->tf->esp += sizeof(int);
+kernel.asm:    *proc->tf = *((struct trapframe *)proc->tf->esp);
+kernel.asm:    cprintf("SIG RETURN AFTER what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:    if (proc == 0 || !((tf->cs&3) == DPL_USER)) //IF IT ISN'T RETURNING TO USER SPACE -> EXIT! 
+kernel.asm:    if (proc == 0 || !((tf->cs&3) == DPL_USER)) //IF IT ISN'T RETURNING TO USER SPACE -> EXIT! 
+kernel.asm:    if (proc == 0 || !((tf->cs&3) == DPL_USER)) //IF IT ISN'T RETURNING TO USER SPACE -> EXIT! 
+kernel.asm:    if (proc->pending == 0)
+kernel.asm:            proc->pending = proc->pending & ~(1 << i);
+kernel.asm:            //cprintf("\nproc->pending is after: %d\n",proc->pending);
+kernel.asm:    //cprintf("\nproc->pending is before: %d\n",proc->pending);
+kernel.asm:80104264:	8d 4b ff             	lea    -0x1(%ebx),%ecx
+kernel.asm:        if (proc->pending & (1 << i)){
+kernel.asm:            if (proc->sigFuncs[sigNum] == &defaultHandler)
+kernel.asm:80104277:	89 7d e4             	mov    %edi,-0x1c(%ebp)
+kernel.asm:                proc->pending = proc->pending & ~(1 << i);
+kernel.asm:            proc->pending = proc->pending & ~(1 << i);
+kernel.asm:    //tf->eip=(int)proc->sigFuncs[sigNum];
+kernel.asm:    cprintf("HANDLE BEFORE what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:    int temp_esp = tf->esp;
+kernel.asm:    temp_esp -= sizeof(struct trapframe);
+kernel.asm:    int temp_esp = tf->esp;
+kernel.asm:    temp_esp -= sizeof(struct trapframe);
+kernel.asm:    tf->esp -= sizeof(struct trapframe);
+kernel.asm:    //tf->esp -= sizeof(int); //update the magic number
+kernel.asm:    //tf->esp -= sizeof(int);
+kernel.asm:    // *((int*)tf->esp)=200;
+kernel.asm:    int length = endInvokeSignal - invokeSignal;
+kernel.asm:    int temp_esp = tf->esp;
+kernel.asm:    temp_esp -= sizeof(struct trapframe);
+kernel.asm:    tf->esp -= sizeof(struct trapframe);
+kernel.asm:    //tf->esp -= sizeof(int);
+kernel.asm:    // *((int*)tf->esp)=200;
+kernel.asm:    int length = endInvokeSignal - invokeSignal;
+kernel.asm:    tf->esp -= length; //decrease tf->esp by the length of the InvokeSignal segment 
+kernel.asm:    int offset = tf->esp;
+kernel.asm:    memmove((int*)tf->esp, invokeSignal, length);
+kernel.asm:    tf->esp -=4; //decrease esp by 4 so that we can push the sigNum
+kernel.asm:801042eb:	8d 50 fc             	lea    -0x4(%eax),%edx
+kernel.asm:    *(int*) tf->esp = sigNum;
+kernel.asm:801042f1:	89 58 fc             	mov    %ebx,-0x4(%eax)
+kernel.asm:    tf->esp -= 4;
+kernel.asm:801042f7:	8d 50 fc             	lea    -0x4(%eax),%edx
+kernel.asm:    *(int*) tf->esp = offset;
+kernel.asm:801042fd:	89 78 fc             	mov    %edi,-0x4(%eax)
+kernel.asm:    proc->tf->eip = (int) proc->sigFuncs[sigNum];
+kernel.asm:80104300:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+kernel.asm:    cprintf("HANDLE AFTER what is proc->tf->eip? %d\n", proc->tf->eip);
+kernel.asm:80104338:	c7 45 e4 41 00 00 00 	movl   $0x41,-0x1c(%ebp)
+kernel.asm:    cprintf("A signal %d was accepted by process %d", sig, proc->pid);
+kernel.asm:80104352:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+kernel.asm:        if (proc->pending & (1 << i)){
+kernel.asm:            if (proc->sigFuncs[sigNum] == &defaultHandler)
+kernel.asm:                proc->pending = proc->pending & ~(1 << i);
+kernel.asm:8010436a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+kernel.asm:        proc->alarmTime=-1;
+kernel.asm:        proc->alarmTime=-1;
+kernel.asm:    proc->alarmTime = pticks;
+kernel.asm:    proc->initAlarmTime = ticks;
+kernel.asm:  initlock(&lk->lk, "sleep lock");
+kernel.asm:  lk->name = name;
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->pid = 0;
+kernel.asm:  initlock(&lk->lk, "sleep lock");
+kernel.asm:  lk->name = name;
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->pid = 0;
+kernel.asm:  acquire(&lk->lk);
+kernel.asm:  while (lk->locked) {
+kernel.asm:    sleep(lk, &lk->lk);
+kernel.asm:  acquire(&lk->lk);
+kernel.asm:  while (lk->locked) {
+kernel.asm:    sleep(lk, &lk->lk);
+kernel.asm:  lk->locked = 1;
+kernel.asm:  lk->pid = proc->pid;
+kernel.asm:  release(&lk->lk);
+kernel.asm:  while (lk->locked) {
+kernel.asm:    sleep(lk, &lk->lk);
+kernel.asm:  lk->locked = 1;
+kernel.asm:  lk->pid = proc->pid;
+kernel.asm:  release(&lk->lk);
+kernel.asm:  acquire(&lk->lk);
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->pid = 0;
+kernel.asm:  release(&lk->lk);
+kernel.asm:  acquire(&lk->lk);
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->pid = 0;
+kernel.asm:  release(&lk->lk);
+kernel.asm:  acquire(&lk->lk);
+kernel.asm:  r = lk->locked;
+kernel.asm:  release(&lk->lk);
+kernel.asm:  lk->name = name;
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->name = name;
+kernel.asm:  lk->locked = 0;
+kernel.asm:  lk->cpu = 0;
+kernel.asm:  ebp = (uint*)v - 2;
+kernel.asm:  ebp = (uint*)v - 2;
+kernel.asm:801044ea:	8d 50 f8             	lea    -0x8(%eax),%edx
+kernel.asm:801044f0:	8d 9a 00 00 00 80    	lea    -0x80000000(%edx),%ebx
+kernel.asm:  ebp = (uint*)v - 2;
+kernel.asm:  ebp = (uint*)v - 2;
+kernel.asm:  if(cpu->ncli == 0)
+kernel.asm:    cpu->intena = eflags & FL_IF;
+kernel.asm:  cpu->ncli += 1;
+kernel.asm:  return lock->locked && lock->cpu == cpu;
+kernel.asm:  // The + in "+m" denotes a read-modify-write operand.
+kernel.asm:  while(xchg(&lk->locked, 1) != 0)
+kernel.asm:  lk->cpu = cpu;
+kernel.asm:  getcallerpcs(&lk, lk->pcs);
+kernel.asm:  lk->cpu = cpu;
+kernel.asm:801045a6:	89 50 fc             	mov    %edx,-0x4(%eax)
+kernel.asm:  getcallerpcs(&lk, lk->pcs);
+kernel.asm:  return lock->locked && lock->cpu == cpu;
+kernel.asm:  return lock->locked && lock->cpu == cpu;
+kernel.asm:  if(cpu->ncli == 0)
+kernel.asm:    cpu->intena = eflags & FL_IF;
+kernel.asm:  cpu->ncli += 1;
+kernel.asm:    panic("popcli - interruptible");
+kernel.asm:  if(--cpu->ncli < 0)
+kernel.asm:80104639:	8d 51 ff             	lea    -0x1(%ecx),%edx
+kernel.asm:  if(cpu->ncli == 0 && cpu->intena)
+kernel.asm:    panic("popcli - interruptible");
+kernel.asm:  if(--cpu->ncli < 0)
+kernel.asm:    panic("popcli - interruptible");
+kernel.asm:  return lock->locked && lock->cpu == cpu;
+kernel.asm:  lk->pcs[0] = 0;
+kernel.asm:  lk->cpu = 0;
+kernel.asm:  // Both the C compiler and the hardware may re-order loads and
+kernel.asm:  // Release the lock, equivalent to lk->locked = 0.
+kernel.asm:  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+kernel.asm:  // Release the lock, equivalent to lk->locked = 0.
+kernel.asm:  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+kernel.asm:  while(n-- > 0){
+kernel.asm:80104721:	8d 78 ff             	lea    -0x1(%eax),%edi
+kernel.asm:  while(n-- > 0){
+kernel.asm:      return *s1 - *s2;
+kernel.asm:      return *s1 - *s2;
+kernel.asm:  while(n-- > 0){
+kernel.asm:      return *s1 - *s2;
+kernel.asm:    while(n-- > 0)
+kernel.asm:    while(n-- > 0)
+kernel.asm:8010477f:	8d 53 ff             	lea    -0x1(%ebx),%edx
+kernel.asm:      *--d = *--s;
+kernel.asm:    while(n-- > 0)
+kernel.asm:    while(n-- > 0)
+kernel.asm:    while(n-- > 0)
+kernel.asm:      *--d = *--s;
+kernel.asm:    while(n-- > 0)
+kernel.asm:    while(n-- > 0)
+kernel.asm:      *--d = *--s;
+kernel.asm:    while(n-- > 0)
+kernel.asm:    n--, p++, q++;
+kernel.asm:    n--, p++, q++;
+kernel.asm:    n--, p++, q++;
+kernel.asm:  return (uchar)*p - (uchar)*q;
+kernel.asm:    n--, p++, q++;
+kernel.asm:  return (uchar)*p - (uchar)*q;
+kernel.asm:    n--, p++, q++;
+kernel.asm:  return (uchar)*p - (uchar)*q;
+kernel.asm:  return (uchar)*p - (uchar)*q;
+kernel.asm:  while(n-- > 0 && (*s++ = *t++) != 0)
+kernel.asm:8010486b:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
+kernel.asm:80104874:	88 4a ff             	mov    %cl,-0x1(%edx)
+kernel.asm:8010487d:	8d 71 ff             	lea    -0x1(%ecx),%esi
+kernel.asm:  while(n-- > 0)
+kernel.asm:  while(n-- > 0 && (*s++ = *t++) != 0)
+kernel.asm:  while(n-- > 0)
+kernel.asm:// Like strncpy but guaranteed to NUL-terminate.
+kernel.asm:801048b2:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
+kernel.asm:  while(--n > 0 && (*s++ = *t++) != 0)
+kernel.asm:801048c3:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
+kernel.asm:801048cc:	88 59 ff             	mov    %bl,-0x1(%ecx)
+kernel.asm:  # Save old callee-save registers
+kernel.asm:  # Load new callee-save registers
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:// Fetch the nul-terminated string at addr from the current process.
+kernel.asm:// Doesn't actually copy the string - just sets *pp to point at it.
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:      return s - *pp;
+kernel.asm:  return -1;
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:      return s - *pp;
+kernel.asm:  return -1;
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:// Fetch the nth word-sized system call argument as a pointer
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  if(size < 0 || (uint)i >= proc->sz || (uint)i+size > proc->sz)
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:  if(size < 0 || (uint)i >= proc->sz || (uint)i+size > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:// Check that the pointer is valid and the string is nul-terminated.
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:// Fetch the nth 32-bit system call argument.
+kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:  if(addr >= proc->sz)
+kernel.asm:    return -1;
+kernel.asm:  ep = (char*)proc->sz;
+kernel.asm:      return s - *pp;
+kernel.asm:    return -1;
+kernel.asm:  num = proc->tf->eax;
+kernel.asm:80104ab4:	8d 48 ff             	lea    -0x1(%eax),%ecx
+kernel.asm:80104abc:	8b 0c 85 20 79 10 80 	mov    -0x7fef86e0(,%eax,4),%ecx
+kernel.asm:    proc->tf->eax = syscalls[num]();
+kernel.asm:            proc->pid, proc->name, num);
+kernel.asm:    proc->tf->eax = -1;
+kernel.asm:  num = proc->tf->eax;
+kernel.asm:    proc->tf->eax = syscalls[num]();
+kernel.asm:            proc->pid, proc->name, num);
+kernel.asm:  num = proc->tf->eax;
+kernel.asm:    proc->tf->eax = syscalls[num]();
+kernel.asm:            proc->pid, proc->name, num);
+kernel.asm:    proc->tf->eax = -1;
+kernel.asm:  return -1;
+kernel.asm:80104b19:	89 4d c0             	mov    %ecx,-0x40(%ebp)
+kernel.asm:80104b1f:	8d 5d da             	lea    -0x26(%ebp),%ebx
+kernel.asm:  return -1;
+kernel.asm:80104b29:	89 55 c4             	mov    %edx,-0x3c(%ebp)
+kernel.asm:80104b2c:	89 4d bc             	mov    %ecx,-0x44(%ebp)
+kernel.asm:80104b46:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:80104b6f:	66 83 7d c4 02       	cmpw   $0x2,-0x3c(%ebp)
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:    if(type == T_FILE && ip->type == T_FILE)
+kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+kernel.asm:80104ba0:	0f bf 45 c4          	movswl -0x3c(%ebp),%eax
+kernel.asm:  ip->major = major;
+kernel.asm:80104bc4:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
+kernel.asm:  ip->minor = minor;
+kernel.asm:80104bcc:	0f b7 45 bc          	movzwl -0x44(%ebp),%eax
+kernel.asm:  ip->nlink = 1;
+kernel.asm:80104be5:	66 83 7d c4 01       	cmpw   $0x1,-0x3c(%ebp)
+kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  ip->minor = minor;
+kernel.asm:  ip->nlink = 1;
+kernel.asm:    dp->nlink++;  // for ".."
+kernel.asm:    // No ip->nlink++ for ".": avoid cyclic ref count.
+kernel.asm:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+kernel.asm:  if(dirlink(dp, name, ip->inum) < 0)
+kernel.asm:  if((ip = ialloc(dp->dev, type)) == 0)
+kernel.asm:// Fetch the nth word-sized system call argument as a file descriptor
+kernel.asm:80104c9c:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
+kernel.asm:80104cb3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:80104cf9:	8d 55 f4             	lea    -0xc(%ebp),%edx
+kernel.asm:    return -1;
+kernel.asm:80104d05:	8b 55 f4             	mov    -0xc(%ebp),%edx
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:      proc->ofile[fd] = f;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:80104d58:	8d 55 ec             	lea    -0x14(%ebp),%edx
+kernel.asm:80104d64:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:80104d7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:80104d89:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:80104da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:80104da7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104dc8:	8d 55 ec             	lea    -0x14(%ebp),%edx
+kernel.asm:80104dd4:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:80104deb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:80104df9:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:80104e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:80104e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104e36:	8d 55 f4             	lea    -0xc(%ebp),%edx
+kernel.asm:80104e39:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  proc->ofile[fd] = 0;
+kernel.asm:80104e45:	8b 55 f0             	mov    -0x10(%ebp),%edx
+kernel.asm:80104e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  proc->ofile[fd] = 0;
+kernel.asm:80104e78:	8d 55 f0             	lea    -0x10(%ebp),%edx
+kernel.asm:80104e84:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:80104eaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104ec9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+kernel.asm:80104ee4:	8d 45 d0             	lea    -0x30(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80104f04:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    return -1;
+kernel.asm:  ip->nlink++;
+kernel.asm:80104f31:	8d 7d da             	lea    -0x26(%ebp),%edi
+kernel.asm:    return -1;
+kernel.asm:  ip->nlink++;
+kernel.asm:80104f44:	8b 45 d0             	mov    -0x30(%ebp),%eax
+kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+kernel.asm:  ip->nlink--;
+kernel.asm:  return -1;
+kernel.asm:  ip->nlink--;
+kernel.asm:  return -1;
+kernel.asm:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+kernel.asm:  ip->nlink--;
+kernel.asm:  return -1;
+kernel.asm:  ip->nlink--;
+kernel.asm:  return -1;
+kernel.asm:80104fe9:	8d 45 c0             	lea    -0x40(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80105009:	8b 45 c0             	mov    -0x40(%ebp),%eax
+kernel.asm:8010500c:	8d 5d ca             	lea    -0x36(%ebp),%ebx
+kernel.asm:8010501d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+kernel.asm:    return -1;
+kernel.asm:80105026:	8b 75 b4             	mov    -0x4c(%ebp),%esi
+kernel.asm:80105061:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+kernel.asm:80105096:	8d 75 d8             	lea    -0x28(%ebp),%esi
+kernel.asm:801050b3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+kernel.asm:801050c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    dp->nlink--;
+kernel.asm:801050e5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+kernel.asm:  ip->nlink--;
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+kernel.asm:8010515b:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:  if(ip->type == T_DIR && !isdirempty(ip)){
+kernel.asm:8010516a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+kernel.asm:  return -1;
+kernel.asm:  return -1;
+kernel.asm:  if(ip->type == T_DIR){
+kernel.asm:    dp->nlink--;
+kernel.asm:80105188:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+kernel.asm:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+kernel.asm:  if(ip->nlink < 1)
+kernel.asm:801051d9:	8d 45 e0             	lea    -0x20(%ebp),%eax
+kernel.asm:801051f4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80105210:	f6 45 e5 02          	testb  $0x2,-0x1b(%ebp)
+kernel.asm:      return -1;
+kernel.asm:80105216:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:      return -1;
+kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+kernel.asm:      return -1;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+kernel.asm:    return -1;
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+kernel.asm:    return -1;
+kernel.asm:80105288:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:      proc->ofile[fd] = f;
+kernel.asm:    return -1;
+kernel.asm:  f->type = FD_INODE;
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:801052bf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:  f->type = FD_INODE;
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+kernel.asm:  f->type = FD_INODE;
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+kernel.asm:  f->type = FD_INODE;
+kernel.asm:  f->ip = ip;
+kernel.asm:  f->off = 0;
+kernel.asm:  f->readable = !(omode & O_WRONLY);
+kernel.asm:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+kernel.asm:      return -1;
+kernel.asm:    if(ip->type == T_DIR && omode != O_RDONLY){
+kernel.asm:801052e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:8010530b:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:80105322:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:8010536b:	8d 45 ec             	lea    -0x14(%ebp),%eax
+kernel.asm:80105382:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:80105399:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:801053b0:	0f bf 45 f4          	movswl -0xc(%ebp),%eax
+kernel.asm:801053b9:	0f bf 4d f0          	movswl -0x10(%ebp),%ecx
+kernel.asm:801053c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:801053fc:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:80105413:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:    return -1;
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:    return -1;
+kernel.asm:  iput(proc->cwd);
+kernel.asm:  proc->cwd = ip;
+kernel.asm:  iput(proc->cwd);
+kernel.asm:  proc->cwd = ip;
+kernel.asm:    return -1;
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:  iput(proc->cwd);
+kernel.asm:  proc->cwd = ip;
+kernel.asm:  if(ip->type != T_DIR){
+kernel.asm:    return -1;
+kernel.asm:  iput(proc->cwd);
+kernel.asm:  proc->cwd = ip;
+kernel.asm:8010548c:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
+kernel.asm:801054aa:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:801054c4:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:801054d4:	8d b5 68 ff ff ff    	lea    -0x98(%ebp),%esi
+kernel.asm:801054e2:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
+kernel.asm:      return -1;
+kernel.asm:801054f0:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
+kernel.asm:      return -1;
+kernel.asm:80105509:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:      return -1;
+kernel.asm:    return -1;
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:80105540:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+kernel.asm:8010554a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:80105550:	c7 84 9d 68 ff ff ff 	movl   $0x0,-0x98(%ebp,%ebx,4)
+kernel.asm:      return -1;
+kernel.asm:80105579:	8d 45 dc             	lea    -0x24(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80105598:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+kernel.asm:8010559f:	8d 45 e0             	lea    -0x20(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:  fd0 = -1;
+kernel.asm:801055b7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:  fd0 = -1;
+kernel.asm:801055d8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:      proc->ofile[fd] = f;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:      proc->ofile[fd] = f;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:    return -1;
+kernel.asm:  fd0 = -1;
+kernel.asm:      proc->ofile[fd0] = 0;
+kernel.asm:80105607:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:      proc->ofile[fd0] = 0;
+kernel.asm:    return -1;
+kernel.asm:    if(proc->ofile[fd] == 0){
+kernel.asm:      proc->ofile[fd] = f;
+kernel.asm:      proc->ofile[fd0] = 0;
+kernel.asm:    return -1;
+kernel.asm:80105624:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+kernel.asm:80105629:	8b 45 dc             	mov    -0x24(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:80105676:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:8010568d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  return proc->pid;
+kernel.asm:  return proc->pid;
+kernel.asm:  return proc->pid;
+kernel.asm:801056c7:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  addr = proc->sz;
+kernel.asm:801056e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+kernel.asm:    return -1;
+kernel.asm:  addr = proc->sz;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:80105717:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:    return -1;
+kernel.asm:  while(ticks - ticks0 < n){
+kernel.asm:8010573a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+kernel.asm:    return -1;
+kernel.asm:  while(ticks - ticks0 < n){
+kernel.asm:    if(proc->killed){
+kernel.asm:      return -1;
+kernel.asm:    return -1;
+kernel.asm:  while(ticks - ticks0 < n){
+kernel.asm:8010576b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+kernel.asm:    if(proc->killed){
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:    return -1;
+kernel.asm:801057f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:8010580d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:8010582c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:80105833:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:80105856:	8d 45 f0             	lea    -0x10(%ebp),%eax
+kernel.asm:8010586d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:80105884:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:8010588b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:801058b6:	8d 45 f4             	lea    -0xc(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:801058cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+kernel.asm:        return -1;
+kernel.asm:  # Set up data and per-cpu segments.
+kernel.asm:80105968:	8b 14 85 0c a0 10 80 	mov    -0x7fef5ff4(,%eax,4),%edx
+kernel.asm:80105974:	66 89 0c c5 22 71 11 	mov    %cx,-0x7fee8ede(,%eax,8)
+kernel.asm:8010597c:	c6 04 c5 24 71 11 80 	movb   $0x0,-0x7fee8edc(,%eax,8)
+kernel.asm:80105984:	c6 04 c5 25 71 11 80 	movb   $0x8e,-0x7fee8edb(,%eax,8)
+kernel.asm:8010598c:	66 89 14 c5 20 71 11 	mov    %dx,-0x7fee8ee0(,%eax,8)
+kernel.asm:80105997:	66 89 14 c5 26 71 11 	mov    %dx,-0x7fee8eda(,%eax,8)
+kernel.asm:  pd[0] = size-1;
+kernel.asm:80105a0b:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+kernel.asm:80105a14:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+kernel.asm:80105a1b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+kernel.asm:80105a1f:	8d 45 fa             	lea    -0x6(%ebp),%eax
+kernel.asm:  if(tf->trapno == T_SYSCALL){
+kernel.asm:    if(proc->killed)
+kernel.asm:  switch(tf->trapno){
+kernel.asm:80105a50:	ff 24 85 90 7a 10 80 	jmp    *-0x7fef8570(,%eax,4)
+kernel.asm:	//need to send signal!proc-
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:    if(proc == 0 || (tf->cs&3) == 0){
+kernel.asm:              tf->trapno, cpunum(), tf->eip, rcr2());
+kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
+kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+kernel.asm:              tf->trapno, cpunum(), tf->eip, rcr2());
+kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
+kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+kernel.asm:              tf->trapno, cpunum(), tf->eip, rcr2());
+kernel.asm:            "eip 0x%x addr 0x%x--kill proc\n",
+kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+kernel.asm:    proc->killed = 1;
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+kernel.asm:  if(tf->trapno == T_SYSCALL){
+kernel.asm:    if(proc->killed)
+kernel.asm:    proc->tf = tf;
+kernel.asm:    if(proc->killed)
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:    if(proc->killed)
+kernel.asm:    proc->tf = tf;
+kernel.asm:    if(proc->killed)
+kernel.asm:            cpunum(), tf->cs, tf->eip);
+kernel.asm:  if(tf->trapno == T_SYSCALL){
+kernel.asm:    if(proc->killed)
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+kernel.asm:  switch(tf->trapno){
+kernel.asm:      /** if((tf->cs&3) == DPL_USER && proc->alarmTime!=-1 && ticks>=proc->alarmTime+proc->initAlarmTime){ //if returning to user mode!
+kernel.asm:	proc->alarmTime=-1;
+kernel.asm:	sigsend(proc->pid, SIGALRM); //send signal!
+kernel.asm:	//need to send signal!proc-
+kernel.asm:  switch(tf->trapno){
+kernel.asm:      /** if((tf->cs&3) == DPL_USER && proc->alarmTime!=-1 && ticks>=proc->alarmTime+proc->initAlarmTime){ //if returning to user mode!
+kernel.asm:	proc->alarmTime=-1;
+kernel.asm:	sigsend(proc->pid, SIGALRM); //send signal!
+kernel.asm:	//need to send signal!proc-
+kernel.asm:    if(proc == 0 || (tf->cs&3) == 0){
+kernel.asm:              tf->trapno, cpunum(), tf->eip, rcr2());
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:    return -1;
+kernel.asm:  // Acknowledge pre-existing interrupt conditions;
+kernel.asm:  // Acknowledge pre-existing interrupt conditions;
+kernel.asm:# generated by vectors.pl - do not edit
+kernel.asm:801068c7:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+kernel.asm:// be page-aligned.
+kernel.asm:// be page-aligned.
+kernel.asm:// be page-aligned.
+kernel.asm:80106904:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+kernel.asm:80106907:	8d 44 0a ff          	lea    -0x1(%edx,%ecx,1),%eax
+kernel.asm:8010690b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:      return -1;
+kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+kernel.asm:80106912:	81 65 e4 00 f0 ff ff 	andl   $0xfffff000,-0x1c(%ebp)
+kernel.asm:      return -1;
+kernel.asm:80106928:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+kernel.asm:      return -1;
+kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+kernel.asm:80106935:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+kernel.asm:      return -1;
+kernel.asm:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+kernel.asm:      return -1;
+kernel.asm:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+kernel.asm:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+kernel.asm:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+kernel.asm:8010698b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+kernel.asm:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+kernel.asm:801069b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:801069b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+kernel.asm:801069f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+kernel.asm:  // Map cpu and proc -- these are private per cpu.
+kernel.asm:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+kernel.asm:  // Map cpu and proc -- these are private per cpu.
+kernel.asm:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+kernel.asm:  pd[0] = size-1;
+kernel.asm:  lgdt(c->gdt, sizeof(c->gdt));
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+kernel.asm:  // Map cpu and proc -- these are private per cpu.
+kernel.asm:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+kernel.asm:80106ae6:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
+kernel.asm:80106aea:	66 89 55 f4          	mov    %dx,-0xc(%ebp)
+kernel.asm:80106af1:	66 89 55 f6          	mov    %dx,-0xa(%ebp)
+kernel.asm:80106af5:	8d 55 f2             	lea    -0xe(%ebp),%edx
+kernel.asm:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+kernel.asm:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+kernel.asm:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+kernel.asm:  lgdt(c->gdt, sizeof(c->gdt));
+kernel.asm:  // Initialize cpu-local storage.
+kernel.asm:  lgdt(c->gdt, sizeof(c->gdt));
+kernel.asm:  // Initialize cpu-local storage.
+kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+kernel.asm:                (uint)k->phys_start, k->perm) < 0)
+kernel.asm:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+kernel.asm:                (uint)k->phys_start, k->perm) < 0)
+kernel.asm:// Switch h/w page table register to the kernel-only page table,
+kernel.asm:// Switch h/w page table register to the kernel-only page table,
+kernel.asm:// Switch h/w page table register to the kernel-only page table,
+kernel.asm:  if(p->kstack == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+kernel.asm:  cpu->gdt[SEG_TSS].s = 0;
+kernel.asm:  cpu->ts.ss0 = SEG_KDATA << 3;
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+kernel.asm:  cpu->gdt[SEG_TSS].s = 0;
+kernel.asm:  cpu->ts.ss0 = SEG_KDATA << 3;
+kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+kernel.asm:  cpu->ts.iomb = (ushort) 0xFFFF;
+kernel.asm:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+kernel.asm:  cpu->gdt[SEG_TSS].s = 0;
+kernel.asm:  cpu->ts.ss0 = SEG_KDATA << 3;
+kernel.asm:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+kernel.asm:  cpu->ts.iomb = (ushort) 0xFFFF;
+kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+kernel.asm:  cpu->ts.iomb = (ushort) 0xFFFF;
+kernel.asm:  lcr3(V2P(p->pgdir));  // switch to process's address space
+kernel.asm:  if(p->kstack == 0)
+kernel.asm:  if(p->pgdir == 0)
+kernel.asm:  if(p->kstack == 0)
+kernel.asm:80106cf8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kernel.asm:80106d1c:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+kernel.asm:80106d2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:// Load a program segment into pgdir.  addr must be page-aligned
+kernel.asm:    if(sz - i < PGSIZE)
+kernel.asm:      n = sz - i;
+kernel.asm:    if(sz - i < PGSIZE)
+kernel.asm:      n = sz - i;
+kernel.asm:      return -1;
+kernel.asm:    if(sz - i < PGSIZE)
+kernel.asm:      n = sz - i;
+kernel.asm:      return -1;
+kernel.asm:      return -1;
+kernel.asm:80106e68:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
+kernel.asm:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+kernel.asm:80106ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+kernel.asm:80107022:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kernel.asm:80107025:	8d 96 00 00 00 80    	lea    -0x80000000(%esi),%edx
+kernel.asm:80107039:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:80107072:	89 75 e4             	mov    %esi,-0x1c(%ebp)
+kernel.asm:80107086:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:801070a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+kernel.asm:      return -1;
+kernel.asm:    n = PGSIZE - (va - va0);
+kernel.asm:80107128:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+kernel.asm:    memmove(pa0 + (va - va0), buf, n);
+kernel.asm:      return -1;
+kernel.asm:    n = PGSIZE - (va - va0);
+kernel.asm:    memmove(pa0 + (va - va0), buf, n);
+kernel.asm:80107149:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kernel.asm:    len -= n;
+kernel.asm:80107151:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kernel.asm:    n = PGSIZE - (va - va0);
+kernel.asm:    memmove(pa0 + (va - va0), buf, n);
+kernel.asm:    len -= n;
+kernel.asm:8010716f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+kernel.asm:    len -= n;
+kernel.asm:      return -1;
+kernel.asm:    len -= n;
+kernel.asm:    memmove(pa0 + (va - va0), buf, n);
+kernel.asm:    len -= n;
+kernel.ld:OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+kernel.ld:	/* Conventionally, Unix linkers provide pseudo-symbols
+kernel.ld:	 * read-only rodata section between text and data. */
+kernel.ld:		*(.eh_frame .note.GNU-stack)
+Binary file _kill matches
+kill.asm:_kill:     file format elf32-i386
+kill.asm:  73:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+kill.asm:  7c:	88 5a ff             	mov    %bl,-0x1(%edx)
+kill.asm:  return (uchar)*p - (uchar)*q;
+kill.asm:  return (uchar)*p - (uchar)*q;
+kill.asm: 17b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+kill.asm: 19c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+kill.asm: 1a7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+kill.asm:    return -1;
+kill.asm:    return -1;
+kill.asm:    return -1;
+kill.asm: 22a:	8d 42 d0             	lea    -0x30(%edx),%eax
+kill.asm:    n = n*10 + *s++ - '0';
+kill.asm: 23e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+kill.asm: 245:	8d 5a d0             	lea    -0x30(%edx),%ebx
+kill.asm:    n = n*10 + *s++ - '0';
+kill.asm:  while(n-- > 0)
+kill.asm:  while(n-- > 0)
+kill.asm:  while(n-- > 0)
+kill.asm:    x = -xx;
+kill.asm: 36d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+kill.asm: 374:	89 75 c0             	mov    %esi,-0x40(%ebp)
+kill.asm:    x = -xx;
+kill.asm: 37b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+kill.asm: 397:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+kill.asm: 39c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+kill.asm:    buf[i++] = '-';
+kill.asm: 3a6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+kill.asm:  while(--i >= 0)
+kill.asm: 3ab:	8d 79 ff             	lea    -0x1(%ecx),%edi
+kill.asm: 3b0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+kill.asm: 3c7:	88 45 d7             	mov    %al,-0x29(%ebp)
+kill.asm:    buf[i++] = '-';
+kill.asm:  while(--i >= 0)
+kill.asm:    x = -xx;
+kill.asm: 3e4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+kill.asm: 404:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+kill.asm: 421:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+kill.asm: 433:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+kill.asm: 43e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+kill.asm: 488:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+kill.asm: 49f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+kill.asm: 4a2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+kill.asm: 4ab:	8b 55 d0             	mov    -0x30(%ebp),%edx
+kill.asm: 4ae:	8d 45 e7             	lea    -0x19(%ebp),%eax
+kill.asm: 4c0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+kill.asm: 4c8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+kill.asm: 4f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+kill.asm: 50a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+kill.asm: 518:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+kill.asm: 51b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+kill.asm: 538:	88 45 e3             	mov    %al,-0x1d(%ebp)
+kill.asm: 53b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+kill.asm: 568:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+kill.asm: 57c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+kill.asm: 590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+kill.asm: 5ab:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+kill.asm: 5b4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+kill.asm: 5c6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+kill.asm: 5c9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+kill.asm: 5d5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm: 5f0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  if(bp + bp->s.size == p->s.ptr){
+kill.asm: 610:	8b 73 fc             	mov    -0x4(%ebx),%esi
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm: 61a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm:    p->s.ptr = bp;
+kill.asm:  bp = (Header*)ap - 1;
+kill.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+kill.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+kill.asm:  if(bp + bp->s.size == p->s.ptr){
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm: 63b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm: 642:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm: 64f:	03 4b fc             	add    -0x4(%ebx),%ecx
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm:    p->s.ptr = bp;
+kill.asm:    bp->s.size += p->s.ptr->s.size;
+kill.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+kill.asm:    bp->s.ptr = p->s.ptr;
+kill.asm:  if(p + p->s.size == bp){
+kill.asm:    p->s.size += bp->s.size;
+kill.asm:    p->s.ptr = bp->s.ptr;
+kill.asm: 65a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+kill.asm:    p->s.ptr = bp;
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm: 6a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:        p->s.size = nunits;
+kill.asm: 6c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+kill.asm:  if(p == (char*)-1)
+kill.asm:  hp->s.size = nu;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:      if(p->s.size == nunits)
+kill.asm:        prevp->s.ptr = p->s.ptr;
+kill.asm:        p->s.size -= nunits;
+kill.asm:        p += p->s.size;
+kill.asm:        p->s.size = nunits;
+kill.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+kill.asm:    if(p->s.size >= nunits){
+kill.asm:      if(p->s.size == nunits)
+kill.asm:        prevp->s.ptr = p->s.ptr;
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+kill.asm:    return newThread->tid;
+kill.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+kill.asm:    return newThread->tid;
+kill.asm:    thread->state=RUNNABLE;
+kill.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+kill.asm:    thread->state=RUNNABLE;
+kill.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+kill.asm:	ttable.threads[i]->state=RUNNABLE;
+kill.asm:    thread->state=RUNNABLE;
+kill.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+kill.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+kill.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+kill.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+kill.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+kill.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+kill.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+kill.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+kill.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+kill.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+kill.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+kill.asm:  //1. store tf in the thread->btf
+kill.asm:  *thread->btf = tf;
+kill.asm:  if(nextThread->isFirstRun==1){
+kill.asm:    //move the tf that is stored in nextThread->btf to the stack
+kill.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+kill.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+kill.asm:  nextThread->state=RUNNING;
+kill.asm:  nextThread->isFirstRun=0;
+kill.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+kill.asm:  nextThread->state=RUNNING;
+kill.asm:  nextThread->isFirstRun=0;
+kill.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+kill.asm:    thread->state=RUNNABLE;
+kill.asm:  *thread->btf = tf;
+kill.asm:  if(nextThread->isFirstRun==1){
+kill.asm: 913:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+kill.asm: 91b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+kill.asm:    ntf->esp=nextThread->btf->esp;
+kill.asm:    ntf->eip=nextThread->btf->eip;
+kill.asm:      //ttable.threads[i]->utstack=0;
+kill.asm:      //ttable.threads[i]->tid=0;
+kill.asm:      //ttable.threads[i]->esp=0;
+kill.asm:      //ttable.threads[i]->ebp=0;
+kill.asm:      //ttable.threads[i]->eip=0;
+kill.asm:      ttable.threads[i]->state=EMPTY;
+kill.asm:      //ttable.threads[i]->sleepTime=0
+kill.asm:      //ttable.threads[i]->sleepInit=0;
+kill.asm:      ttable.threads[i]->isFirstRun=1;
+kill.asm:      //ttable.threads[i]->btf=0;
+kill.asm:      //ttable.threads[i]->waitingExitTid=0;
+kill.asm:    thread->tid = threadTidCounter;
+kill.asm:    thread->state = RUNNING;
+kill.asm:      //ttable.threads[i]->btf=0;
+kill.asm:      //ttable.threads[i]->waitingExitTid=0;
+kill.asm:    thread->tid = threadTidCounter;
+kill.asm:    thread->state = RUNNING;
+kill.asm:    thread->tid = threadTidCounter;
+kill.asm:    thread->state = RUNNING;
+kill.asm:        return -1;*/
+kill.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+kill.asm:      //ttable.threads[i]->btf=0;
+kill.asm:      //ttable.threads[i]->waitingExitTid=0;
+kill.asm:    thread->tid = threadTidCounter;
+kill.asm:    thread->state = RUNNING;
+kill.asm:        return -1;*/
+kill.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+kill.asm:      return -1;
+kill.asm:        return -1;*/
+kill.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+kill.asm:      return -1;
+kill.asm:    if (threadNum == MAX_UTHREADS - 1) 
+kill.asm:        return -1;
+kill.asm:      if(ttable.threads[i]->state==EMPTY){
+kill.asm:    newThread->tid = threadTidCounter;
+kill.asm:    newThread->tid = threadTidCounter;
+kill.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+kill.asm:    newThread->tid = threadTidCounter;
+kill.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+kill.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+kill.asm:    esp -= 4;
+kill.asm:    newThread->tid = threadTidCounter;
+kill.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+kill.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+kill.asm:    esp -= 4;
+kill.asm:    esp -= 4;
+kill.asm:    newThread->btf->esp=esp-3*sizeof(int);
+kill.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+kill.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+kill.asm:    esp -= 4;
+kill.asm:    esp -= 4;
+kill.asm:    newThread->btf->esp=esp-3*sizeof(int);
+kill.asm:    newThread->btf->eip=(int)start_func;
+kill.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+kill.asm:    newThread->eip=(int)start_func;//
+kill.asm:    newThread->state = RUNNABLE;
+kill.asm:    return newThread->tid;
+kill.asm:    if (threadNum == MAX_UTHREADS - 1) 
+kill.asm:        return -1;
+kill.asm:    return thread->tid;
+kill.asm:    return thread->tid;
+kill.asm:    return thread->tid;
+kill.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+kill.asm:    return thread->tid;
+kill.asm:      if(ttable.threads[i]->tid==tid){
+kill.asm:      return -1; 
+kill.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+kill.asm:      return -1; 
+kill.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+kill.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+kill.asm:    thread->waitingExitTid=tid;
+kill.asm:    thread->state=BLOCKED;
+kill.asm:      return -1; 
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:	return -1;
+kill.asm:    thread->state=BLOCKED;
+kill.asm:    thread->sleepInit=uptime();
+kill.asm:    thread->sleepTime=ticks;
+kill.asm:	return -1;
+kill.asm:    thread->state=BLOCKED;
+kill.asm:    thread->sleepInit=uptime();
+kill.asm:    thread->sleepTime=ticks;
+kill.asm:	return -1;
+kill.asm:    free(th->utstack);
+kill.asm:    th->tid=0;
+kill.asm:    th->esp=0;
+kill.asm:    th->ebp=0;
+kill.asm:    th->eip=0;
+kill.asm:    th->state=EMPTY;
+kill.asm:    th->sleepTime=0;
+kill.asm:    th->sleepInit=0;
+kill.asm:    th->isFirstRun=1;
+kill.asm:    th->btf=0;
+kill.asm:    th->waitingExitTid=0;
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:    th->isFirstRun=1;
+kill.asm:    th->btf=0;
+kill.asm:    th->waitingExitTid=0;
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+kill.asm:      if(ttable.threads[i]->state==RUNNABLE){
+kill.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+kill.asm:	ttable.threads[i]->state=RUNNABLE;
+kill.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+kill.asm:	ttable.threads[i]->state=RUNNABLE;
+kill.asm:    threadsCounter--;
+kill.asm:    threadsCounter--;
+kill.d:kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file kill.o matches
+lapic.c:// The local APIC manages internal (non-I/O) interrupts.
+lapic.c:  // Clear error status register (requires back-to-back writes).
+lapic.c:  // Send an Init Level De-Assert to synchronise arbitration ID's.
+lapic.c:  // Send INIT (level-triggered) interrupt to reset other CPU.
+lapic.c:  r->second = cmos_read(SECS);
+lapic.c:  r->minute = cmos_read(MINS);
+lapic.c:  r->hour   = cmos_read(HOURS);
+lapic.c:  r->day    = cmos_read(DAY);
+lapic.c:  r->month  = cmos_read(MONTH);
+lapic.c:  r->year   = cmos_read(YEAR);
+lapic.c:// qemu seems to use 24-hour GWT and the values are BCD encoded
+lapic.c:  r->year += 2000;
+lapic.d:lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h \
+Binary file lapic.o matches
+LICENSE:Copyright (c) 2006-2016 Frans Kaashoek, Robert Morris, Russ Cox,
+Binary file _ln matches
+ln.asm:_ln:     file format elf32-i386
+ln.asm:  83:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+ln.asm:  8c:	88 5a ff             	mov    %bl,-0x1(%edx)
+ln.asm:  return (uchar)*p - (uchar)*q;
+ln.asm:  return (uchar)*p - (uchar)*q;
+ln.asm: 18b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+ln.asm: 1ac:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ln.asm: 1b7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+ln.asm:    return -1;
+ln.asm:    return -1;
+ln.asm:    return -1;
+ln.asm: 23a:	8d 42 d0             	lea    -0x30(%edx),%eax
+ln.asm:    n = n*10 + *s++ - '0';
+ln.asm: 24e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+ln.asm: 255:	8d 5a d0             	lea    -0x30(%edx),%ebx
+ln.asm:    n = n*10 + *s++ - '0';
+ln.asm:  while(n-- > 0)
+ln.asm:  while(n-- > 0)
+ln.asm:  while(n-- > 0)
+ln.asm:    x = -xx;
+ln.asm: 37d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+ln.asm: 384:	89 75 c0             	mov    %esi,-0x40(%ebp)
+ln.asm:    x = -xx;
+ln.asm: 38b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+ln.asm: 3a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ln.asm: 3ac:	8b 75 c0             	mov    -0x40(%ebp),%esi
+ln.asm:    buf[i++] = '-';
+ln.asm: 3b6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+ln.asm:  while(--i >= 0)
+ln.asm: 3bb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+ln.asm: 3c0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+ln.asm: 3d7:	88 45 d7             	mov    %al,-0x29(%ebp)
+ln.asm:    buf[i++] = '-';
+ln.asm:  while(--i >= 0)
+ln.asm:    x = -xx;
+ln.asm: 3f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+ln.asm: 414:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+ln.asm: 431:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+ln.asm: 443:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+ln.asm: 44e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ln.asm: 498:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+ln.asm: 4af:	89 55 d0             	mov    %edx,-0x30(%ebp)
+ln.asm: 4b2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+ln.asm: 4bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+ln.asm: 4be:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ln.asm: 4d0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+ln.asm: 4d8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ln.asm: 500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ln.asm: 51a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ln.asm: 528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ln.asm: 52b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ln.asm: 548:	88 45 e3             	mov    %al,-0x1d(%ebp)
+ln.asm: 54b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+ln.asm: 578:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+ln.asm: 58c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+ln.asm: 5a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ln.asm: 5bb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ln.asm: 5c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ln.asm: 5d6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+ln.asm: 5d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+ln.asm: 5e5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm: 600:	8d 53 f8             	lea    -0x8(%ebx),%edx
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  if(bp + bp->s.size == p->s.ptr){
+ln.asm: 620:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm: 62a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm:    p->s.ptr = bp;
+ln.asm:  bp = (Header*)ap - 1;
+ln.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ln.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ln.asm:  if(bp + bp->s.size == p->s.ptr){
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm: 64b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm: 652:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm: 65f:	03 4b fc             	add    -0x4(%ebx),%ecx
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm:    p->s.ptr = bp;
+ln.asm:    bp->s.size += p->s.ptr->s.size;
+ln.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ln.asm:    bp->s.ptr = p->s.ptr;
+ln.asm:  if(p + p->s.size == bp){
+ln.asm:    p->s.size += bp->s.size;
+ln.asm:    p->s.ptr = bp->s.ptr;
+ln.asm: 66a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ln.asm:    p->s.ptr = bp;
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm: 6b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:        p->s.size = nunits;
+ln.asm: 6d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ln.asm:  if(p == (char*)-1)
+ln.asm:  hp->s.size = nu;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:      if(p->s.size == nunits)
+ln.asm:        prevp->s.ptr = p->s.ptr;
+ln.asm:        p->s.size -= nunits;
+ln.asm:        p += p->s.size;
+ln.asm:        p->s.size = nunits;
+ln.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ln.asm:    if(p->s.size >= nunits){
+ln.asm:      if(p->s.size == nunits)
+ln.asm:        prevp->s.ptr = p->s.ptr;
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ln.asm:    return newThread->tid;
+ln.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ln.asm:    return newThread->tid;
+ln.asm:    thread->state=RUNNABLE;
+ln.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ln.asm:    thread->state=RUNNABLE;
+ln.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ln.asm:	ttable.threads[i]->state=RUNNABLE;
+ln.asm:    thread->state=RUNNABLE;
+ln.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ln.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ln.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ln.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ln.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ln.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ln.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ln.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ln.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ln.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+ln.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+ln.asm:  //1. store tf in the thread->btf
+ln.asm:  *thread->btf = tf;
+ln.asm:  if(nextThread->isFirstRun==1){
+ln.asm:    //move the tf that is stored in nextThread->btf to the stack
+ln.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+ln.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ln.asm:  nextThread->state=RUNNING;
+ln.asm:  nextThread->isFirstRun=0;
+ln.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ln.asm:  nextThread->state=RUNNING;
+ln.asm:  nextThread->isFirstRun=0;
+ln.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ln.asm:    thread->state=RUNNABLE;
+ln.asm:  *thread->btf = tf;
+ln.asm:  if(nextThread->isFirstRun==1){
+ln.asm: 923:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+ln.asm: 92b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+ln.asm:    ntf->esp=nextThread->btf->esp;
+ln.asm:    ntf->eip=nextThread->btf->eip;
+ln.asm:      //ttable.threads[i]->utstack=0;
+ln.asm:      //ttable.threads[i]->tid=0;
+ln.asm:      //ttable.threads[i]->esp=0;
+ln.asm:      //ttable.threads[i]->ebp=0;
+ln.asm:      //ttable.threads[i]->eip=0;
+ln.asm:      ttable.threads[i]->state=EMPTY;
+ln.asm:      //ttable.threads[i]->sleepTime=0
+ln.asm:      //ttable.threads[i]->sleepInit=0;
+ln.asm:      ttable.threads[i]->isFirstRun=1;
+ln.asm:      //ttable.threads[i]->btf=0;
+ln.asm:      //ttable.threads[i]->waitingExitTid=0;
+ln.asm:    thread->tid = threadTidCounter;
+ln.asm:    thread->state = RUNNING;
+ln.asm:      //ttable.threads[i]->btf=0;
+ln.asm:      //ttable.threads[i]->waitingExitTid=0;
+ln.asm:    thread->tid = threadTidCounter;
+ln.asm:    thread->state = RUNNING;
+ln.asm:    thread->tid = threadTidCounter;
+ln.asm:    thread->state = RUNNING;
+ln.asm:        return -1;*/
+ln.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ln.asm:      //ttable.threads[i]->btf=0;
+ln.asm:      //ttable.threads[i]->waitingExitTid=0;
+ln.asm:    thread->tid = threadTidCounter;
+ln.asm:    thread->state = RUNNING;
+ln.asm:        return -1;*/
+ln.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ln.asm:      return -1;
+ln.asm:        return -1;*/
+ln.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ln.asm:      return -1;
+ln.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ln.asm:        return -1;
+ln.asm:      if(ttable.threads[i]->state==EMPTY){
+ln.asm:    newThread->tid = threadTidCounter;
+ln.asm:    newThread->tid = threadTidCounter;
+ln.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ln.asm:    newThread->tid = threadTidCounter;
+ln.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ln.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ln.asm:    esp -= 4;
+ln.asm:    newThread->tid = threadTidCounter;
+ln.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ln.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ln.asm:    esp -= 4;
+ln.asm:    esp -= 4;
+ln.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ln.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ln.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ln.asm:    esp -= 4;
+ln.asm:    esp -= 4;
+ln.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ln.asm:    newThread->btf->eip=(int)start_func;
+ln.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+ln.asm:    newThread->eip=(int)start_func;//
+ln.asm:    newThread->state = RUNNABLE;
+ln.asm:    return newThread->tid;
+ln.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ln.asm:        return -1;
+ln.asm:    return thread->tid;
+ln.asm:    return thread->tid;
+ln.asm:    return thread->tid;
+ln.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+ln.asm:    return thread->tid;
+ln.asm:      if(ttable.threads[i]->tid==tid){
+ln.asm:      return -1; 
+ln.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ln.asm:      return -1; 
+ln.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ln.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ln.asm:    thread->waitingExitTid=tid;
+ln.asm:    thread->state=BLOCKED;
+ln.asm:      return -1; 
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:	return -1;
+ln.asm:    thread->state=BLOCKED;
+ln.asm:    thread->sleepInit=uptime();
+ln.asm:    thread->sleepTime=ticks;
+ln.asm:	return -1;
+ln.asm:    thread->state=BLOCKED;
+ln.asm:    thread->sleepInit=uptime();
+ln.asm:    thread->sleepTime=ticks;
+ln.asm:	return -1;
+ln.asm:    free(th->utstack);
+ln.asm:    th->tid=0;
+ln.asm:    th->esp=0;
+ln.asm:    th->ebp=0;
+ln.asm:    th->eip=0;
+ln.asm:    th->state=EMPTY;
+ln.asm:    th->sleepTime=0;
+ln.asm:    th->sleepInit=0;
+ln.asm:    th->isFirstRun=1;
+ln.asm:    th->btf=0;
+ln.asm:    th->waitingExitTid=0;
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:    th->isFirstRun=1;
+ln.asm:    th->btf=0;
+ln.asm:    th->waitingExitTid=0;
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ln.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ln.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ln.asm:	ttable.threads[i]->state=RUNNABLE;
+ln.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ln.asm:	ttable.threads[i]->state=RUNNABLE;
+ln.asm:    threadsCounter--;
+ln.asm:    threadsCounter--;
+ln.d:ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file ln.o matches
+log.c:// the count of in-progress FS system calls and returns.
+log.c:// The log is a physical re-do log containing disk blocks.
+log.c:// The on-disk log format:
+log.c:// Contents of the header block, used for both the on-disk header block
+log.c:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+log.c:// Read the log header from disk into the in-memory log header
+log.c:  struct logheader *lh = (struct logheader *) (buf->data);
+log.c:  log.lh.n = lh->n;
+log.c:    log.lh.block[i] = lh->block[i];
+log.c:// Write in-memory log header to disk.
+log.c:  struct logheader *hb = (struct logheader *) (buf->data);
+log.c:  hb->n = log.lh.n;
+log.c:    hb->block[i] = log.lh.block[i];
+log.c:  log.outstanding -= 1;
+log.c:    memmove(to->data, from->data, BSIZE);
+log.c:    write_head();    // Write header to disk -- the real commit
+log.c:// Caller has modified b->data and is done with the buffer.
+log.c://   modify bp->data[]
+log.c:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+log.c:    if (log.lh.block[i] == b->blockno)   // log absorbtion
+log.c:  log.lh.block[i] = b->blockno;
+log.c:  b->flags |= B_DIRTY; // prevent eviction
+log.d:log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+Binary file log.o matches
+Binary file _ls matches
+ls.asm:_ls:     file format elf32-i386
+ls.asm:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+ls.asm:  // Return blank-padded name.
+ls.asm:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+ls.asm:  // Return blank-padded name.
+ls.asm:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+ls.asm:     119:	8d b5 d4 fd ff ff    	lea    -0x22c(%ebp),%esi
+ls.asm:     133:	0f b7 85 d4 fd ff ff 	movzwl -0x22c(%ebp),%eax
+ls.asm:     146:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
+ls.asm:     14f:	8b b5 dc fd ff ff    	mov    -0x224(%ebp),%esi
+ls.asm:     155:	89 95 b4 fd ff ff    	mov    %edx,-0x24c(%ebp)
+ls.asm:     160:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
+ls.asm:     1be:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+ls.asm:     1c8:	8d bd c4 fd ff ff    	lea    -0x23c(%ebp),%edi
+ls.asm:     1d6:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+ls.asm:     1e4:	8d 8d e8 fd ff ff    	lea    -0x218(%ebp),%ecx
+ls.asm:     1ef:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
+ls.asm:     1f5:	89 8d a4 fd ff ff    	mov    %ecx,-0x25c(%ebp)
+ls.asm:     21d:	66 83 bd c4 fd ff ff 	cmpw   $0x0,-0x23c(%ebp)
+ls.asm:     227:	8d 85 c6 fd ff ff    	lea    -0x23a(%ebp),%eax
+ls.asm:     231:	8b 85 a4 fd ff ff    	mov    -0x25c(%ebp),%eax
+ls.asm:     247:	8b 85 a8 fd ff ff    	mov    -0x258(%ebp),%eax
+ls.asm:     251:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+ls.asm:     26b:	0f bf 95 d4 fd ff ff 	movswl -0x22c(%ebp),%edx
+ls.asm:     272:	8b 8d e4 fd ff ff    	mov    -0x21c(%ebp),%ecx
+ls.asm:     278:	8b 85 dc fd ff ff    	mov    -0x224(%ebp),%eax
+ls.asm:     27e:	89 95 b0 fd ff ff    	mov    %edx,-0x250(%ebp)
+ls.asm:     284:	8d 95 e8 fd ff ff    	lea    -0x218(%ebp),%edx
+ls.asm:     28d:	89 8d ac fd ff ff    	mov    %ecx,-0x254(%ebp)
+ls.asm:     293:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
+ls.asm:     29e:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
+ls.asm:     2a4:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
+ls.asm:     2bd:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
+ls.asm:     350:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
+ls.asm:     393:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+ls.asm:     39c:	88 5a ff             	mov    %bl,-0x1(%edx)
+ls.asm:  return (uchar)*p - (uchar)*q;
+ls.asm:  return (uchar)*p - (uchar)*q;
+ls.asm:     49b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+ls.asm:     4bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ls.asm:     4c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+ls.asm:    return -1;
+ls.asm:    return -1;
+ls.asm:    return -1;
+ls.asm:     54a:	8d 42 d0             	lea    -0x30(%edx),%eax
+ls.asm:    n = n*10 + *s++ - '0';
+ls.asm:     55e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+ls.asm:     565:	8d 5a d0             	lea    -0x30(%edx),%ebx
+ls.asm:    n = n*10 + *s++ - '0';
+ls.asm:  while(n-- > 0)
+ls.asm:  while(n-- > 0)
+ls.asm:  while(n-- > 0)
+ls.asm:    x = -xx;
+ls.asm:     68d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+ls.asm:     694:	89 75 c0             	mov    %esi,-0x40(%ebp)
+ls.asm:    x = -xx;
+ls.asm:     69b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+ls.asm:     6b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ls.asm:     6bc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+ls.asm:    buf[i++] = '-';
+ls.asm:     6c6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+ls.asm:  while(--i >= 0)
+ls.asm:     6cb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+ls.asm:     6d0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+ls.asm:     6e7:	88 45 d7             	mov    %al,-0x29(%ebp)
+ls.asm:    buf[i++] = '-';
+ls.asm:  while(--i >= 0)
+ls.asm:    x = -xx;
+ls.asm:     704:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+ls.asm:     724:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+ls.asm:     741:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+ls.asm:     753:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+ls.asm:     75e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ls.asm:     7a8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+ls.asm:     7bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+ls.asm:     7c2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+ls.asm:     7cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+ls.asm:     7ce:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ls.asm:     7e0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+ls.asm:     7e8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+ls.asm:     810:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ls.asm:     82a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ls.asm:     838:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ls.asm:     83b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ls.asm:     858:	88 45 e3             	mov    %al,-0x1d(%ebp)
+ls.asm:     85b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+ls.asm:     888:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+ls.asm:     89c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+ls.asm:     8b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ls.asm:     8cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ls.asm:     8d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ls.asm:     8e6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+ls.asm:     8e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+ls.asm:     8f5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:     910:	8d 53 f8             	lea    -0x8(%ebx),%edx
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  if(bp + bp->s.size == p->s.ptr){
+ls.asm:     930:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:     93a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:    p->s.ptr = bp;
+ls.asm:  bp = (Header*)ap - 1;
+ls.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ls.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ls.asm:  if(bp + bp->s.size == p->s.ptr){
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:     95b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:     962:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:     96f:	03 4b fc             	add    -0x4(%ebx),%ecx
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:    p->s.ptr = bp;
+ls.asm:    bp->s.size += p->s.ptr->s.size;
+ls.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+ls.asm:    bp->s.ptr = p->s.ptr;
+ls.asm:  if(p + p->s.size == bp){
+ls.asm:    p->s.size += bp->s.size;
+ls.asm:    p->s.ptr = bp->s.ptr;
+ls.asm:     97a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ls.asm:    p->s.ptr = bp;
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:     9c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:        p->s.size = nunits;
+ls.asm:     9e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ls.asm:  if(p == (char*)-1)
+ls.asm:  hp->s.size = nu;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:      if(p->s.size == nunits)
+ls.asm:        prevp->s.ptr = p->s.ptr;
+ls.asm:        p->s.size -= nunits;
+ls.asm:        p += p->s.size;
+ls.asm:        p->s.size = nunits;
+ls.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ls.asm:    if(p->s.size >= nunits){
+ls.asm:      if(p->s.size == nunits)
+ls.asm:        prevp->s.ptr = p->s.ptr;
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ls.asm:    return newThread->tid;
+ls.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ls.asm:    return newThread->tid;
+ls.asm:    thread->state=RUNNABLE;
+ls.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ls.asm:    thread->state=RUNNABLE;
+ls.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+ls.asm:	ttable.threads[i]->state=RUNNABLE;
+ls.asm:    thread->state=RUNNABLE;
+ls.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ls.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ls.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ls.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ls.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ls.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+ls.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+ls.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ls.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+ls.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+ls.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+ls.asm:  //1. store tf in the thread->btf
+ls.asm:  *thread->btf = tf;
+ls.asm:  if(nextThread->isFirstRun==1){
+ls.asm:    //move the tf that is stored in nextThread->btf to the stack
+ls.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+ls.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ls.asm:  nextThread->state=RUNNING;
+ls.asm:  nextThread->isFirstRun=0;
+ls.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+ls.asm:  nextThread->state=RUNNING;
+ls.asm:  nextThread->isFirstRun=0;
+ls.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+ls.asm:    thread->state=RUNNABLE;
+ls.asm:  *thread->btf = tf;
+ls.asm:  if(nextThread->isFirstRun==1){
+ls.asm:     c33:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+ls.asm:     c3b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+ls.asm:    ntf->esp=nextThread->btf->esp;
+ls.asm:    ntf->eip=nextThread->btf->eip;
+ls.asm:      //ttable.threads[i]->utstack=0;
+ls.asm:      //ttable.threads[i]->tid=0;
+ls.asm:      //ttable.threads[i]->esp=0;
+ls.asm:      //ttable.threads[i]->ebp=0;
+ls.asm:      //ttable.threads[i]->eip=0;
+ls.asm:      ttable.threads[i]->state=EMPTY;
+ls.asm:      //ttable.threads[i]->sleepTime=0
+ls.asm:      //ttable.threads[i]->sleepInit=0;
+ls.asm:      ttable.threads[i]->isFirstRun=1;
+ls.asm:      //ttable.threads[i]->btf=0;
+ls.asm:      //ttable.threads[i]->waitingExitTid=0;
+ls.asm:    thread->tid = threadTidCounter;
+ls.asm:    thread->state = RUNNING;
+ls.asm:      //ttable.threads[i]->btf=0;
+ls.asm:      //ttable.threads[i]->waitingExitTid=0;
+ls.asm:    thread->tid = threadTidCounter;
+ls.asm:    thread->state = RUNNING;
+ls.asm:    thread->tid = threadTidCounter;
+ls.asm:    thread->state = RUNNING;
+ls.asm:        return -1;*/
+ls.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ls.asm:      //ttable.threads[i]->btf=0;
+ls.asm:      //ttable.threads[i]->waitingExitTid=0;
+ls.asm:    thread->tid = threadTidCounter;
+ls.asm:    thread->state = RUNNING;
+ls.asm:        return -1;*/
+ls.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ls.asm:      return -1;
+ls.asm:        return -1;*/
+ls.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+ls.asm:      return -1;
+ls.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ls.asm:        return -1;
+ls.asm:      if(ttable.threads[i]->state==EMPTY){
+ls.asm:    newThread->tid = threadTidCounter;
+ls.asm:    newThread->tid = threadTidCounter;
+ls.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ls.asm:    newThread->tid = threadTidCounter;
+ls.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ls.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ls.asm:    esp -= 4;
+ls.asm:    newThread->tid = threadTidCounter;
+ls.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ls.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ls.asm:    esp -= 4;
+ls.asm:    esp -= 4;
+ls.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ls.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+ls.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+ls.asm:    esp -= 4;
+ls.asm:    esp -= 4;
+ls.asm:    newThread->btf->esp=esp-3*sizeof(int);
+ls.asm:    newThread->btf->eip=(int)start_func;
+ls.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+ls.asm:    newThread->eip=(int)start_func;//
+ls.asm:    newThread->state = RUNNABLE;
+ls.asm:    return newThread->tid;
+ls.asm:    if (threadNum == MAX_UTHREADS - 1) 
+ls.asm:        return -1;
+ls.asm:    return thread->tid;
+ls.asm:    return thread->tid;
+ls.asm:    return thread->tid;
+ls.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+ls.asm:    return thread->tid;
+ls.asm:      if(ttable.threads[i]->tid==tid){
+ls.asm:      return -1; 
+ls.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ls.asm:      return -1; 
+ls.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ls.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+ls.asm:    thread->waitingExitTid=tid;
+ls.asm:    thread->state=BLOCKED;
+ls.asm:      return -1; 
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:	return -1;
+ls.asm:    thread->state=BLOCKED;
+ls.asm:    thread->sleepInit=uptime();
+ls.asm:    thread->sleepTime=ticks;
+ls.asm:	return -1;
+ls.asm:    thread->state=BLOCKED;
+ls.asm:    thread->sleepInit=uptime();
+ls.asm:    thread->sleepTime=ticks;
+ls.asm:	return -1;
+ls.asm:    free(th->utstack);
+ls.asm:    th->tid=0;
+ls.asm:    th->esp=0;
+ls.asm:    th->ebp=0;
+ls.asm:    th->eip=0;
+ls.asm:    th->state=EMPTY;
+ls.asm:    th->sleepTime=0;
+ls.asm:    th->sleepInit=0;
+ls.asm:    th->isFirstRun=1;
+ls.asm:    th->btf=0;
+ls.asm:    th->waitingExitTid=0;
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:    th->isFirstRun=1;
+ls.asm:    th->btf=0;
+ls.asm:    th->waitingExitTid=0;
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ls.asm:      if(ttable.threads[i]->state==RUNNABLE){
+ls.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ls.asm:	ttable.threads[i]->state=RUNNABLE;
+ls.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+ls.asm:	ttable.threads[i]->state=RUNNABLE;
+ls.asm:    threadsCounter--;
+ls.asm:    threadsCounter--;
+ls.c:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+ls.c:  // Return blank-padded name.
+ls.c:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+ls.d:ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
+Binary file ls.o matches
+main.c:  xchg(&cpu->started, 1); // tell startothers() we're up
+main.c:// Start the non-boot (AP) processors.
+main.c:    *(void**)(code-4) = stack + KSTACKSIZE;
+main.c:    *(void**)(code-8) = mpenter;
+main.c:    *(int**)(code-12) = (void *) V2P(entrypgdir);
+main.c:    lapicstartap(c->apicid, V2P(code));
+main.c:    while(c->started == 0)
+main.d:main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file main.o matches
+Makefile:# Cross-compiling (e.g., on Mac OS X)
+Makefile:# TOOLPREFIX = i386-jos-elf
+Makefile:TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+Makefile:	then echo 'i386-jos-elf-'; \
+Makefile:	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+Makefile:	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+Makefile:	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+Makefile:	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+Makefile:	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+Makefile:# QEMU = qemu-system-i386
+Makefile:	elif which qemu-system-i386 > /dev/null; \
+Makefile:	then echo qemu-system-i386; exit; \
+Makefile:	elif which qemu-system-x86_64 > /dev/null; \
+Makefile:	then echo qemu-system-x86_64; exit; \
+Makefile:	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+Makefile:	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+Makefile:CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+Makefile:#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+Makefile:CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+Makefile:ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+Makefile:LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+Makefile:	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+Makefile:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+Makefile:	$(OBJDUMP) -S bootblock.o > bootblock.asm
+Makefile:	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+Makefile:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+Makefile:	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+Makefile:	$(OBJDUMP) -S bootblockother.o > entryother.asm
+Makefile:	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+Makefile:	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+Makefile:	$(OBJCOPY) -S -O binary initcode.out initcode
+Makefile:	$(OBJDUMP) -S initcode.o > initcode.asm
+Makefile:	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+Makefile:	$(OBJDUMP) -S kernel > kernel.asm
+Makefile:	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+Makefile:MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+Makefile:	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+Makefile:	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+Makefile:	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+Makefile:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+Makefile:	$(OBJDUMP) -S $@ > $*.asm
+Makefile:	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+Makefile:	# forktest has less library code linked in - needs to be small
+Makefile:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+Makefile:	$(OBJDUMP) -S _forktest > forktest.asm
+Makefile:	gcc -Werror -Wall -o mkfs mkfs.c
+Makefile:# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+Makefile:-include *.d
+Makefile:	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+Makefile:FILES = $(shell grep -v '^\#' runoff.list)
+Makefile:	ls -l xv6.pdf
+Makefile:	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+Makefile:	bochs -q
+Makefile:GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+Makefile:QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+Makefile:	then echo "-gdb tcp::$(GDBPORT)"; \
+Makefile:	else echo "-s -p $(GDBPORT)"; fi)
+Makefile:QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+Makefile:	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+Makefile:qemu-memfs: xv6memfs.img
+Makefile:	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+Makefile:qemu-nox: fs.img xv6.img
+Makefile:	$(QEMU) -nographic $(QEMUOPTS)
+Makefile:qemu-gdb: fs.img xv6.img .gdbinit
+Makefile:	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+Makefile:qemu-nox-gdb: fs.img xv6.img .gdbinit
+Makefile:	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+Makefile:	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+Makefile:	rm -rf dist
+Makefile:		grep -v PAGEBREAK $$i >dist/$$i; \
+Makefile:dist-test:
+Makefile:	rm -rf dist
+Makefile:	rm -rf dist-test
+Makefile:	mkdir dist-test
+Makefile:	cp dist/* dist-test
+Makefile:	cd dist-test; $(MAKE) print
+Makefile:	cd dist-test; $(MAKE) bochs || true
+Makefile:	cd dist-test; $(MAKE) qemu
+Makefile:	rm -rf /tmp/xv6
+Makefile:	mkdir -p /tmp/xv6
+Makefile:	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+Makefile:.PHONY: dist-test dist
+memide.c:  // no-op
+memide.c:  if(!holdingsleep(&b->lock))
+memide.c:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+memide.c:  if(b->dev != 1)
+memide.c:  if(b->blockno >= disksize)
+memide.c:  p = memdisk + b->blockno*BSIZE;
+memide.c:  if(b->flags & B_DIRTY){
+memide.c:    b->flags &= ~B_DIRTY;
+memide.c:    memmove(p, b->data, BSIZE);
+memide.c:    memmove(b->data, p, BSIZE);
+memide.c:  b->flags |= B_VALID;
+memlayout.h:#define V2P(a) (((uint) (a)) - KERNBASE)
+memlayout.h:#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+Binary file _mkdir matches
+mkdir.asm:_mkdir:     file format elf32-i386
+mkdir.asm:  93:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+mkdir.asm:  9c:	88 5a ff             	mov    %bl,-0x1(%edx)
+mkdir.asm:  return (uchar)*p - (uchar)*q;
+mkdir.asm:  return (uchar)*p - (uchar)*q;
+mkdir.asm: 19b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+mkdir.asm: 1bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+mkdir.asm: 1c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+mkdir.asm:    return -1;
+mkdir.asm:    return -1;
+mkdir.asm:    return -1;
+mkdir.asm: 24a:	8d 42 d0             	lea    -0x30(%edx),%eax
+mkdir.asm:    n = n*10 + *s++ - '0';
+mkdir.asm: 25e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+mkdir.asm: 265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+mkdir.asm:    n = n*10 + *s++ - '0';
+mkdir.asm:  while(n-- > 0)
+mkdir.asm:  while(n-- > 0)
+mkdir.asm:  while(n-- > 0)
+mkdir.asm:    x = -xx;
+mkdir.asm: 38d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+mkdir.asm: 394:	89 75 c0             	mov    %esi,-0x40(%ebp)
+mkdir.asm:    x = -xx;
+mkdir.asm: 39b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+mkdir.asm: 3b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+mkdir.asm: 3bc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+mkdir.asm:    buf[i++] = '-';
+mkdir.asm: 3c6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+mkdir.asm:  while(--i >= 0)
+mkdir.asm: 3cb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+mkdir.asm: 3d0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+mkdir.asm: 3e7:	88 45 d7             	mov    %al,-0x29(%ebp)
+mkdir.asm:    buf[i++] = '-';
+mkdir.asm:  while(--i >= 0)
+mkdir.asm:    x = -xx;
+mkdir.asm: 404:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+mkdir.asm: 424:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+mkdir.asm: 441:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+mkdir.asm: 453:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+mkdir.asm: 45e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+mkdir.asm: 4a8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+mkdir.asm: 4bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+mkdir.asm: 4c2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+mkdir.asm: 4cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+mkdir.asm: 4ce:	8d 45 e7             	lea    -0x19(%ebp),%eax
+mkdir.asm: 4e0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+mkdir.asm: 4e8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+mkdir.asm: 510:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+mkdir.asm: 52a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+mkdir.asm: 538:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+mkdir.asm: 53b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+mkdir.asm: 558:	88 45 e3             	mov    %al,-0x1d(%ebp)
+mkdir.asm: 55b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+mkdir.asm: 588:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+mkdir.asm: 59c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+mkdir.asm: 5b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+mkdir.asm: 5cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+mkdir.asm: 5d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+mkdir.asm: 5e6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+mkdir.asm: 5e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+mkdir.asm: 5f5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm: 610:	8d 53 f8             	lea    -0x8(%ebx),%edx
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+mkdir.asm: 630:	8b 73 fc             	mov    -0x4(%ebx),%esi
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm: 63a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:  bp = (Header*)ap - 1;
+mkdir.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+mkdir.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+mkdir.asm:  if(bp + bp->s.size == p->s.ptr){
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm: 65b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm: 662:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm: 66f:	03 4b fc             	add    -0x4(%ebx),%ecx
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:    bp->s.size += p->s.ptr->s.size;
+mkdir.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+mkdir.asm:    bp->s.ptr = p->s.ptr;
+mkdir.asm:  if(p + p->s.size == bp){
+mkdir.asm:    p->s.size += bp->s.size;
+mkdir.asm:    p->s.ptr = bp->s.ptr;
+mkdir.asm: 67a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+mkdir.asm:    p->s.ptr = bp;
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm: 6c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:        p->s.size = nunits;
+mkdir.asm: 6e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+mkdir.asm:  if(p == (char*)-1)
+mkdir.asm:  hp->s.size = nu;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:      if(p->s.size == nunits)
+mkdir.asm:        prevp->s.ptr = p->s.ptr;
+mkdir.asm:        p->s.size -= nunits;
+mkdir.asm:        p += p->s.size;
+mkdir.asm:        p->s.size = nunits;
+mkdir.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+mkdir.asm:    if(p->s.size >= nunits){
+mkdir.asm:      if(p->s.size == nunits)
+mkdir.asm:        prevp->s.ptr = p->s.ptr;
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+mkdir.asm:    return newThread->tid;
+mkdir.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+mkdir.asm:    return newThread->tid;
+mkdir.asm:    thread->state=RUNNABLE;
+mkdir.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+mkdir.asm:    thread->state=RUNNABLE;
+mkdir.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+mkdir.asm:	ttable.threads[i]->state=RUNNABLE;
+mkdir.asm:    thread->state=RUNNABLE;
+mkdir.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+mkdir.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+mkdir.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+mkdir.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+mkdir.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+mkdir.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+mkdir.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+mkdir.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+mkdir.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+mkdir.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+mkdir.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+mkdir.asm:  //1. store tf in the thread->btf
+mkdir.asm:  *thread->btf = tf;
+mkdir.asm:  if(nextThread->isFirstRun==1){
+mkdir.asm:    //move the tf that is stored in nextThread->btf to the stack
+mkdir.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+mkdir.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+mkdir.asm:  nextThread->state=RUNNING;
+mkdir.asm:  nextThread->isFirstRun=0;
+mkdir.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+mkdir.asm:  nextThread->state=RUNNING;
+mkdir.asm:  nextThread->isFirstRun=0;
+mkdir.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+mkdir.asm:    thread->state=RUNNABLE;
+mkdir.asm:  *thread->btf = tf;
+mkdir.asm:  if(nextThread->isFirstRun==1){
+mkdir.asm: 933:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+mkdir.asm: 93b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+mkdir.asm:    ntf->esp=nextThread->btf->esp;
+mkdir.asm:    ntf->eip=nextThread->btf->eip;
+mkdir.asm:      //ttable.threads[i]->utstack=0;
+mkdir.asm:      //ttable.threads[i]->tid=0;
+mkdir.asm:      //ttable.threads[i]->esp=0;
+mkdir.asm:      //ttable.threads[i]->ebp=0;
+mkdir.asm:      //ttable.threads[i]->eip=0;
+mkdir.asm:      ttable.threads[i]->state=EMPTY;
+mkdir.asm:      //ttable.threads[i]->sleepTime=0
+mkdir.asm:      //ttable.threads[i]->sleepInit=0;
+mkdir.asm:      ttable.threads[i]->isFirstRun=1;
+mkdir.asm:      //ttable.threads[i]->btf=0;
+mkdir.asm:      //ttable.threads[i]->waitingExitTid=0;
+mkdir.asm:    thread->tid = threadTidCounter;
+mkdir.asm:    thread->state = RUNNING;
+mkdir.asm:      //ttable.threads[i]->btf=0;
+mkdir.asm:      //ttable.threads[i]->waitingExitTid=0;
+mkdir.asm:    thread->tid = threadTidCounter;
+mkdir.asm:    thread->state = RUNNING;
+mkdir.asm:    thread->tid = threadTidCounter;
+mkdir.asm:    thread->state = RUNNING;
+mkdir.asm:        return -1;*/
+mkdir.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+mkdir.asm:      //ttable.threads[i]->btf=0;
+mkdir.asm:      //ttable.threads[i]->waitingExitTid=0;
+mkdir.asm:    thread->tid = threadTidCounter;
+mkdir.asm:    thread->state = RUNNING;
+mkdir.asm:        return -1;*/
+mkdir.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+mkdir.asm:      return -1;
+mkdir.asm:        return -1;*/
+mkdir.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+mkdir.asm:      return -1;
+mkdir.asm:    if (threadNum == MAX_UTHREADS - 1) 
+mkdir.asm:        return -1;
+mkdir.asm:      if(ttable.threads[i]->state==EMPTY){
+mkdir.asm:    newThread->tid = threadTidCounter;
+mkdir.asm:    newThread->tid = threadTidCounter;
+mkdir.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+mkdir.asm:    newThread->tid = threadTidCounter;
+mkdir.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+mkdir.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+mkdir.asm:    esp -= 4;
+mkdir.asm:    newThread->tid = threadTidCounter;
+mkdir.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+mkdir.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+mkdir.asm:    esp -= 4;
+mkdir.asm:    esp -= 4;
+mkdir.asm:    newThread->btf->esp=esp-3*sizeof(int);
+mkdir.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+mkdir.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+mkdir.asm:    esp -= 4;
+mkdir.asm:    esp -= 4;
+mkdir.asm:    newThread->btf->esp=esp-3*sizeof(int);
+mkdir.asm:    newThread->btf->eip=(int)start_func;
+mkdir.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+mkdir.asm:    newThread->eip=(int)start_func;//
+mkdir.asm:    newThread->state = RUNNABLE;
+mkdir.asm:    return newThread->tid;
+mkdir.asm:    if (threadNum == MAX_UTHREADS - 1) 
+mkdir.asm:        return -1;
+mkdir.asm:    return thread->tid;
+mkdir.asm:    return thread->tid;
+mkdir.asm:    return thread->tid;
+mkdir.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+mkdir.asm:    return thread->tid;
+mkdir.asm:      if(ttable.threads[i]->tid==tid){
+mkdir.asm:      return -1; 
+mkdir.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+mkdir.asm:      return -1; 
+mkdir.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+mkdir.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+mkdir.asm:    thread->waitingExitTid=tid;
+mkdir.asm:    thread->state=BLOCKED;
+mkdir.asm:      return -1; 
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:	return -1;
+mkdir.asm:    thread->state=BLOCKED;
+mkdir.asm:    thread->sleepInit=uptime();
+mkdir.asm:    thread->sleepTime=ticks;
+mkdir.asm:	return -1;
+mkdir.asm:    thread->state=BLOCKED;
+mkdir.asm:    thread->sleepInit=uptime();
+mkdir.asm:    thread->sleepTime=ticks;
+mkdir.asm:	return -1;
+mkdir.asm:    free(th->utstack);
+mkdir.asm:    th->tid=0;
+mkdir.asm:    th->esp=0;
+mkdir.asm:    th->ebp=0;
+mkdir.asm:    th->eip=0;
+mkdir.asm:    th->state=EMPTY;
+mkdir.asm:    th->sleepTime=0;
+mkdir.asm:    th->sleepInit=0;
+mkdir.asm:    th->isFirstRun=1;
+mkdir.asm:    th->btf=0;
+mkdir.asm:    th->waitingExitTid=0;
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:    th->isFirstRun=1;
+mkdir.asm:    th->btf=0;
+mkdir.asm:    th->waitingExitTid=0;
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+mkdir.asm:      if(ttable.threads[i]->state==RUNNABLE){
+mkdir.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+mkdir.asm:	ttable.threads[i]->state=RUNNABLE;
+mkdir.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+mkdir.asm:	ttable.threads[i]->state=RUNNABLE;
+mkdir.asm:    threadsCounter--;
+mkdir.asm:    threadsCounter--;
+mkdir.d:mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file mkdir.o matches
+Binary file mkfs matches
+mkfs.c:  nblocks = FSSIZE - nmeta;
+mkfs.c:      if(indirect[fbn - NDIRECT] == 0){
+mkfs.c:        indirect[fbn - NDIRECT] = xint(freeblock++);
+mkfs.c:      x = xint(indirect[fbn-NDIRECT]);
+mkfs.c:    n1 = min(n, (fbn + 1) * BSIZE - off);
+mkfs.c:    bcopy(p, buf + off - (fbn * BSIZE), n1);
+mkfs.c:    n -= n1;
+mmu.h:#define SEG_KCPU  3  // kernel per-cpu data
+mmu.h:// cpu->gdt[NSEGS] holds the above segments.
+mmu.h:  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
+mmu.h:#define STA_E       0x4     // Expand down (non-executable segments)
+mmu.h:#define STA_W       0x2     // Writeable (non-executable segments)
+mmu.h:#define STS_T16A    0x1     // Available 16-bit TSS
+mmu.h:#define STS_T16B    0x3     // Busy 16-bit TSS
+mmu.h:#define STS_CG16    0x4     // 16-bit Call Gate
+mmu.h:#define STS_IG16    0x6     // 16-bit Interrupt Gate
+mmu.h:#define STS_TG16    0x7     // 16-bit Trap Gate
+mmu.h:#define STS_T32A    0x9     // Available 32-bit TSS
+mmu.h:#define STS_T32B    0xB     // Busy 32-bit TSS
+mmu.h:#define STS_CG32    0xC     // 32-bit Call Gate
+mmu.h:#define STS_IG32    0xE     // 32-bit Interrupt Gate
+mmu.h:#define STS_TG32    0xF     // 32-bit Trap Gate
+mmu.h:// A virtual address 'la' has a three-part structure as follows:
+mmu.h:// +--------10------+-------10-------+---------12----------+
+mmu.h:// +----------------+----------------+---------------------+
+mmu.h://  \--- PDX(va) --/ \--- PTX(va) --/
+mmu.h:#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+mmu.h:#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+mmu.h:#define PTE_PWT         0x008   // Write-Through
+mmu.h:#define PTE_PCD         0x010   // Cache-Disable
+mmu.h:// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+mmu.h:// - sel: Code segment selector for interrupt/trap handler
+mmu.h:// - off: Offset in code segment for interrupt/trap handler
+mmu.h:// - dpl: Descriptor Privilege Level -
+mp.c:    if((mp = mpsearch1(p-1024, 1024)))
+mp.c:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+mp.c:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+mp.c:  if(conf->version != 1 && conf->version != 4)
+mp.c:  if(sum((uchar*)conf, conf->length) != 0)
+mp.c:  lapic = (uint*)conf->lapicaddr;
+mp.c:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+mp.c:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+mp.c:      ioapicid = ioapic->apicno;
+mp.c:  if(mp->imcrp){
+mp.d:mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h \
+Binary file mp.o matches
+Notes:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
+Notes:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
+Notes:sector-aligned. so you can't use ld -N. and the sections may also need
+Notes:to be non-zero length, only really matters for tiny "kernels".
+Notes:perhaps have fixed-size stack, put it in the data segment?
+Notes:test out-of-fd cases for creating pipe.
+Notes:  per-fd lock *just* protects count read-modify-write
+Notes:in general, the table locks protect both free-ness and
+Notes:  per-pipe lock
+Notes:what does inode->busy mean?
+Notes:  no-one is allowed to do anything to the inode
+Notes:inode->count counts in-memory pointers to the struct
+Notes:  prevents inode[] element from being re-used
+Notes:blocks and inodes have ad-hoc sleep-locks
+Notes:test: dup() shared fd->off
+Notes:sh: stop stdin on ctrl-d (for cat > y)
+param.h:#define KSTACKSIZE 4096  // size of per-process kernel stack
+param.h:#define NINODE       50  // maximum number of active i-nodes
+param.h:#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+picirq.c:#define IO_PIC1         0x20    // Master (IRQs 0-7)
+picirq.c:#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+picirq.c:  // Set up master (8259A-1)
+picirq.c:  //        (slave PIC) 3-bit # of slave's connection to master
+picirq.c:  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
+picirq.c:  // Set up slave (8259A-2)
+picirq.d:picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
+Binary file picirq.o matches
+pipe.c:  p->readopen = 1;
+pipe.c:  p->writeopen = 1;
+pipe.c:  p->nwrite = 0;
+pipe.c:  p->nread = 0;
+pipe.c:  initlock(&p->lock, "pipe");
+pipe.c:  (*f0)->type = FD_PIPE;
+pipe.c:  (*f0)->readable = 1;
+pipe.c:  (*f0)->writable = 0;
+pipe.c:  (*f0)->pipe = p;
+pipe.c:  (*f1)->type = FD_PIPE;
+pipe.c:  (*f1)->readable = 0;
+pipe.c:  (*f1)->writable = 1;
+pipe.c:  (*f1)->pipe = p;
+pipe.c:  return -1;
+pipe.c:  acquire(&p->lock);
+pipe.c:    p->writeopen = 0;
+pipe.c:    wakeup(&p->nread);
+pipe.c:    p->readopen = 0;
+pipe.c:    wakeup(&p->nwrite);
+pipe.c:  if(p->readopen == 0 && p->writeopen == 0){
+pipe.c:    release(&p->lock);
+pipe.c:    release(&p->lock);
+pipe.c:  acquire(&p->lock);
+pipe.c:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+pipe.c:      if(p->readopen == 0 || proc->killed){
+pipe.c:        release(&p->lock);
+pipe.c:        return -1;
+pipe.c:      wakeup(&p->nread);
+pipe.c:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+pipe.c:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+pipe.c:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+pipe.c:  release(&p->lock);
+pipe.c:  acquire(&p->lock);
+pipe.c:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+pipe.c:    if(proc->killed){
+pipe.c:      release(&p->lock);
+pipe.c:      return -1;
+pipe.c:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+pipe.c:  for(i = 0; i < n; i++){  //DOC: piperead-copy
+pipe.c:    if(p->nread == p->nwrite)
+pipe.c:    addr[i] = p->data[p->nread++ % PIPESIZE];
+pipe.c:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+pipe.c:  release(&p->lock);
+pipe.d:pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h \
+Binary file pipe.o matches
+printf.c:    x = -xx;
+printf.c:    buf[i++] = '-';
+printf.c:  while(--i >= 0)
+printf.d:printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file printf.o matches
+printpcs:for p in i386-jos-elf-addr2line addr2line; do
+printpcs:       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
+printpcs:# Enable as much pretty-printing as this addr2line can do
+printpcs:$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
+proc.c:    cprintf("A signal %d was accepted by process %d", sig, proc->pid);
+proc.c:    if(p->state == UNUSED)
+proc.c:  p->state = EMBRYO;
+proc.c:  p->alarmTime=-1;
+proc.c:  p->pid = nextpid++;
+proc.c:      p->sigFuncs[i] = &defaultHandler;
+proc.c:  if((p->kstack = kalloc()) == 0){
+proc.c:    p->state = UNUSED;
+proc.c:  sp = p->kstack + KSTACKSIZE;
+proc.c:  sp -= sizeof *p->tf;
+proc.c:  p->tf = (struct trapframe*)sp;
+proc.c:  sp -= 4;
+proc.c:  sp -= sizeof *p->context;
+proc.c:  p->context = (struct context*)sp;
+proc.c:  memset(p->context, 0, sizeof *p->context);
+proc.c:  p->context->eip = (uint)forkret;
+proc.c:  if((p->pgdir = setupkvm()) == 0)
+proc.c:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+proc.c:  p->sz = PGSIZE;
+proc.c:  memset(p->tf, 0, sizeof(*p->tf));
+proc.c:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+proc.c:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+proc.c:  p->tf->es = p->tf->ds;
+proc.c:  p->tf->ss = p->tf->ds;
+proc.c:  p->tf->eflags = FL_IF;
+proc.c:  p->tf->esp = PGSIZE;
+proc.c:  p->tf->eip = 0;  // beginning of initcode.S
+proc.c:  safestrcpy(p->name, "initcode", sizeof(p->name));
+proc.c:  p->cwd = namei("/");
+proc.c:  // this assignment to p->state lets other cores
+proc.c:  p->state = RUNNABLE;
+proc.c:// Return 0 on success, -1 on failure.
+proc.c:  sz = proc->sz;
+proc.c:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+proc.c:      return -1;
+proc.c:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+proc.c:      return -1;
+proc.c:  proc->sz = sz;
+proc.c:    return -1;
+proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+proc.c:    kfree(np->kstack);
+proc.c:    np->kstack = 0;
+proc.c:    np->state = UNUSED;
+proc.c:    return -1;
+proc.c:  np->sz = proc->sz;
+proc.c:  np->parent = proc;
+proc.c:  *np->tf = *proc->tf;
+proc.c:  np->tf->eax = 0;
+proc.c:    if(proc->ofile[i])
+proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
+proc.c:  np->cwd = idup(proc->cwd);
+proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
+proc.c:  pid = np->pid;
+proc.c:  np->state = RUNNABLE;
+proc.c:    if(proc->ofile[fd]){
+proc.c:      fileclose(proc->ofile[fd]);
+proc.c:      proc->ofile[fd] = 0;
+proc.c:  iput(proc->cwd);
+proc.c:  proc->cwd = 0;
+proc.c:  wakeup1(proc->parent);
+proc.c:    if(p->parent == proc){
+proc.c:      p->parent = initproc;
+proc.c:      if(p->state == ZOMBIE)
+proc.c:  proc->state = ZOMBIE;
+proc.c:// Return -1 if this process has no children.
+proc.c:      if(p->parent != proc)
+proc.c:      if(p->state == ZOMBIE){
+proc.c:        pid = p->pid;
+proc.c:        kfree(p->kstack);
+proc.c:        p->kstack = 0;
+proc.c:        freevm(p->pgdir);
+proc.c:        p->pid = 0;
+proc.c:        p->parent = 0;
+proc.c:        p->name[0] = 0;
+proc.c:        p->killed = 0;
+proc.c:        p->state = UNUSED;
+proc.c:    if(!havekids || proc->killed){
+proc.c:      return -1;
+proc.c:    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+proc.c:// Per-CPU process scheduler.
+proc.c://  - choose a process to run
+proc.c://  - swtch to start running that process
+proc.c://  - eventually that process transfers control
+proc.c:      if(p->state != RUNNABLE)
+proc.c:     /* if(p->alarmTime>0){
+proc.c:	p->alarmTime -=1;
+proc.c:        if(p->alarmTime!=-1 && ticks>=p->alarmTime + p->initAlarmTime){
+proc.c:            //p->alarmTime=0; //reset alarmTime
+proc.c:            p->alarmTime=-1;
+proc.c:            sigsend(p->pid,SIGALRM);
+proc.c:      p->state = RUNNING;
+proc.c:      swtch(&cpu->scheduler, p->context);
+proc.c:      // It should have changed its p->state before coming back.
+proc.c:// and have changed proc->state. Saves and restores
+proc.c:// be proc->intena and proc->ncli, but that would
+proc.c:  if(cpu->ncli != 1)
+proc.c:  if(proc->state == RUNNING)
+proc.c:  intena = cpu->intena;
+proc.c:  swtch(&proc->context, cpu->scheduler);
+proc.c:  cpu->intena = intena;
+proc.c:  proc->state = RUNNABLE;
+proc.c:  // change p->state and then call sched.
+proc.c:  proc->chan = chan;
+proc.c:  proc->state = SLEEPING;
+proc.c:  proc->chan = 0;
+proc.c:    if(p->state == SLEEPING && p->chan == chan)
+proc.c:      p->state = RUNNABLE;
+proc.c:    if(p->pid == pid){
+proc.c:      p->killed = 1;
+proc.c:      if(p->state == SLEEPING)
+proc.c:        p->state = RUNNABLE;
+proc.c:  return -1;
+proc.c:    if(p->state == UNUSED)
+proc.c:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+proc.c:      state = states[p->state];
+proc.c:    cprintf("%d %s %s", p->pid, state, p->name);
+proc.c:    if(p->state == SLEEPING){
+proc.c:      getcallerpcs((uint*)p->context->ebp+2, pc);
+proc.c:        return (sighandler_t) -1;
+proc.c:    sighandler_t oldHandler = proc->sigFuncs[signum];
+proc.c:    proc->sigFuncs[signum] = handler;
+proc.c:    //if fail --> -1 [need to add case!]
+proc.c:        return -1; struct proc *p; int found=0; for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+proc.c:        if(p->pid == pid && (p->state==RUNNING || p->state==RUNNABLE || p->state==SLEEPING)){
+proc.c:        return -1;
+proc.c:    for(i = signum-1; i>0; i--){
+proc.c:    p->pending = sigHex | p->pending;
+proc.c:    ////////////// should be *proc->tf=proc->tf->esp+4;
+proc.c:    proc->tf->esp +=sizeof(uint);
+proc.c:    proc->tf->esp += sizeof(int);
+proc.c:    int length = endInvokeSignal - invokeSignal;
+proc.c:    proc->tf->esp += ((length + 1) & ~3);
+proc.c:    //proc->tf->esp += sizeof(int);
+proc.c:    *proc->tf = *((struct trapframe *)proc->tf->esp);
+proc.c:    cprintf("the sigNum at esp+4 is: %d",proc->tf->esp+0);
+proc.c:    cprintf("the sigNum at esp+4 is: %d",proc->tf->esp+4);
+proc.c:    int temp_esp = proc->tf->esp;
+proc.c:    *proc->tf = *(struct trapframe*)proc->tf->esp;
+proc.c:    cprintf("SIG RETURN BEFORE what is proc->tf->eip? %d\n", proc->tf->eip);
+proc.c:    ////////////// should be *proc->tf=proc->tf->esp+4;
+proc.c:    proc->tf->esp +=sizeof(uint);
+proc.c:    proc->tf->esp += sizeof(int);
+proc.c:    int length = endInvokeSignal - invokeSignal;
+proc.c:    proc->tf->esp += length;
+proc.c:    //proc->tf->esp += sizeof(int);
+proc.c:    *proc->tf = *((struct trapframe *)proc->tf->esp);
+proc.c:    cprintf("SIG RETURN AFTER what is proc->tf->eip? %d\n", proc->tf->eip);
+proc.c:    if (proc == 0 || !((tf->cs&3) == DPL_USER)) //IF IT ISN'T RETURNING TO USER SPACE -> EXIT! 
+proc.c:    if (proc->pending == 0)
+proc.c:    //cprintf("\nproc->pending is before: %d\n",proc->pending);
+proc.c:        if (proc->pending & (1 << i)){
+proc.c:            if (proc->sigFuncs[sigNum] == &defaultHandler)
+proc.c:                proc->pending = proc->pending & ~(1 << i);
+proc.c:            proc->pending = proc->pending & ~(1 << i);
+proc.c:            //cprintf("\nproc->pending is after: %d\n",proc->pending);
+proc.c:    //int temp_esp = proc->tf->esp;
+proc.c:    int temp_esp = tf->esp;
+proc.c:    int length = endInvokeSignal - invokeSignal;
+proc.c:    temp_esp -= ((length + 1) & ~3);
+proc.c:    temp_esp -= sizeof(struct trapframe);
+proc.c:    //memmove(temp_esp, nextThread->btf,sizeof(struct trapframe));
+proc.c:    temp_esp -= 4;
+proc.c:    temp_esp -= 4;
+proc.c:    //proc->tf->esp = temp_esp + 8 + sizeof(struct trapframe);
+proc.c:    //proc->tf->eip = (int)proc->sigFuncs[sigNum];
+proc.c:    tf->esp = ((length + 1 ) & ~3);
+proc.c:    //tf->esp = temp_esp + 8 + sizeof(struct trapframe);
+proc.c:    tf->eip = (int)proc->sigFuncs[sigNum];
+proc.c:    //tf->eip=(int)proc->sigFuncs[sigNum];
+proc.c:    cprintf("HANDLE BEFORE what is proc->tf->eip? %d\n", proc->tf->eip);
+proc.c:    int temp_esp = tf->esp;
+proc.c:    temp_esp -= sizeof(struct trapframe);
+proc.c:    tf->esp -= sizeof(struct trapframe);
+proc.c:    //tf->esp -= sizeof(int); //update the magic number
+proc.c:    //tf->esp -= sizeof(int);
+proc.c:    // *((int*)tf->esp)=200;
+proc.c:    int length = endInvokeSignal - invokeSignal;
+proc.c:    tf->esp -= length; //decrease tf->esp by the length of the InvokeSignal segment 
+proc.c:    int offset = tf->esp;
+proc.c:    memmove((int*)tf->esp, invokeSignal, length);
+proc.c:    tf->esp -=4; //decrease esp by 4 so that we can push the sigNum
+proc.c:    *(int*) tf->esp = sigNum;
+proc.c:    tf->esp -= 4;
+proc.c:    *(int*) tf->esp = offset;
+proc.c:    proc->tf->eip = (int) proc->sigFuncs[sigNum];
+proc.c:    cprintf("HANDLE AFTER what is proc->tf->eip? %d\n", proc->tf->eip);
+proc.c:    int temp_esp = tf->esp;
+proc.c:    temp_esp -= sizeof(struct trapframe);
+proc.c:    tf->esp -= sizeof(struct trapframe);
+proc.c:    //tf->esp -= sizeof(int); //update the magic number
+proc.c:    //tf->esp -= sizeof(int);
+proc.c:    // *((int*)tf->esp)=200;
+proc.c:    int length = endInvokeSignal - invokeSignal;
+proc.c:    tf->esp -= length; //decrease tf->esp by the length of the InvokeSignal segment 
+proc.c:    int offset = tf->esp;
+proc.c:    memmove((int*)tf->esp, invokeSignal, length);
+proc.c:    tf->esp -=4; //decrease esp by 4 so that we can push the sigNum
+proc.c:    *(int*) tf->esp = sigNum;
+proc.c:    tf->esp -= 4;
+proc.c:    *(int*) tf->esp = offset;
+proc.c:    tf->eip = (int) proc->sigFuncs[sigNum];
+proc.c:        proc->alarmTime=0;
+proc.c:    proc->alarmTime = pticks;
+proc.c:    proc->initAlarmTime = ticks;
+proc.c:        proc->alarmTime=-1;
+proc.c:    proc->alarmTime = pticks;
+proc.c:    proc->initAlarmTime = ticks;
+proc.d:proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+proc.h:// Per-CPU state
+proc.h:  // Cpu-local storage variables; see below
+proc.h:  struct proc *proc;           // The currently-running process.
+proc.h:// Per-CPU variables, holding pointers to the
+proc.h:// This is similar to how thread-local variables are implemented
+proc.h:// Per-process state
+proc.h:  void *chan;                  // If non-zero, sleeping on chan
+proc.h:  int killed;                  // If non-zero, have been killed
+proc.h://   fixed-size stack
+Binary file proc.o matches
+pr.pl:if($ARGV[0] eq "-h"){
+pr.pl:	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
+README:xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
+README:but is implemented for a modern x86-based multiprocessor using ANSI C.
+README:to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+README:provides pointers to on-line resources for v6.
+README:Boyd-Wickizer, Cody Cutler, Mike CAT, Nelson Elhage, Nathaniel Filardo, Peter
+README:Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
+README:On non-x86 or non-ELF machines (like OS X, even on x86), you will
+README:need to install a cross-compiler gcc suite capable of producing x86 ELF
+README:Then run "make TOOLPREFIX=i386-jos-elf-".
+Binary file _rm matches
+rm.asm:_rm:     file format elf32-i386
+rm.asm:  93:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+rm.asm:  9c:	88 5a ff             	mov    %bl,-0x1(%edx)
+rm.asm:  return (uchar)*p - (uchar)*q;
+rm.asm:  return (uchar)*p - (uchar)*q;
+rm.asm: 19b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+rm.asm: 1bc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+rm.asm: 1c7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+rm.asm:    return -1;
+rm.asm:    return -1;
+rm.asm:    return -1;
+rm.asm: 24a:	8d 42 d0             	lea    -0x30(%edx),%eax
+rm.asm:    n = n*10 + *s++ - '0';
+rm.asm: 25e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+rm.asm: 265:	8d 5a d0             	lea    -0x30(%edx),%ebx
+rm.asm:    n = n*10 + *s++ - '0';
+rm.asm:  while(n-- > 0)
+rm.asm:  while(n-- > 0)
+rm.asm:  while(n-- > 0)
+rm.asm:    x = -xx;
+rm.asm: 38d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+rm.asm: 394:	89 75 c0             	mov    %esi,-0x40(%ebp)
+rm.asm:    x = -xx;
+rm.asm: 39b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+rm.asm: 3b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+rm.asm: 3bc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+rm.asm:    buf[i++] = '-';
+rm.asm: 3c6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+rm.asm:  while(--i >= 0)
+rm.asm: 3cb:	8d 79 ff             	lea    -0x1(%ecx),%edi
+rm.asm: 3d0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+rm.asm: 3e7:	88 45 d7             	mov    %al,-0x29(%ebp)
+rm.asm:    buf[i++] = '-';
+rm.asm:  while(--i >= 0)
+rm.asm:    x = -xx;
+rm.asm: 404:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+rm.asm: 424:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+rm.asm: 441:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+rm.asm: 453:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+rm.asm: 45e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+rm.asm: 4a8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+rm.asm: 4bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+rm.asm: 4c2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+rm.asm: 4cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+rm.asm: 4ce:	8d 45 e7             	lea    -0x19(%ebp),%eax
+rm.asm: 4e0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+rm.asm: 4e8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+rm.asm: 510:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+rm.asm: 52a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+rm.asm: 538:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+rm.asm: 53b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+rm.asm: 558:	88 45 e3             	mov    %al,-0x1d(%ebp)
+rm.asm: 55b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+rm.asm: 588:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+rm.asm: 59c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+rm.asm: 5b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+rm.asm: 5cb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+rm.asm: 5d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+rm.asm: 5e6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+rm.asm: 5e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+rm.asm: 5f5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm: 610:	8d 53 f8             	lea    -0x8(%ebx),%edx
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  if(bp + bp->s.size == p->s.ptr){
+rm.asm: 630:	8b 73 fc             	mov    -0x4(%ebx),%esi
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm: 63a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm:    p->s.ptr = bp;
+rm.asm:  bp = (Header*)ap - 1;
+rm.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+rm.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+rm.asm:  if(bp + bp->s.size == p->s.ptr){
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm: 65b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm: 662:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm: 66f:	03 4b fc             	add    -0x4(%ebx),%ecx
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm:    p->s.ptr = bp;
+rm.asm:    bp->s.size += p->s.ptr->s.size;
+rm.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+rm.asm:    bp->s.ptr = p->s.ptr;
+rm.asm:  if(p + p->s.size == bp){
+rm.asm:    p->s.size += bp->s.size;
+rm.asm:    p->s.ptr = bp->s.ptr;
+rm.asm: 67a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+rm.asm:    p->s.ptr = bp;
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm: 6c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:        p->s.size = nunits;
+rm.asm: 6e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+rm.asm:  if(p == (char*)-1)
+rm.asm:  hp->s.size = nu;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:      if(p->s.size == nunits)
+rm.asm:        prevp->s.ptr = p->s.ptr;
+rm.asm:        p->s.size -= nunits;
+rm.asm:        p += p->s.size;
+rm.asm:        p->s.size = nunits;
+rm.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+rm.asm:    if(p->s.size >= nunits){
+rm.asm:      if(p->s.size == nunits)
+rm.asm:        prevp->s.ptr = p->s.ptr;
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+rm.asm:    return newThread->tid;
+rm.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+rm.asm:    return newThread->tid;
+rm.asm:    thread->state=RUNNABLE;
+rm.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+rm.asm:    thread->state=RUNNABLE;
+rm.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+rm.asm:	ttable.threads[i]->state=RUNNABLE;
+rm.asm:    thread->state=RUNNABLE;
+rm.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+rm.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+rm.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+rm.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+rm.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+rm.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+rm.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+rm.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+rm.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+rm.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+rm.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+rm.asm:  //1. store tf in the thread->btf
+rm.asm:  *thread->btf = tf;
+rm.asm:  if(nextThread->isFirstRun==1){
+rm.asm:    //move the tf that is stored in nextThread->btf to the stack
+rm.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+rm.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+rm.asm:  nextThread->state=RUNNING;
+rm.asm:  nextThread->isFirstRun=0;
+rm.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+rm.asm:  nextThread->state=RUNNING;
+rm.asm:  nextThread->isFirstRun=0;
+rm.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+rm.asm:    thread->state=RUNNABLE;
+rm.asm:  *thread->btf = tf;
+rm.asm:  if(nextThread->isFirstRun==1){
+rm.asm: 933:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+rm.asm: 93b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+rm.asm:    ntf->esp=nextThread->btf->esp;
+rm.asm:    ntf->eip=nextThread->btf->eip;
+rm.asm:      //ttable.threads[i]->utstack=0;
+rm.asm:      //ttable.threads[i]->tid=0;
+rm.asm:      //ttable.threads[i]->esp=0;
+rm.asm:      //ttable.threads[i]->ebp=0;
+rm.asm:      //ttable.threads[i]->eip=0;
+rm.asm:      ttable.threads[i]->state=EMPTY;
+rm.asm:      //ttable.threads[i]->sleepTime=0
+rm.asm:      //ttable.threads[i]->sleepInit=0;
+rm.asm:      ttable.threads[i]->isFirstRun=1;
+rm.asm:      //ttable.threads[i]->btf=0;
+rm.asm:      //ttable.threads[i]->waitingExitTid=0;
+rm.asm:    thread->tid = threadTidCounter;
+rm.asm:    thread->state = RUNNING;
+rm.asm:      //ttable.threads[i]->btf=0;
+rm.asm:      //ttable.threads[i]->waitingExitTid=0;
+rm.asm:    thread->tid = threadTidCounter;
+rm.asm:    thread->state = RUNNING;
+rm.asm:    thread->tid = threadTidCounter;
+rm.asm:    thread->state = RUNNING;
+rm.asm:        return -1;*/
+rm.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+rm.asm:      //ttable.threads[i]->btf=0;
+rm.asm:      //ttable.threads[i]->waitingExitTid=0;
+rm.asm:    thread->tid = threadTidCounter;
+rm.asm:    thread->state = RUNNING;
+rm.asm:        return -1;*/
+rm.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+rm.asm:      return -1;
+rm.asm:        return -1;*/
+rm.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+rm.asm:      return -1;
+rm.asm:    if (threadNum == MAX_UTHREADS - 1) 
+rm.asm:        return -1;
+rm.asm:      if(ttable.threads[i]->state==EMPTY){
+rm.asm:    newThread->tid = threadTidCounter;
+rm.asm:    newThread->tid = threadTidCounter;
+rm.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+rm.asm:    newThread->tid = threadTidCounter;
+rm.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+rm.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+rm.asm:    esp -= 4;
+rm.asm:    newThread->tid = threadTidCounter;
+rm.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+rm.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+rm.asm:    esp -= 4;
+rm.asm:    esp -= 4;
+rm.asm:    newThread->btf->esp=esp-3*sizeof(int);
+rm.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+rm.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+rm.asm:    esp -= 4;
+rm.asm:    esp -= 4;
+rm.asm:    newThread->btf->esp=esp-3*sizeof(int);
+rm.asm:    newThread->btf->eip=(int)start_func;
+rm.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+rm.asm:    newThread->eip=(int)start_func;//
+rm.asm:    newThread->state = RUNNABLE;
+rm.asm:    return newThread->tid;
+rm.asm:    if (threadNum == MAX_UTHREADS - 1) 
+rm.asm:        return -1;
+rm.asm:    return thread->tid;
+rm.asm:    return thread->tid;
+rm.asm:    return thread->tid;
+rm.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+rm.asm:    return thread->tid;
+rm.asm:      if(ttable.threads[i]->tid==tid){
+rm.asm:      return -1; 
+rm.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+rm.asm:      return -1; 
+rm.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+rm.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+rm.asm:    thread->waitingExitTid=tid;
+rm.asm:    thread->state=BLOCKED;
+rm.asm:      return -1; 
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:	return -1;
+rm.asm:    thread->state=BLOCKED;
+rm.asm:    thread->sleepInit=uptime();
+rm.asm:    thread->sleepTime=ticks;
+rm.asm:	return -1;
+rm.asm:    thread->state=BLOCKED;
+rm.asm:    thread->sleepInit=uptime();
+rm.asm:    thread->sleepTime=ticks;
+rm.asm:	return -1;
+rm.asm:    free(th->utstack);
+rm.asm:    th->tid=0;
+rm.asm:    th->esp=0;
+rm.asm:    th->ebp=0;
+rm.asm:    th->eip=0;
+rm.asm:    th->state=EMPTY;
+rm.asm:    th->sleepTime=0;
+rm.asm:    th->sleepInit=0;
+rm.asm:    th->isFirstRun=1;
+rm.asm:    th->btf=0;
+rm.asm:    th->waitingExitTid=0;
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:    th->isFirstRun=1;
+rm.asm:    th->btf=0;
+rm.asm:    th->waitingExitTid=0;
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+rm.asm:      if(ttable.threads[i]->state==RUNNABLE){
+rm.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+rm.asm:	ttable.threads[i]->state=RUNNABLE;
+rm.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+rm.asm:	ttable.threads[i]->state=RUNNABLE;
+rm.asm:    threadsCounter--;
+rm.asm:    threadsCounter--;
+rm.d:rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file rm.o matches
+runoff:mkdir -p fmt
+runoff:rm -f fmt/*
+runoff:files=`grep -v '^#' runoff.list | awk '{print $1}'`
+runoff:	./runoff1 -n $n $i >fmt/$i
+runoff:	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+runoff:pr -e8 -t runoff.list | awk '
+runoff:/^[a-z0-9]/ {
+runoff:}' | pr -3 -t >>fmt/toc
+runoff:perl -e '
+runoff:			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
+runoff:perl -e '
+runoff:		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
+runoff:		if (/^[0-9]+ extern/) {
+runoff:		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
+runoff:		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
+runoff:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
+runoff:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
+runoff:		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
+runoff:		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
+runoff:		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
+runoff:		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+runoff:perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
+runoff:	egrep -v ' (STUB|usage|main|if|for)$' >>defs
+runoff:#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
+runoff:for i in `awk '{print $2}' defs | sort -f | uniq`
+runoff:	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
+runoff:	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
+runoff:		echo $uses |fmt -29 | sed 's/^/    /'
+runoff:	../pr.pl -h "table of contents" toc
+runoff:	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
+runoff:	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
+runoff:	# pr.pl -h "definitions" -2 t.defs | pad
+runoff:	# pr.pl -h "cross-references" -2 refs | pad 
+runoff:		../pr.pl -h "xv6/$i" $i
+runoff:) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
+runoff:nicefont=LucidaSans-Typewriter83
+runoff:if [ ! -f ../$nicefont ]
+runoff:	if git cat-file blob font:$nicefont > ../$nicefont~; then
+runoff:if [ -f ../$nicefont ]
+runoff1:if($ARGV[0] eq "-v") {
+runoff1:if($ARGV[0] eq "-n") {
+runoff1:$n = int(($n+49)/50)*50 - 1;
+runoff1:			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
+runoff1:		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
+runoff1:		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
+runoff.list:# low-level hardware
+runoff.list:# user-level
+runoff.spec:# "left" and "right" specify which page of a two-page spread a file
+runoff.spec:# goal is to have two action-packed 2-page spreads,
+runoff.spec:# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
+Binary file _sh matches
+sh.asm:_sh:     file format elf32-i386
+sh.asm:      buf[strlen(buf)-1] = 0;  // chop \n
+sh.asm:      buf[strlen(buf)-1] = 0;  // chop \n
+sh.asm:      buf[strlen(buf)-1] = 0;  // chop \n
+sh.asm:      buf[strlen(buf)-1] = 0;  // chop \n
+sh.asm:    return -1;
+sh.asm:    return -1;
+sh.asm:  if(pid == -1)
+sh.asm:  if(pid == -1)
+sh.asm:  switch(cmd->type){
+sh.asm:    runcmd(lcmd->right);
+sh.asm:     1d0:	8d 45 f0             	lea    -0x10(%ebp),%eax
+sh.asm:      runcmd(pcmd->left);
+sh.asm:      runcmd(pcmd->right);
+sh.asm:     1fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+sh.asm:     208:	8b 45 f4             	mov    -0xc(%ebp),%eax
+sh.asm:    close(rcmd->fd);
+sh.asm:    if(open(rcmd->file, rcmd->mode) < 0){
+sh.asm:      printf(2, "open %s failed\n", rcmd->file);
+sh.asm:    if(ecmd->argv[0] == 0)
+sh.asm:    exec(ecmd->argv[0], ecmd->argv);
+sh.asm:    printf(2, "exec %s failed\n", ecmd->argv[0]);
+sh.asm:    runcmd(rcmd->cmd);
+sh.asm:      runcmd(lcmd->left);
+sh.asm:    runcmd(lcmd->right);
+sh.asm:    printf(2, "exec %s failed\n", ecmd->argv[0]);
+sh.asm:    close(rcmd->fd);
+sh.asm:    if(open(rcmd->file, rcmd->mode) < 0){
+sh.asm:      runcmd(bcmd->cmd);
+sh.asm:  switch(cmd->type){
+sh.asm:    close(rcmd->fd);
+sh.asm:    if(open(rcmd->file, rcmd->mode) < 0){
+sh.asm:      printf(2, "open %s failed\n", rcmd->file);
+sh.asm:      runcmd(pcmd->left);
+sh.asm:     2f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+sh.asm:     2fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+sh.asm:     308:	8b 45 f4             	mov    -0xc(%ebp),%eax
+sh.asm:      runcmd(pcmd->right);
+sh.asm:     32a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+sh.asm:     335:	8b 45 f0             	mov    -0x10(%ebp),%eax
+sh.asm:     340:	8b 45 f4             	mov    -0xc(%ebp),%eax
+sh.asm:      runcmd(pcmd->left);
+sh.asm:  cmd->type = EXEC;
+sh.asm:  cmd->type = EXEC;
+sh.asm:  cmd->type = REDIR;
+sh.asm:  cmd->cmd = subcmd;
+sh.asm:  cmd->type = REDIR;
+sh.asm:  cmd->cmd = subcmd;
+sh.asm:  cmd->file = file;
+sh.asm:  cmd->efile = efile;
+sh.asm:  cmd->mode = mode;
+sh.asm:  cmd->fd = fd;
+sh.asm:  cmd->type = PIPE;
+sh.asm:  cmd->left = left;
+sh.asm:  cmd->type = PIPE;
+sh.asm:  cmd->left = left;
+sh.asm:  cmd->right = right;
+sh.asm:  cmd->type = LIST;
+sh.asm:  cmd->left = left;
+sh.asm:  cmd->type = LIST;
+sh.asm:  cmd->left = left;
+sh.asm:  cmd->right = right;
+sh.asm:  cmd->type = BACK;
+sh.asm:  cmd->cmd = subcmd;
+sh.asm:  cmd->type = BACK;
+sh.asm:  cmd->cmd = subcmd;
+sh.asm:     6e1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+sh.asm:     6e8:	8d 45 e0             	lea    -0x20(%ebp),%eax
+sh.asm:     718:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+sh.asm:     71f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+sh.asm:     7ad:	89 45 cc             	mov    %eax,-0x34(%ebp)
+sh.asm:     7b5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+sh.asm:     7bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
+sh.asm:    cmd->argv[argc] = q;
+sh.asm:    cmd->eargv[argc] = eq;
+sh.asm:     7c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+sh.asm:     7db:	89 45 d0             	mov    %eax,-0x30(%ebp)
+sh.asm:     7f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+sh.asm:     7fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
+sh.asm:    cmd->argv[argc] = q;
+sh.asm:     819:	8b 45 e0             	mov    -0x20(%ebp),%eax
+sh.asm:    cmd->eargv[argc] = eq;
+sh.asm:     81f:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
+sh.asm:    cmd->argv[argc] = q;
+sh.asm:    cmd->eargv[argc] = eq;
+sh.asm:     825:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+sh.asm:     82b:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
+sh.asm:  cmd->argv[argc] = 0;
+sh.asm:  cmd->eargv[argc] = 0;
+sh.asm:     858:	8b 45 cc             	mov    -0x34(%ebp),%eax
+sh.asm:     85b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+sh.asm:  cmd->argv[argc] = 0;
+sh.asm:  cmd->eargv[argc] = 0;
+sh.asm:     86f:	8b 45 d0             	mov    -0x30(%ebp),%eax
+sh.asm:    panic("syntax - missing )");
+sh.asm:    panic("syntax - missing )");
+sh.asm:// NUL-terminate all the counted strings.
+sh.asm:  switch(cmd->type){
+sh.asm:    nulterminate(pcmd->right);
+sh.asm:    nulterminate(lcmd->left);
+sh.asm:    nulterminate(lcmd->right);
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:  switch(cmd->type){
+sh.asm:    for(i=0; ecmd->argv[i]; i++)
+sh.asm:      *ecmd->eargv[i] = 0;
+sh.asm:  switch(cmd->type){
+sh.asm:    for(i=0; ecmd->argv[i]; i++)
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:  switch(cmd->type){
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:    nulterminate(lcmd->right);
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:      *ecmd->eargv[i] = 0;
+sh.asm:    nulterminate(rcmd->cmd);
+sh.asm:    *rcmd->efile = 0;
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:    nulterminate(rcmd->cmd);
+sh.asm:    *rcmd->efile = 0;
+sh.asm:    nulterminate(bcmd->cmd);
+sh.asm:     bd3:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+sh.asm:     bdc:	88 5a ff             	mov    %bl,-0x1(%edx)
+sh.asm:  return (uchar)*p - (uchar)*q;
+sh.asm:  return (uchar)*p - (uchar)*q;
+sh.asm:     cdb:	8d 7d e7             	lea    -0x19(%ebp),%edi
+sh.asm:     cfc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+sh.asm:     d07:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+sh.asm:    return -1;
+sh.asm:    return -1;
+sh.asm:    return -1;
+sh.asm:     d8a:	8d 42 d0             	lea    -0x30(%edx),%eax
+sh.asm:    n = n*10 + *s++ - '0';
+sh.asm:     d9e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+sh.asm:     da5:	8d 5a d0             	lea    -0x30(%edx),%ebx
+sh.asm:    n = n*10 + *s++ - '0';
+sh.asm:  while(n-- > 0)
+sh.asm:  while(n-- > 0)
+sh.asm:  while(n-- > 0)
+sh.asm:    x = -xx;
+sh.asm:     ecd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+sh.asm:     ed4:	89 75 c0             	mov    %esi,-0x40(%ebp)
+sh.asm:    x = -xx;
+sh.asm:     edb:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+sh.asm:     ef7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+sh.asm:     efc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+sh.asm:    buf[i++] = '-';
+sh.asm:     f06:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+sh.asm:  while(--i >= 0)
+sh.asm:     f0b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+sh.asm:     f10:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+sh.asm:     f27:	88 45 d7             	mov    %al,-0x29(%ebp)
+sh.asm:    buf[i++] = '-';
+sh.asm:  while(--i >= 0)
+sh.asm:    x = -xx;
+sh.asm:     f44:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+sh.asm:     f64:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+sh.asm:     f81:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+sh.asm:     f93:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+sh.asm:     f9e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+sh.asm:     fe8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+sh.asm:     fff:	89 55 d0             	mov    %edx,-0x30(%ebp)
+sh.asm:    1002:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+sh.asm:    100b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+sh.asm:    100e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+sh.asm:    1020:	88 55 e7             	mov    %dl,-0x19(%ebp)
+sh.asm:    1028:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+sh.asm:    1050:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+sh.asm:    106a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+sh.asm:    1078:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+sh.asm:    107b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+sh.asm:    1098:	88 45 e3             	mov    %al,-0x1d(%ebp)
+sh.asm:    109b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+sh.asm:    10c8:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+sh.asm:    10dc:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+sh.asm:    10f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+sh.asm:    110b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+sh.asm:    1114:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+sh.asm:    1126:	88 45 e4             	mov    %al,-0x1c(%ebp)
+sh.asm:    1129:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+sh.asm:    1135:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:    1150:	8d 53 f8             	lea    -0x8(%ebx),%edx
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  if(bp + bp->s.size == p->s.ptr){
+sh.asm:    1170:	8b 73 fc             	mov    -0x4(%ebx),%esi
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:    117a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    p->s.ptr = bp;
+sh.asm:  bp = (Header*)ap - 1;
+sh.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+sh.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+sh.asm:  if(bp + bp->s.size == p->s.ptr){
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    119b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    11a2:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    11af:	03 4b fc             	add    -0x4(%ebx),%ecx
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    p->s.ptr = bp;
+sh.asm:    bp->s.size += p->s.ptr->s.size;
+sh.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+sh.asm:    bp->s.ptr = p->s.ptr;
+sh.asm:  if(p + p->s.size == bp){
+sh.asm:    p->s.size += bp->s.size;
+sh.asm:    p->s.ptr = bp->s.ptr;
+sh.asm:    11ba:	8b 53 f8             	mov    -0x8(%ebx),%edx
+sh.asm:    p->s.ptr = bp;
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:    1208:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:        p->s.size = nunits;
+sh.asm:    1223:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+sh.asm:  if(p == (char*)-1)
+sh.asm:  hp->s.size = nu;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:      if(p->s.size == nunits)
+sh.asm:        prevp->s.ptr = p->s.ptr;
+sh.asm:        p->s.size -= nunits;
+sh.asm:        p += p->s.size;
+sh.asm:        p->s.size = nunits;
+sh.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+sh.asm:    if(p->s.size >= nunits){
+sh.asm:      if(p->s.size == nunits)
+sh.asm:        prevp->s.ptr = p->s.ptr;
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+sh.asm:    return newThread->tid;
+sh.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+sh.asm:    return newThread->tid;
+sh.asm:    thread->state=RUNNABLE;
+sh.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+sh.asm:    thread->state=RUNNABLE;
+sh.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+sh.asm:	ttable.threads[i]->state=RUNNABLE;
+sh.asm:    thread->state=RUNNABLE;
+sh.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+sh.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+sh.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+sh.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+sh.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+sh.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+sh.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+sh.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+sh.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+sh.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+sh.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+sh.asm:  //1. store tf in the thread->btf
+sh.asm:  *thread->btf = tf;
+sh.asm:  if(nextThread->isFirstRun==1){
+sh.asm:    //move the tf that is stored in nextThread->btf to the stack
+sh.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+sh.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+sh.asm:  nextThread->state=RUNNING;
+sh.asm:  nextThread->isFirstRun=0;
+sh.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+sh.asm:  nextThread->state=RUNNING;
+sh.asm:  nextThread->isFirstRun=0;
+sh.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+sh.asm:    thread->state=RUNNABLE;
+sh.asm:  *thread->btf = tf;
+sh.asm:  if(nextThread->isFirstRun==1){
+sh.asm:    1473:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+sh.asm:    147b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+sh.asm:    ntf->esp=nextThread->btf->esp;
+sh.asm:    ntf->eip=nextThread->btf->eip;
+sh.asm:      //ttable.threads[i]->utstack=0;
+sh.asm:      //ttable.threads[i]->tid=0;
+sh.asm:      //ttable.threads[i]->esp=0;
+sh.asm:      //ttable.threads[i]->ebp=0;
+sh.asm:      //ttable.threads[i]->eip=0;
+sh.asm:      ttable.threads[i]->state=EMPTY;
+sh.asm:      //ttable.threads[i]->sleepTime=0
+sh.asm:      //ttable.threads[i]->sleepInit=0;
+sh.asm:      ttable.threads[i]->isFirstRun=1;
+sh.asm:      //ttable.threads[i]->btf=0;
+sh.asm:      //ttable.threads[i]->waitingExitTid=0;
+sh.asm:    thread->tid = threadTidCounter;
+sh.asm:    thread->state = RUNNING;
+sh.asm:      //ttable.threads[i]->btf=0;
+sh.asm:      //ttable.threads[i]->waitingExitTid=0;
+sh.asm:    thread->tid = threadTidCounter;
+sh.asm:    thread->state = RUNNING;
+sh.asm:    thread->tid = threadTidCounter;
+sh.asm:    thread->state = RUNNING;
+sh.asm:        return -1;*/
+sh.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+sh.asm:      //ttable.threads[i]->btf=0;
+sh.asm:      //ttable.threads[i]->waitingExitTid=0;
+sh.asm:    thread->tid = threadTidCounter;
+sh.asm:    thread->state = RUNNING;
+sh.asm:        return -1;*/
+sh.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+sh.asm:      return -1;
+sh.asm:        return -1;*/
+sh.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+sh.asm:      return -1;
+sh.asm:    if (threadNum == MAX_UTHREADS - 1) 
+sh.asm:        return -1;
+sh.asm:      if(ttable.threads[i]->state==EMPTY){
+sh.asm:    newThread->tid = threadTidCounter;
+sh.asm:    newThread->tid = threadTidCounter;
+sh.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+sh.asm:    newThread->tid = threadTidCounter;
+sh.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+sh.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+sh.asm:    esp -= 4;
+sh.asm:    newThread->tid = threadTidCounter;
+sh.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+sh.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+sh.asm:    esp -= 4;
+sh.asm:    esp -= 4;
+sh.asm:    newThread->btf->esp=esp-3*sizeof(int);
+sh.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+sh.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+sh.asm:    esp -= 4;
+sh.asm:    esp -= 4;
+sh.asm:    newThread->btf->esp=esp-3*sizeof(int);
+sh.asm:    newThread->btf->eip=(int)start_func;
+sh.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+sh.asm:    newThread->eip=(int)start_func;//
+sh.asm:    newThread->state = RUNNABLE;
+sh.asm:    return newThread->tid;
+sh.asm:    if (threadNum == MAX_UTHREADS - 1) 
+sh.asm:        return -1;
+sh.asm:    return thread->tid;
+sh.asm:    return thread->tid;
+sh.asm:    return thread->tid;
+sh.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+sh.asm:    return thread->tid;
+sh.asm:      if(ttable.threads[i]->tid==tid){
+sh.asm:      return -1; 
+sh.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+sh.asm:      return -1; 
+sh.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+sh.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+sh.asm:    thread->waitingExitTid=tid;
+sh.asm:    thread->state=BLOCKED;
+sh.asm:      return -1; 
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:	return -1;
+sh.asm:    thread->state=BLOCKED;
+sh.asm:    thread->sleepInit=uptime();
+sh.asm:    thread->sleepTime=ticks;
+sh.asm:	return -1;
+sh.asm:    thread->state=BLOCKED;
+sh.asm:    thread->sleepInit=uptime();
+sh.asm:    thread->sleepTime=ticks;
+sh.asm:	return -1;
+sh.asm:    free(th->utstack);
+sh.asm:    th->tid=0;
+sh.asm:    th->esp=0;
+sh.asm:    th->ebp=0;
+sh.asm:    th->eip=0;
+sh.asm:    th->state=EMPTY;
+sh.asm:    th->sleepTime=0;
+sh.asm:    th->sleepInit=0;
+sh.asm:    th->isFirstRun=1;
+sh.asm:    th->btf=0;
+sh.asm:    th->waitingExitTid=0;
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:    th->isFirstRun=1;
+sh.asm:    th->btf=0;
+sh.asm:    th->waitingExitTid=0;
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+sh.asm:      if(ttable.threads[i]->state==RUNNABLE){
+sh.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+sh.asm:	ttable.threads[i]->state=RUNNABLE;
+sh.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+sh.asm:	ttable.threads[i]->state=RUNNABLE;
+sh.asm:    threadsCounter--;
+sh.asm:    threadsCounter--;
+sh.c:  switch(cmd->type){
+sh.c:    if(ecmd->argv[0] == 0)
+sh.c:    exec(ecmd->argv[0], ecmd->argv);
+sh.c:    printf(2, "exec %s failed\n", ecmd->argv[0]);
+sh.c:    close(rcmd->fd);
+sh.c:    if(open(rcmd->file, rcmd->mode) < 0){
+sh.c:      printf(2, "open %s failed\n", rcmd->file);
+sh.c:    runcmd(rcmd->cmd);
+sh.c:      runcmd(lcmd->left);
+sh.c:    runcmd(lcmd->right);
+sh.c:      runcmd(pcmd->left);
+sh.c:      runcmd(pcmd->right);
+sh.c:      runcmd(bcmd->cmd);
+sh.c:    return -1;
+sh.c:      buf[strlen(buf)-1] = 0;  // chop \n
+sh.c:  if(pid == -1)
+sh.c:  cmd->type = EXEC;
+sh.c:  cmd->type = REDIR;
+sh.c:  cmd->cmd = subcmd;
+sh.c:  cmd->file = file;
+sh.c:  cmd->efile = efile;
+sh.c:  cmd->mode = mode;
+sh.c:  cmd->fd = fd;
+sh.c:  cmd->type = PIPE;
+sh.c:  cmd->left = left;
+sh.c:  cmd->right = right;
+sh.c:  cmd->type = LIST;
+sh.c:  cmd->left = left;
+sh.c:  cmd->right = right;
+sh.c:  cmd->type = BACK;
+sh.c:  cmd->cmd = subcmd;
+sh.c:    panic("syntax - missing )");
+sh.c:    cmd->argv[argc] = q;
+sh.c:    cmd->eargv[argc] = eq;
+sh.c:  cmd->argv[argc] = 0;
+sh.c:  cmd->eargv[argc] = 0;
+sh.c:// NUL-terminate all the counted strings.
+sh.c:  switch(cmd->type){
+sh.c:    for(i=0; ecmd->argv[i]; i++)
+sh.c:      *ecmd->eargv[i] = 0;
+sh.c:    nulterminate(rcmd->cmd);
+sh.c:    *rcmd->efile = 0;
+sh.c:    nulterminate(pcmd->left);
+sh.c:    nulterminate(pcmd->right);
+sh.c:    nulterminate(lcmd->left);
+sh.c:    nulterminate(lcmd->right);
+sh.c:    nulterminate(bcmd->cmd);
+sh.d:sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
+Binary file sh.o matches
+show1:runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
+sign.pl:$buf .= "\0" x (510-$n);
+sleep1.p:then a deadlock can happen, because the non-atomic
+sleep1.p:increment of value conflicts with the non-atomic 
+sleep1.p:	:: cond ->
+sleep1.p:	:: else ->
+sleep1.p:	:: w < N ->
+sleep1.p:	:: else ->
+sleep1.p:	:: i < ITER ->
+sleep1.p:		x = value; value = x - 1; x = 0;
+sleep1.p:	:: else ->
+sleep1.p:	:: i < ITER ->
+sleep1.p:	:: else ->
+sleeplock.c:  initlock(&lk->lk, "sleep lock");
+sleeplock.c:  lk->name = name;
+sleeplock.c:  lk->locked = 0;
+sleeplock.c:  lk->pid = 0;
+sleeplock.c:  acquire(&lk->lk);
+sleeplock.c:  while (lk->locked) {
+sleeplock.c:    sleep(lk, &lk->lk);
+sleeplock.c:  lk->locked = 1;
+sleeplock.c:  lk->pid = proc->pid;
+sleeplock.c:  release(&lk->lk);
+sleeplock.c:  acquire(&lk->lk);
+sleeplock.c:  lk->locked = 0;
+sleeplock.c:  lk->pid = 0;
+sleeplock.c:  release(&lk->lk);
+sleeplock.c:  acquire(&lk->lk);
+sleeplock.c:  r = lk->locked;
+sleeplock.c:  release(&lk->lk);
+sleeplock.d:sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h \
+sleeplock.h:// Long-term locks for processes
+Binary file sleeplock.o matches
+spinlock.c:  lk->name = name;
+spinlock.c:  lk->locked = 0;
+spinlock.c:  lk->cpu = 0;
+spinlock.c:  while(xchg(&lk->locked, 1) != 0)
+spinlock.c:  lk->cpu = cpu;
+spinlock.c:  getcallerpcs(&lk, lk->pcs);
+spinlock.c:  lk->pcs[0] = 0;
+spinlock.c:  lk->cpu = 0;
+spinlock.c:  // Both the C compiler and the hardware may re-order loads and
+spinlock.c:  // Release the lock, equivalent to lk->locked = 0.
+spinlock.c:  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+spinlock.c:  ebp = (uint*)v - 2;
+spinlock.c:  return lock->locked && lock->cpu == cpu;
+spinlock.c:  if(cpu->ncli == 0)
+spinlock.c:    cpu->intena = eflags & FL_IF;
+spinlock.c:  cpu->ncli += 1;
+spinlock.c:    panic("popcli - interruptible");
+spinlock.c:  if(--cpu->ncli < 0)
+spinlock.c:  if(cpu->ncli == 0 && cpu->intena)
+spinlock.d:spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file spinlock.o matches
+spinp:if [ $# != 1 ] || [ ! -f "$1" ]; then
+spinp:rm -f $1.trail
+spinp:spin -a $1 || exit 1
+spinp:cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
+spinp:pan -i
+spinp:if [ -f $1.trail ]; then
+spinp:	spin -t -p $1
+Binary file _stressfs matches
+stressfs.asm:_stressfs:     file format elf32-i386
+stressfs.asm: 153:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+stressfs.asm: 15c:	88 5a ff             	mov    %bl,-0x1(%edx)
+stressfs.asm:  return (uchar)*p - (uchar)*q;
+stressfs.asm:  return (uchar)*p - (uchar)*q;
+stressfs.asm: 25b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+stressfs.asm: 27c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+stressfs.asm: 287:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+stressfs.asm:    return -1;
+stressfs.asm:    return -1;
+stressfs.asm:    return -1;
+stressfs.asm: 30a:	8d 42 d0             	lea    -0x30(%edx),%eax
+stressfs.asm:    n = n*10 + *s++ - '0';
+stressfs.asm: 31e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+stressfs.asm: 325:	8d 5a d0             	lea    -0x30(%edx),%ebx
+stressfs.asm:    n = n*10 + *s++ - '0';
+stressfs.asm:  while(n-- > 0)
+stressfs.asm:  while(n-- > 0)
+stressfs.asm:  while(n-- > 0)
+stressfs.asm:    x = -xx;
+stressfs.asm: 44d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+stressfs.asm: 454:	89 75 c0             	mov    %esi,-0x40(%ebp)
+stressfs.asm:    x = -xx;
+stressfs.asm: 45b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+stressfs.asm: 477:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+stressfs.asm: 47c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+stressfs.asm:    buf[i++] = '-';
+stressfs.asm: 486:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+stressfs.asm:  while(--i >= 0)
+stressfs.asm: 48b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+stressfs.asm: 490:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+stressfs.asm: 4a7:	88 45 d7             	mov    %al,-0x29(%ebp)
+stressfs.asm:    buf[i++] = '-';
+stressfs.asm:  while(--i >= 0)
+stressfs.asm:    x = -xx;
+stressfs.asm: 4c4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+stressfs.asm: 4e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+stressfs.asm: 501:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+stressfs.asm: 513:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+stressfs.asm: 51e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+stressfs.asm: 568:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+stressfs.asm: 57f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+stressfs.asm: 582:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+stressfs.asm: 58b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+stressfs.asm: 58e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+stressfs.asm: 5a0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+stressfs.asm: 5a8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+stressfs.asm: 5d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+stressfs.asm: 5ea:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+stressfs.asm: 5f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+stressfs.asm: 5fb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+stressfs.asm: 618:	88 45 e3             	mov    %al,-0x1d(%ebp)
+stressfs.asm: 61b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+stressfs.asm: 648:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+stressfs.asm: 65c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+stressfs.asm: 670:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+stressfs.asm: 68b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+stressfs.asm: 694:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+stressfs.asm: 6a6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+stressfs.asm: 6a9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+stressfs.asm: 6b5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm: 6d0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+stressfs.asm: 6f0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm: 6fa:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:  bp = (Header*)ap - 1;
+stressfs.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+stressfs.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+stressfs.asm:  if(bp + bp->s.size == p->s.ptr){
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm: 71b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm: 722:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm: 72f:	03 4b fc             	add    -0x4(%ebx),%ecx
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:    bp->s.size += p->s.ptr->s.size;
+stressfs.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+stressfs.asm:    bp->s.ptr = p->s.ptr;
+stressfs.asm:  if(p + p->s.size == bp){
+stressfs.asm:    p->s.size += bp->s.size;
+stressfs.asm:    p->s.ptr = bp->s.ptr;
+stressfs.asm: 73a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+stressfs.asm:    p->s.ptr = bp;
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm: 788:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:        p->s.size = nunits;
+stressfs.asm: 7a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+stressfs.asm:  if(p == (char*)-1)
+stressfs.asm:  hp->s.size = nu;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:      if(p->s.size == nunits)
+stressfs.asm:        prevp->s.ptr = p->s.ptr;
+stressfs.asm:        p->s.size -= nunits;
+stressfs.asm:        p += p->s.size;
+stressfs.asm:        p->s.size = nunits;
+stressfs.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+stressfs.asm:    if(p->s.size >= nunits){
+stressfs.asm:      if(p->s.size == nunits)
+stressfs.asm:        prevp->s.ptr = p->s.ptr;
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+stressfs.asm:    return newThread->tid;
+stressfs.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+stressfs.asm:    return newThread->tid;
+stressfs.asm:    thread->state=RUNNABLE;
+stressfs.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+stressfs.asm:    thread->state=RUNNABLE;
+stressfs.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+stressfs.asm:	ttable.threads[i]->state=RUNNABLE;
+stressfs.asm:    thread->state=RUNNABLE;
+stressfs.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+stressfs.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+stressfs.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+stressfs.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+stressfs.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+stressfs.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+stressfs.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+stressfs.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+stressfs.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+stressfs.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+stressfs.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+stressfs.asm:  //1. store tf in the thread->btf
+stressfs.asm:  *thread->btf = tf;
+stressfs.asm:  if(nextThread->isFirstRun==1){
+stressfs.asm:    //move the tf that is stored in nextThread->btf to the stack
+stressfs.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+stressfs.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+stressfs.asm:  nextThread->state=RUNNING;
+stressfs.asm:  nextThread->isFirstRun=0;
+stressfs.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+stressfs.asm:  nextThread->state=RUNNING;
+stressfs.asm:  nextThread->isFirstRun=0;
+stressfs.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+stressfs.asm:    thread->state=RUNNABLE;
+stressfs.asm:  *thread->btf = tf;
+stressfs.asm:  if(nextThread->isFirstRun==1){
+stressfs.asm: 9f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+stressfs.asm: 9fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+stressfs.asm:    ntf->esp=nextThread->btf->esp;
+stressfs.asm:    ntf->eip=nextThread->btf->eip;
+stressfs.asm:      //ttable.threads[i]->utstack=0;
+stressfs.asm:      //ttable.threads[i]->tid=0;
+stressfs.asm:      //ttable.threads[i]->esp=0;
+stressfs.asm:      //ttable.threads[i]->ebp=0;
+stressfs.asm:      //ttable.threads[i]->eip=0;
+stressfs.asm:      ttable.threads[i]->state=EMPTY;
+stressfs.asm:      //ttable.threads[i]->sleepTime=0
+stressfs.asm:      //ttable.threads[i]->sleepInit=0;
+stressfs.asm:      ttable.threads[i]->isFirstRun=1;
+stressfs.asm:      //ttable.threads[i]->btf=0;
+stressfs.asm:      //ttable.threads[i]->waitingExitTid=0;
+stressfs.asm:    thread->tid = threadTidCounter;
+stressfs.asm:    thread->state = RUNNING;
+stressfs.asm:      //ttable.threads[i]->btf=0;
+stressfs.asm:      //ttable.threads[i]->waitingExitTid=0;
+stressfs.asm:    thread->tid = threadTidCounter;
+stressfs.asm:    thread->state = RUNNING;
+stressfs.asm:    thread->tid = threadTidCounter;
+stressfs.asm:    thread->state = RUNNING;
+stressfs.asm:        return -1;*/
+stressfs.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+stressfs.asm:      //ttable.threads[i]->btf=0;
+stressfs.asm:      //ttable.threads[i]->waitingExitTid=0;
+stressfs.asm:    thread->tid = threadTidCounter;
+stressfs.asm:    thread->state = RUNNING;
+stressfs.asm:        return -1;*/
+stressfs.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+stressfs.asm:      return -1;
+stressfs.asm:        return -1;*/
+stressfs.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+stressfs.asm:      return -1;
+stressfs.asm:    if (threadNum == MAX_UTHREADS - 1) 
+stressfs.asm:        return -1;
+stressfs.asm:      if(ttable.threads[i]->state==EMPTY){
+stressfs.asm:    newThread->tid = threadTidCounter;
+stressfs.asm:    newThread->tid = threadTidCounter;
+stressfs.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+stressfs.asm:    newThread->tid = threadTidCounter;
+stressfs.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+stressfs.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+stressfs.asm:    esp -= 4;
+stressfs.asm:    newThread->tid = threadTidCounter;
+stressfs.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+stressfs.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+stressfs.asm:    esp -= 4;
+stressfs.asm:    esp -= 4;
+stressfs.asm:    newThread->btf->esp=esp-3*sizeof(int);
+stressfs.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+stressfs.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+stressfs.asm:    esp -= 4;
+stressfs.asm:    esp -= 4;
+stressfs.asm:    newThread->btf->esp=esp-3*sizeof(int);
+stressfs.asm:    newThread->btf->eip=(int)start_func;
+stressfs.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+stressfs.asm:    newThread->eip=(int)start_func;//
+stressfs.asm:    newThread->state = RUNNABLE;
+stressfs.asm:    return newThread->tid;
+stressfs.asm:    if (threadNum == MAX_UTHREADS - 1) 
+stressfs.asm:        return -1;
+stressfs.asm:    return thread->tid;
+stressfs.asm:    return thread->tid;
+stressfs.asm:    return thread->tid;
+stressfs.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+stressfs.asm:    return thread->tid;
+stressfs.asm:      if(ttable.threads[i]->tid==tid){
+stressfs.asm:      return -1; 
+stressfs.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+stressfs.asm:      return -1; 
+stressfs.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+stressfs.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+stressfs.asm:    thread->waitingExitTid=tid;
+stressfs.asm:    thread->state=BLOCKED;
+stressfs.asm:      return -1; 
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:	return -1;
+stressfs.asm:    thread->state=BLOCKED;
+stressfs.asm:    thread->sleepInit=uptime();
+stressfs.asm:    thread->sleepTime=ticks;
+stressfs.asm:	return -1;
+stressfs.asm:    thread->state=BLOCKED;
+stressfs.asm:    thread->sleepInit=uptime();
+stressfs.asm:    thread->sleepTime=ticks;
+stressfs.asm:	return -1;
+stressfs.asm:    free(th->utstack);
+stressfs.asm:    th->tid=0;
+stressfs.asm:    th->esp=0;
+stressfs.asm:    th->ebp=0;
+stressfs.asm:    th->eip=0;
+stressfs.asm:    th->state=EMPTY;
+stressfs.asm:    th->sleepTime=0;
+stressfs.asm:    th->sleepInit=0;
+stressfs.asm:    th->isFirstRun=1;
+stressfs.asm:    th->btf=0;
+stressfs.asm:    th->waitingExitTid=0;
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:    th->isFirstRun=1;
+stressfs.asm:    th->btf=0;
+stressfs.asm:    th->waitingExitTid=0;
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+stressfs.asm:      if(ttable.threads[i]->state==RUNNABLE){
+stressfs.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+stressfs.asm:	ttable.threads[i]->state=RUNNABLE;
+stressfs.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+stressfs.asm:	ttable.threads[i]->state=RUNNABLE;
+stressfs.asm:    threadsCounter--;
+stressfs.asm:    threadsCounter--;
+stressfs.d:stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h \
+Binary file stressfs.o matches
+string.c:  while(n-- > 0){
+string.c:      return *s1 - *s2;
+string.c:    while(n-- > 0)
+string.c:      *--d = *--s;
+string.c:    while(n-- > 0)
+string.c:    n--, p++, q++;
+string.c:  return (uchar)*p - (uchar)*q;
+string.c:  while(n-- > 0 && (*s++ = *t++) != 0)
+string.c:  while(n-- > 0)
+string.c:// Like strncpy but guaranteed to NUL-terminate.
+string.c:  while(--n > 0 && (*s++ = *t++) != 0)
+string.d:string.o: string.c /usr/include/stdc-predef.h types.h x86.h
+Binary file string.o matches
+swtch.S:  # Save old callee-save registers
+swtch.S:  # Load new callee-save registers
+symlink.patch:diff -r f8a4e40ab1d6 fs.c
+symlink.patch:--- a/fs.c	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/fs.c	Thu Aug 30 14:29:02 2007 -0400
+symlink.patch:@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
+symlink.patch:-_namei(char *path, int parent, char *name)
+symlink.patch:     ip = idup(cp->cwd);
+symlink.patch:@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
+symlink.patch:-    iunlockput(ip);
+symlink.patch:+    if(next->type == T_SYMLINK){
+symlink.patch:+      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
+symlink.patch:+      buf[next->size] = 0;
+symlink.patch:@@ -615,11 +635,11 @@ namei(char *path)
+symlink.patch:-  return _namei(path, 0, name);
+symlink.patch:-  return _namei(path, 1, name);
+symlink.patch:-}
+symlink.patch:diff -r f8a4e40ab1d6 fs.h
+symlink.patch:--- a/fs.h	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400
+symlink.patch:@@ -33,6 +33,7 @@ struct dinode {
+symlink.patch:diff -r f8a4e40ab1d6 syscall.c
+symlink.patch:--- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/syscall.c	Thu Aug 30 13:05:29 2007 -0400
+symlink.patch:@@ -96,6 +96,7 @@ extern int sys_unlink(void);
+symlink.patch:@@ -118,6 +119,7 @@ static int (*syscalls[])(void) = {
+symlink.patch:diff -r f8a4e40ab1d6 syscall.h
+symlink.patch:--- a/syscall.h	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/syscall.h	Thu Aug 30 13:02:48 2007 -0400
+symlink.patch:@@ -19,3 +19,4 @@
+symlink.patch:diff -r f8a4e40ab1d6 sysfile.c
+symlink.patch:--- a/sysfile.c	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/sysfile.c	Thu Aug 30 13:10:31 2007 -0400
+symlink.patch:@@ -257,6 +257,21 @@ create(char *path, int canexist, short t
+symlink.patch:+    return -1;
+symlink.patch:+    return -1;
+symlink.patch:@@ -393,3 +408,4 @@ sys_pipe(void)
+symlink.patch:diff -r f8a4e40ab1d6 user.h
+symlink.patch:--- a/user.h	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/user.h	Thu Aug 30 13:02:34 2007 -0400
+symlink.patch:@@ -21,6 +21,7 @@ int getpid();
+symlink.patch:diff -r f8a4e40ab1d6 usys.S
+symlink.patch:--- a/usys.S	Thu Aug 30 14:32:06 2007 -0400
+symlink.patch:+++ b/usys.S	Thu Aug 30 13:05:54 2007 -0400
+symlink.patch:@@ -28,3 +28,4 @@ STUB(getpid)
+syscall.c:  if(addr >= proc->sz || addr+4 > proc->sz)
+syscall.c:    return -1;
+syscall.c:// Fetch the nul-terminated string at addr from the current process.
+syscall.c:// Doesn't actually copy the string - just sets *pp to point at it.
+syscall.c:  if(addr >= proc->sz)
+syscall.c:    return -1;
+syscall.c:  ep = (char*)proc->sz;
+syscall.c:      return s - *pp;
+syscall.c:  return -1;
+syscall.c:// Fetch the nth 32-bit system call argument.
+syscall.c:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+syscall.c:// Fetch the nth word-sized system call argument as a pointer
+syscall.c:    return -1;
+syscall.c:  if(size < 0 || (uint)i >= proc->sz || (uint)i+size > proc->sz)
+syscall.c:    return -1;
+syscall.c:// Fetch the nth word-sized system call argument as a string pointer.
+syscall.c:// Check that the pointer is valid and the string is nul-terminated.
+syscall.c:    return -1;
+syscall.c:  num = proc->tf->eax;
+syscall.c:    proc->tf->eax = syscalls[num]();
+syscall.c:            proc->pid, proc->name, num);
+syscall.c:    proc->tf->eax = -1;
+syscall.d:syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file syscall.o matches
+sysfile.c:// File-system system calls.
+sysfile.c:// Fetch the nth word-sized system call argument as a file descriptor
+sysfile.c:    return -1;
+sysfile.c:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
+sysfile.c:    return -1;
+sysfile.c:    if(proc->ofile[fd] == 0){
+sysfile.c:      proc->ofile[fd] = f;
+sysfile.c:  return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:  proc->ofile[fd] = 0;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:  if(ip->type == T_DIR){
+sysfile.c:    return -1;
+sysfile.c:  ip->nlink++;
+sysfile.c:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+sysfile.c:  ip->nlink--;
+sysfile.c:  return -1;
+sysfile.c:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:  if(ip->nlink < 1)
+sysfile.c:  if(ip->type == T_DIR && !isdirempty(ip)){
+sysfile.c:  if(ip->type == T_DIR){
+sysfile.c:    dp->nlink--;
+sysfile.c:  ip->nlink--;
+sysfile.c:  return -1;
+sysfile.c:    if(type == T_FILE && ip->type == T_FILE)
+sysfile.c:  if((ip = ialloc(dp->dev, type)) == 0)
+sysfile.c:  ip->major = major;
+sysfile.c:  ip->minor = minor;
+sysfile.c:  ip->nlink = 1;
+sysfile.c:    dp->nlink++;  // for ".."
+sysfile.c:    // No ip->nlink++ for ".": avoid cyclic ref count.
+sysfile.c:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+sysfile.c:  if(dirlink(dp, name, ip->inum) < 0)
+sysfile.c:    return -1;
+sysfile.c:      return -1;
+sysfile.c:      return -1;
+sysfile.c:    if(ip->type == T_DIR && omode != O_RDONLY){
+sysfile.c:      return -1;
+sysfile.c:    return -1;
+sysfile.c:  f->type = FD_INODE;
+sysfile.c:  f->ip = ip;
+sysfile.c:  f->off = 0;
+sysfile.c:  f->readable = !(omode & O_WRONLY);
+sysfile.c:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:  if(ip->type != T_DIR){
+sysfile.c:    return -1;
+sysfile.c:  iput(proc->cwd);
+sysfile.c:  proc->cwd = ip;
+sysfile.c:    return -1;
+sysfile.c:      return -1;
+sysfile.c:      return -1;
+sysfile.c:      return -1;
+sysfile.c:    return -1;
+sysfile.c:    return -1;
+sysfile.c:  fd0 = -1;
+sysfile.c:      proc->ofile[fd0] = 0;
+sysfile.c:    return -1;
+sysfile.d:sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file sysfile.o matches
+sysproc.c:    return -1;
+sysproc.c:  return proc->pid;
+sysproc.c:    return -1;
+sysproc.c:  addr = proc->sz;
+sysproc.c:    return -1;
+sysproc.c:    return -1;
+sysproc.c:  while(ticks - ticks0 < n){
+sysproc.c:    if(proc->killed){
+sysproc.c:      return -1;
+sysproc.c:        return -1;
+sysproc.c:        return -1;
+sysproc.c:        return -1;
+sysproc.d:sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h \
+Binary file sysproc.o matches
+Binary file _t2 matches
+t2.asm:_t2:     file format elf32-i386
+t2.asm:	printf(1,"-=-=-=-=-=-=-=-=-=-=-TEXT USER LEVEL THREAD-=-=-=-=-=-=-=-=-=-=-\n");
+t2.asm: 163:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+t2.asm: 16c:	88 5a ff             	mov    %bl,-0x1(%edx)
+t2.asm:  return (uchar)*p - (uchar)*q;
+t2.asm:  return (uchar)*p - (uchar)*q;
+t2.asm: 26b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+t2.asm: 28c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+t2.asm: 297:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+t2.asm:    return -1;
+t2.asm:    return -1;
+t2.asm:    return -1;
+t2.asm: 31a:	8d 42 d0             	lea    -0x30(%edx),%eax
+t2.asm:    n = n*10 + *s++ - '0';
+t2.asm: 32e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+t2.asm: 335:	8d 5a d0             	lea    -0x30(%edx),%ebx
+t2.asm:    n = n*10 + *s++ - '0';
+t2.asm:  while(n-- > 0)
+t2.asm:  while(n-- > 0)
+t2.asm:  while(n-- > 0)
+t2.asm:    x = -xx;
+t2.asm: 45d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+t2.asm: 464:	89 75 c0             	mov    %esi,-0x40(%ebp)
+t2.asm:    x = -xx;
+t2.asm: 46b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+t2.asm: 487:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+t2.asm: 48c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+t2.asm:    buf[i++] = '-';
+t2.asm: 496:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+t2.asm:  while(--i >= 0)
+t2.asm: 49b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+t2.asm: 4a0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+t2.asm: 4b7:	88 45 d7             	mov    %al,-0x29(%ebp)
+t2.asm:    buf[i++] = '-';
+t2.asm:  while(--i >= 0)
+t2.asm:    x = -xx;
+t2.asm: 4d4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+t2.asm: 4f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+t2.asm: 511:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+t2.asm: 523:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+t2.asm: 52e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+t2.asm: 578:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+t2.asm: 58f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+t2.asm: 592:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+t2.asm: 59b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+t2.asm: 59e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+t2.asm: 5b0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+t2.asm: 5b8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+t2.asm: 5e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+t2.asm: 5fa:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+t2.asm: 608:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+t2.asm: 60b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+t2.asm: 628:	88 45 e3             	mov    %al,-0x1d(%ebp)
+t2.asm: 62b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+t2.asm: 658:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+t2.asm: 66c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+t2.asm: 680:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+t2.asm: 69b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+t2.asm: 6a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+t2.asm: 6b6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+t2.asm: 6b9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+t2.asm: 6c5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm: 6e0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+t2.asm:  if(bp + bp->s.size == p->s.ptr){
+t2.asm: 700:	8b 73 fc             	mov    -0x4(%ebx),%esi
+t2.asm:    bp->s.size += p->s.ptr->s.size;
+t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+t2.asm:    bp->s.ptr = p->s.ptr;
+t2.asm: 70a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+t2.asm:  if(p + p->s.size == bp){
+t2.asm:    p->s.size += bp->s.size;
+t2.asm:    p->s.ptr = bp->s.ptr;
+t2.asm:    p->s.ptr = bp;
+t2.asm:  bp = (Header*)ap - 1;
+t2.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+t2.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+t2.asm:  if(bp + bp->s.size == p->s.ptr){
+t2.asm:    bp->s.size += p->s.ptr->s.size;
+t2.asm: 72b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+t2.asm: 732:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+t2.asm:    bp->s.ptr = p->s.ptr;
+t2.asm:  if(p + p->s.size == bp){
+t2.asm:    p->s.size += bp->s.size;
+t2.asm: 73f:	03 4b fc             	add    -0x4(%ebx),%ecx
+t2.asm:    p->s.ptr = bp->s.ptr;
+t2.asm:    p->s.ptr = bp;
+t2.asm:    bp->s.size += p->s.ptr->s.size;
+t2.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+t2.asm:    bp->s.ptr = p->s.ptr;
+t2.asm:  if(p + p->s.size == bp){
+t2.asm:    p->s.size += bp->s.size;
+t2.asm:    p->s.ptr = bp->s.ptr;
+t2.asm: 74a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+t2.asm:    p->s.ptr = bp;
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+t2.asm:    if(p->s.size >= nunits){
+t2.asm: 798:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+t2.asm:    if(p->s.size >= nunits){
+t2.asm:        p->s.size = nunits;
+t2.asm: 7b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+t2.asm:  if(p == (char*)-1)
+t2.asm:  hp->s.size = nu;
+t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+t2.asm:    if(p->s.size >= nunits){
+t2.asm:      if(p->s.size == nunits)
+t2.asm:        prevp->s.ptr = p->s.ptr;
+t2.asm:        p->s.size -= nunits;
+t2.asm:        p += p->s.size;
+t2.asm:        p->s.size = nunits;
+t2.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+t2.asm:    if(p->s.size >= nunits){
+t2.asm:      if(p->s.size == nunits)
+t2.asm:        prevp->s.ptr = p->s.ptr;
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+t2.asm:    return newThread->tid;
+t2.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+t2.asm:    return newThread->tid;
+t2.asm:    thread->state=RUNNABLE;
+t2.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+t2.asm:    thread->state=RUNNABLE;
+t2.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+t2.asm:	ttable.threads[i]->state=RUNNABLE;
+t2.asm:    thread->state=RUNNABLE;
+t2.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+t2.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+t2.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+t2.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+t2.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+t2.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+t2.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+t2.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+t2.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+t2.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+t2.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+t2.asm:  //1. store tf in the thread->btf
+t2.asm:  *thread->btf = tf;
+t2.asm:  if(nextThread->isFirstRun==1){
+t2.asm:    //move the tf that is stored in nextThread->btf to the stack
+t2.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+t2.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+t2.asm:  nextThread->state=RUNNING;
+t2.asm:  nextThread->isFirstRun=0;
+t2.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+t2.asm:  nextThread->state=RUNNING;
+t2.asm:  nextThread->isFirstRun=0;
+t2.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+t2.asm:    thread->state=RUNNABLE;
+t2.asm:  *thread->btf = tf;
+t2.asm:  if(nextThread->isFirstRun==1){
+t2.asm: a03:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+t2.asm: a0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+t2.asm:    ntf->esp=nextThread->btf->esp;
+t2.asm:    ntf->eip=nextThread->btf->eip;
+t2.asm:      //ttable.threads[i]->utstack=0;
+t2.asm:      //ttable.threads[i]->tid=0;
+t2.asm:      //ttable.threads[i]->esp=0;
+t2.asm:      //ttable.threads[i]->ebp=0;
+t2.asm:      //ttable.threads[i]->eip=0;
+t2.asm:      ttable.threads[i]->state=EMPTY;
+t2.asm:      //ttable.threads[i]->sleepTime=0
+t2.asm:      //ttable.threads[i]->sleepInit=0;
+t2.asm:      ttable.threads[i]->isFirstRun=1;
+t2.asm:      //ttable.threads[i]->btf=0;
+t2.asm:      //ttable.threads[i]->waitingExitTid=0;
+t2.asm:    thread->tid = threadTidCounter;
+t2.asm:    thread->state = RUNNING;
+t2.asm:      //ttable.threads[i]->btf=0;
+t2.asm:      //ttable.threads[i]->waitingExitTid=0;
+t2.asm:    thread->tid = threadTidCounter;
+t2.asm:    thread->state = RUNNING;
+t2.asm:    thread->tid = threadTidCounter;
+t2.asm:    thread->state = RUNNING;
+t2.asm:        return -1;*/
+t2.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+t2.asm:      //ttable.threads[i]->btf=0;
+t2.asm:      //ttable.threads[i]->waitingExitTid=0;
+t2.asm:    thread->tid = threadTidCounter;
+t2.asm:    thread->state = RUNNING;
+t2.asm:        return -1;*/
+t2.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+t2.asm:      return -1;
+t2.asm:        return -1;*/
+t2.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+t2.asm:      return -1;
+t2.asm:    if (threadNum == MAX_UTHREADS - 1) 
+t2.asm:        return -1;
+t2.asm:      if(ttable.threads[i]->state==EMPTY){
+t2.asm:    newThread->tid = threadTidCounter;
+t2.asm:    newThread->tid = threadTidCounter;
+t2.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+t2.asm:    newThread->tid = threadTidCounter;
+t2.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+t2.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+t2.asm:    esp -= 4;
+t2.asm:    newThread->tid = threadTidCounter;
+t2.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+t2.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+t2.asm:    esp -= 4;
+t2.asm:    esp -= 4;
+t2.asm:    newThread->btf->esp=esp-3*sizeof(int);
+t2.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+t2.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+t2.asm:    esp -= 4;
+t2.asm:    esp -= 4;
+t2.asm:    newThread->btf->esp=esp-3*sizeof(int);
+t2.asm:    newThread->btf->eip=(int)start_func;
+t2.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+t2.asm:    newThread->eip=(int)start_func;//
+t2.asm:    newThread->state = RUNNABLE;
+t2.asm:    return newThread->tid;
+t2.asm:    if (threadNum == MAX_UTHREADS - 1) 
+t2.asm:        return -1;
+t2.asm:    return thread->tid;
+t2.asm:    return thread->tid;
+t2.asm:    return thread->tid;
+t2.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+t2.asm:    return thread->tid;
+t2.asm:      if(ttable.threads[i]->tid==tid){
+t2.asm:      return -1; 
+t2.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+t2.asm:      return -1; 
+t2.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+t2.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+t2.asm:    thread->waitingExitTid=tid;
+t2.asm:    thread->state=BLOCKED;
+t2.asm:      return -1; 
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:	return -1;
+t2.asm:    thread->state=BLOCKED;
+t2.asm:    thread->sleepInit=uptime();
+t2.asm:    thread->sleepTime=ticks;
+t2.asm:	return -1;
+t2.asm:    thread->state=BLOCKED;
+t2.asm:    thread->sleepInit=uptime();
+t2.asm:    thread->sleepTime=ticks;
+t2.asm:	return -1;
+t2.asm:    free(th->utstack);
+t2.asm:    th->tid=0;
+t2.asm:    th->esp=0;
+t2.asm:    th->ebp=0;
+t2.asm:    th->eip=0;
+t2.asm:    th->state=EMPTY;
+t2.asm:    th->sleepTime=0;
+t2.asm:    th->sleepInit=0;
+t2.asm:    th->isFirstRun=1;
+t2.asm:    th->btf=0;
+t2.asm:    th->waitingExitTid=0;
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:    th->isFirstRun=1;
+t2.asm:    th->btf=0;
+t2.asm:    th->waitingExitTid=0;
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+t2.asm:      if(ttable.threads[i]->state==RUNNABLE){
+t2.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+t2.asm:	ttable.threads[i]->state=RUNNABLE;
+t2.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+t2.asm:	ttable.threads[i]->state=RUNNABLE;
+t2.asm:    threadsCounter--;
+t2.asm:    threadsCounter--;
+t2.c:	printf(1,"-=-=-=-=-=-=-=-=-=-=-TEXT USER LEVEL THREAD-=-=-=-=-=-=-=-=-=-=-\n");
+t2.c~:	printf(1,"-=-=-=-=-=-=-=-=-=-=-TEXT USER LEVEL THREAD-=-=-=-=-=-=-=-=-=-=-\n");
+t2.d:t2.o: t2.c /usr/include/stdc-predef.h types.h user.h stat.h thread.h
+Binary file t2.o matches
+Binary file _thread matches
+thread.asm:_thread:     file format elf32-i386
+thread.asm:    return newThread->tid;
+thread.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+thread.asm:    return newThread->tid;
+thread.asm:    thread->state=RUNNABLE;
+thread.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+thread.asm:    thread->state=RUNNABLE;
+thread.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+thread.asm:	ttable.threads[i]->state=RUNNABLE;
+thread.asm:    thread->state=RUNNABLE;
+thread.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+thread.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+thread.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+thread.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+thread.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+thread.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+thread.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+thread.asm:  //1. store tf in the thread->btf
+thread.asm:  *thread->btf = tf;
+thread.asm:  if(nextThread->isFirstRun==1){
+thread.asm:    //move the tf that is stored in nextThread->btf to the stack
+thread.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+thread.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+thread.asm:  nextThread->state=RUNNING;
+thread.asm:  nextThread->isFirstRun=0;
+thread.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+thread.asm:  nextThread->state=RUNNING;
+thread.asm:  nextThread->isFirstRun=0;
+thread.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+thread.asm:    thread->state=RUNNABLE;
+thread.asm:  *thread->btf = tf;
+thread.asm:  if(nextThread->isFirstRun==1){
+thread.asm: 1b3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+thread.asm: 1bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+thread.asm:    ntf->esp=nextThread->btf->esp;
+thread.asm:    ntf->eip=nextThread->btf->eip;
+thread.asm:      //ttable.threads[i]->utstack=0;
+thread.asm:      //ttable.threads[i]->tid=0;
+thread.asm:      //ttable.threads[i]->esp=0;
+thread.asm:      //ttable.threads[i]->ebp=0;
+thread.asm:      //ttable.threads[i]->eip=0;
+thread.asm:      ttable.threads[i]->state=EMPTY;
+thread.asm:      //ttable.threads[i]->sleepTime=0
+thread.asm:      //ttable.threads[i]->sleepInit=0;
+thread.asm:      ttable.threads[i]->isFirstRun=1;
+thread.asm:      //ttable.threads[i]->btf=0;
+thread.asm:      //ttable.threads[i]->waitingExitTid=0;
+thread.asm:    thread->tid = threadTidCounter;
+thread.asm:    thread->state = RUNNING;
+thread.asm:      //ttable.threads[i]->btf=0;
+thread.asm:      //ttable.threads[i]->waitingExitTid=0;
+thread.asm:    thread->tid = threadTidCounter;
+thread.asm:    thread->state = RUNNING;
+thread.asm:    thread->tid = threadTidCounter;
+thread.asm:    thread->state = RUNNING;
+thread.asm:        return -1;*/
+thread.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+thread.asm:      //ttable.threads[i]->btf=0;
+thread.asm:      //ttable.threads[i]->waitingExitTid=0;
+thread.asm:    thread->tid = threadTidCounter;
+thread.asm:    thread->state = RUNNING;
+thread.asm:        return -1;*/
+thread.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+thread.asm:      return -1;
+thread.asm:        return -1;*/
+thread.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+thread.asm:      return -1;
+thread.asm:    if (threadNum == MAX_UTHREADS - 1) 
+thread.asm:        return -1;
+thread.asm:      if(ttable.threads[i]->state==EMPTY){
+thread.asm:    newThread->tid = threadTidCounter;
+thread.asm:    newThread->tid = threadTidCounter;
+thread.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+thread.asm:    newThread->tid = threadTidCounter;
+thread.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+thread.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+thread.asm:    esp -= 4;
+thread.asm:    newThread->tid = threadTidCounter;
+thread.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+thread.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+thread.asm:    esp -= 4;
+thread.asm:    esp -= 4;
+thread.asm:    newThread->btf->esp=esp-3*sizeof(int);
+thread.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+thread.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+thread.asm:    esp -= 4;
+thread.asm:    esp -= 4;
+thread.asm:    newThread->btf->esp=esp-3*sizeof(int);
+thread.asm:    newThread->btf->eip=(int)start_func;
+thread.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+thread.asm:    newThread->eip=(int)start_func;//
+thread.asm:    newThread->state = RUNNABLE;
+thread.asm:    return newThread->tid;
+thread.asm:    if (threadNum == MAX_UTHREADS - 1) 
+thread.asm:        return -1;
+thread.asm:    return thread->tid;
+thread.asm:    return thread->tid;
+thread.asm:    return thread->tid;
+thread.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+thread.asm:    return thread->tid;
+thread.asm:      if(ttable.threads[i]->tid==tid){
+thread.asm:      return -1; 
+thread.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+thread.asm:      return -1; 
+thread.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+thread.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+thread.asm:    thread->waitingExitTid=tid;
+thread.asm:    thread->state=BLOCKED;
+thread.asm:      return -1; 
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:	return -1;
+thread.asm:    thread->state=BLOCKED;
+thread.asm:    thread->sleepInit=uptime();
+thread.asm:    thread->sleepTime=ticks;
+thread.asm:	return -1;
+thread.asm:    thread->state=BLOCKED;
+thread.asm:    thread->sleepInit=uptime();
+thread.asm:    thread->sleepTime=ticks;
+thread.asm:	return -1;
+thread.asm:    free(th->utstack);
+thread.asm:    th->tid=0;
+thread.asm:    th->esp=0;
+thread.asm:    th->ebp=0;
+thread.asm:    th->eip=0;
+thread.asm:    th->state=EMPTY;
+thread.asm:    th->sleepTime=0;
+thread.asm:    th->sleepInit=0;
+thread.asm:    th->isFirstRun=1;
+thread.asm:    th->btf=0;
+thread.asm:    th->waitingExitTid=0;
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:    th->isFirstRun=1;
+thread.asm:    th->btf=0;
+thread.asm:    th->waitingExitTid=0;
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+thread.asm:      if(ttable.threads[i]->state==RUNNABLE){
+thread.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+thread.asm:	ttable.threads[i]->state=RUNNABLE;
+thread.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+thread.asm:	ttable.threads[i]->state=RUNNABLE;
+thread.asm:    threadsCounter--;
+thread.asm:    threadsCounter--;
+thread.asm: 633:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+thread.asm: 63c:	88 5a ff             	mov    %bl,-0x1(%edx)
+thread.asm:  return (uchar)*p - (uchar)*q;
+thread.asm:  return (uchar)*p - (uchar)*q;
+thread.asm: 73b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+thread.asm: 75c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+thread.asm: 767:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+thread.asm:    return -1;
+thread.asm:    return -1;
+thread.asm:    return -1;
+thread.asm: 7ea:	8d 42 d0             	lea    -0x30(%edx),%eax
+thread.asm:    n = n*10 + *s++ - '0';
+thread.asm: 7fe:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+thread.asm: 805:	8d 5a d0             	lea    -0x30(%edx),%ebx
+thread.asm:    n = n*10 + *s++ - '0';
+thread.asm:  while(n-- > 0)
+thread.asm:  while(n-- > 0)
+thread.asm:  while(n-- > 0)
+thread.asm:    x = -xx;
+thread.asm: 92d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+thread.asm: 934:	89 75 c0             	mov    %esi,-0x40(%ebp)
+thread.asm:    x = -xx;
+thread.asm: 93b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+thread.asm: 957:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+thread.asm: 95c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+thread.asm:    buf[i++] = '-';
+thread.asm: 966:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+thread.asm:  while(--i >= 0)
+thread.asm: 96b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+thread.asm: 970:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+thread.asm: 987:	88 45 d7             	mov    %al,-0x29(%ebp)
+thread.asm:    buf[i++] = '-';
+thread.asm:  while(--i >= 0)
+thread.asm:    x = -xx;
+thread.asm: 9a4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+thread.asm: 9c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+thread.asm: 9e1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+thread.asm: 9f3:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+thread.asm: 9fe:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+thread.asm: a48:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+thread.asm: a5f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+thread.asm: a62:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+thread.asm: a6b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+thread.asm: a6e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+thread.asm: a80:	88 55 e7             	mov    %dl,-0x19(%ebp)
+thread.asm: a88:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+thread.asm: ab0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+thread.asm: aca:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+thread.asm: ad8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+thread.asm: adb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+thread.asm: af8:	88 45 e3             	mov    %al,-0x1d(%ebp)
+thread.asm: afb:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+thread.asm: b28:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+thread.asm: b3c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+thread.asm: b50:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+thread.asm: b6b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+thread.asm: b74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+thread.asm: b86:	88 45 e4             	mov    %al,-0x1c(%ebp)
+thread.asm: b89:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+thread.asm: b95:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm: bb0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  if(bp + bp->s.size == p->s.ptr){
+thread.asm: bd0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm: bda:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm:    p->s.ptr = bp;
+thread.asm:  bp = (Header*)ap - 1;
+thread.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+thread.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+thread.asm:  if(bp + bp->s.size == p->s.ptr){
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm: bfb:	89 73 fc             	mov    %esi,-0x4(%ebx)
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm: c02:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm: c0f:	03 4b fc             	add    -0x4(%ebx),%ecx
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm:    p->s.ptr = bp;
+thread.asm:    bp->s.size += p->s.ptr->s.size;
+thread.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+thread.asm:    bp->s.ptr = p->s.ptr;
+thread.asm:  if(p + p->s.size == bp){
+thread.asm:    p->s.size += bp->s.size;
+thread.asm:    p->s.ptr = bp->s.ptr;
+thread.asm: c1a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+thread.asm:    p->s.ptr = bp;
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm: c68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:        p->s.size = nunits;
+thread.asm: c83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+thread.asm:  if(p == (char*)-1)
+thread.asm:  hp->s.size = nu;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:      if(p->s.size == nunits)
+thread.asm:        prevp->s.ptr = p->s.ptr;
+thread.asm:        p->s.size -= nunits;
+thread.asm:        p += p->s.size;
+thread.asm:        p->s.size = nunits;
+thread.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+thread.asm:    if(p->s.size >= nunits){
+thread.asm:      if(p->s.size == nunits)
+thread.asm:        prevp->s.ptr = p->s.ptr;
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+thread.c:      //ttable.threads[i]->utstack=0;
+thread.c:      //ttable.threads[i]->tid=0;
+thread.c:      //ttable.threads[i]->esp=0;
+thread.c:      //ttable.threads[i]->ebp=0;
+thread.c:      //ttable.threads[i]->eip=0;
+thread.c:      ttable.threads[i]->state=EMPTY;
+thread.c:      //ttable.threads[i]->sleepTime=0
+thread.c:      //ttable.threads[i]->sleepInit=0;
+thread.c:      ttable.threads[i]->isFirstRun=1;
+thread.c:      //ttable.threads[i]->btf=0;
+thread.c:      //ttable.threads[i]->waitingExitTid=0;
+thread.c:    thread->tid = threadTidCounter;
+thread.c:    thread->state = RUNNING;
+thread.c:        return -1;*/
+thread.c:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+thread.c:      return -1;
+thread.c:    if (threadNum == MAX_UTHREADS - 1) 
+thread.c:        return -1;
+thread.c:      if(ttable.threads[i]->state==EMPTY){
+thread.c:    newThread->tid = threadTidCounter;
+thread.c:    newThread->utstack = (char*) malloc(STACK_SIZE);
+thread.c:    int esp = (int)newThread->utstack + STACK_SIZE;
+thread.c:    esp -= 4;
+thread.c:    esp -= 4;
+thread.c:    newThread->btf->esp=esp-3*sizeof(int);
+thread.c:    newThread->btf->eip=(int)start_func;
+thread.c:    *((int*)(newThread->utstack+STACK_SIZE-1*sizeof(int)))=(int)arg; 
+thread.c:    *((int*)(newThread->utstack+STACK_SIZE-2*sizeof(int)))=(int)start_func; 
+thread.c:    *((int*)(newThread->utstack+STACK_SIZE-3*sizeof(int)))=(int)0; 
+thread.c:    // *((int*)(newThread->utstack+STACK_SIZE-1*sizeof(int)))=(int)uthread_exit;
+thread.c:    // *((int*)(newThread->utstack+STACK_SIZE-1*sizeof(int)))=0;//necessary???
+thread.c:    // *((int*)(newThread->ustack+STACK_SIZE-3*sizeof(int)))=0; //necessary? not sure..
+thread.c:    newThread->esp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+thread.c:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+thread.c:    newThread->eip=(int)start_func;//
+thread.c:    newThread->state = RUNNABLE;
+thread.c:    return newThread->tid;
+thread.c:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+thread.c:    thread->state=RUNNABLE;
+thread.c:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+thread.c:	ttable.threads[i]->state=RUNNABLE;
+thread.c:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.c:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+thread.c:  printf(1, "tf->eip is: %d\n", tf.eip);
+thread.c:  printf(1, "tf->esp is: %d\n", tf.esp);
+thread.c:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+thread.c:  //1. store tf in the thread->btf
+thread.c:  *thread->btf = tf;
+thread.c:  if(nextThread->isFirstRun==1){
+thread.c:    ntf->esp=nextThread->btf->esp;
+thread.c:    ntf->eip=nextThread->btf->eip;
+thread.c:    //move the tf that is stored in nextThread->btf to the stack
+thread.c:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+thread.c:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+thread.c:  nextThread->state=RUNNING;
+thread.c:  nextThread->isFirstRun=0;
+thread.c:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+thread.c:    thread->state=RUNNABLE;
+thread.c:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+thread.c:	ttable.threads[i]->state=RUNNABLE;
+thread.c:  for(i=0; i<MAX_UTHREADS-1; i++){
+thread.c:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+thread.c:  thread->btf = malloc(sizeof(struct trapframe));
+thread.c:  *thread->btf= prevTf; //back up the previous tf
+thread.c:  //memmove(&tf, &current_thread->tf,???sizeof(struct trapframe));
+thread.c:  if(nextThread->isFirstRun==1){ //it is the first run of this thread!
+thread.c:    ntf.esp=(int)nextThread->utstack+STACK_SIZE-3*sizeof(int);
+thread.c:    ntf.ebp=(int)nextThread->utstack+STACK_SIZE-3*sizeof(int);
+thread.c:    printf(4, "the values of prevTf- esp: %d, ebp: %d, eip: %d\n", prevTf.esp, prevTf.ebp, prevTf.eip);
+thread.c:    printf(4, "the values of ntf- esp: %d, ebp: %d, eip: %d\n", ntf.esp, ntf.ebp, ntf.eip);
+thread.c:    *(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+thread.c:  nextThread->state=RUNNING;
+thread.c:    nextThread->isFirstRun=0;
+thread.c:    return thread->tid;
+thread.c:      if(ttable.threads[i]->tid==tid){
+thread.c:      return -1; 
+thread.c:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+thread.c:    thread->waitingExitTid=tid;
+thread.c:    thread->state=BLOCKED;
+thread.c:      if(ttable.threads[i]->state==RUNNABLE){
+thread.c:	return -1;
+thread.c:    thread->state=BLOCKED;
+thread.c:    thread->sleepInit=uptime();
+thread.c:    thread->sleepTime=ticks;
+thread.c:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+thread.c:    free(th->utstack);
+thread.c:    th->tid=0;
+thread.c:    th->esp=0;
+thread.c:    th->ebp=0;
+thread.c:    th->eip=0;
+thread.c:    th->state=EMPTY;
+thread.c:    th->sleepTime=0;
+thread.c:    th->sleepInit=0;
+thread.c:    th->isFirstRun=1;
+thread.c:    th->btf=0;
+thread.c:    th->waitingExitTid=0;
+thread.c:      if(ttable.threads[i]->state==RUNNABLE){
+thread.c:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+thread.c:	ttable.threads[i]->state=RUNNABLE;
+thread.c:    threadsCounter--;
+thread.d:thread.o: thread.c /usr/include/stdc-predef.h types.h thread.h user.h \
+Binary file thread.o matches
+timer.c:// Frequency of all three count-down timers;
+timer.d:timer.o: timer.c /usr/include/stdc-predef.h types.h defs.h traps.h x86.h
+Binary file timer.o matches
+toc.ftr:The source listing is preceded by a cross-reference that lists every defined 
+Binary file trapasm.o matches
+trapasm.S:  # Set up data and per-cpu segments.
+trap.c:  if(tf->trapno == T_SYSCALL){
+trap.c:    if(proc->killed)
+trap.c:    proc->tf = tf;
+trap.c:    if(proc->killed)
+trap.c:  switch(tf->trapno){
+trap.c:      /** if((tf->cs&3) == DPL_USER && proc->alarmTime!=-1 && ticks>=proc->alarmTime+proc->initAlarmTime){ //if returning to user mode!
+trap.c:	proc->alarmTime=-1;
+trap.c:	sigsend(proc->pid, SIGALRM); //send signal!
+trap.c:	//need to send signal!proc-
+trap.c:            cpunum(), tf->cs, tf->eip);
+trap.c:    if(proc == 0 || (tf->cs&3) == 0){
+trap.c:              tf->trapno, cpunum(), tf->eip, rcr2());
+trap.c:            "eip 0x%x addr 0x%x--kill proc\n",
+trap.c:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+trap.c:    proc->killed = 1;
+trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+trap.c:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+trap.d:trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h \
+Binary file trap.o matches
+traps.h:// Processor-defined:
+traps.h:#define T_NMI            2      // non-maskable interrupt
+TRICKS:---
+TRICKS:at that point, cp->tf is set to point to a trap frame
+TRICKS:---
+TRICKS:---
+TRICKS:	if(c->ncli++ == 0)
+TRICKS:		c->intena = eflags & FL_IF;
+TRICKS:Consider a bottom-level pushcli.  
+TRICKS:	c->intena = 1;
+TRICKS:---
+TRICKS:The x86's processor-ordering memory model 
+TRICKS:  - all reads in B see the effects of writes in A.
+TRICKS:  - all reads in A do *not* see the effects of writes in B.
+TRICKS:to memory before the write of lk->locked = 0 in 
+TRICKS:will observe CPU0's write of lk->locked = 0 only
+TRICKS:---
+TRICKS:The code in fork needs to read np->pid before
+TRICKS:setting np->state to RUNNABLE.  The following
+TRICKS:	  np->state = RUNNABLE;
+TRICKS:	  return np->pid; // oops
+TRICKS:After setting np->state to RUNNABLE, some other CPU
+TRICKS:"return np->pid". Even saving a copy of np->pid before
+TRICKS:setting np->state isn't safe, since the compiler is
+TRICKS:allowed to re-order statements.
+TRICKS:The real code saves a copy of np->pid, then acquires a lock
+TRICKS:around the write to np->state. The acquire() prevents the
+TRICKS:compiler from re-ordering.
+uart.c:  // Acknowledge pre-existing interrupt conditions;
+uart.c:    return -1;
+uart.c:    return -1;
+uart.d:uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h \
+Binary file uart.o matches
+ulib.c:  return (uchar)*p - (uchar)*q;
+ulib.c:    return -1;
+ulib.c:    n = n*10 + *s++ - '0';
+ulib.c:  while(n-- > 0)
+ulib.d:ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h \
+Binary file ulib.o matches
+umalloc.c:  bp = (Header*)ap - 1;
+umalloc.c:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+umalloc.c:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+umalloc.c:  if(bp + bp->s.size == p->s.ptr){
+umalloc.c:    bp->s.size += p->s.ptr->s.size;
+umalloc.c:    bp->s.ptr = p->s.ptr->s.ptr;
+umalloc.c:    bp->s.ptr = p->s.ptr;
+umalloc.c:  if(p + p->s.size == bp){
+umalloc.c:    p->s.size += bp->s.size;
+umalloc.c:    p->s.ptr = bp->s.ptr;
+umalloc.c:    p->s.ptr = bp;
+umalloc.c:  if(p == (char*)-1)
+umalloc.c:  hp->s.size = nu;
+umalloc.c:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+umalloc.c:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+umalloc.c:    if(p->s.size >= nunits){
+umalloc.c:      if(p->s.size == nunits)
+umalloc.c:        prevp->s.ptr = p->s.ptr;
+umalloc.c:        p->s.size -= nunits;
+umalloc.c:        p += p->s.size;
+umalloc.c:        p->s.size = nunits;
+umalloc.d:umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h \
+Binary file umalloc.o matches
+Binary file _usertests matches
+usertests.c:// does chdir() call iput(p->cwd) in a transaction?
+usertests.c:// does exit() call iput(p->cwd) in a transaction?
+usertests.c://      return -1;
+usertests.c:      if(n == MAXFILE - 1){
+usertests.c:    printf(1, "link non-existant succeeded! oops\n");
+usertests.c:      i = de.name[1] - '0';
+usertests.c:    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+usertests.c:    printf(1, "unlink non-empty dd succeeded!\n");
+usertests.c:  for(; n > 0; n--){
+usertests.c:  if(wait() != -1){
+usertests.c:    printf(stdout, "sbrk test failed post-fork\n");
+usertests.c:  amt = (BIG) - (uint)a;
+usertests.c:  lastaddr = (char*) (BIG-1);
+usertests.c:  // can one de-allocate?
+usertests.c:  c = sbrk(-4096);
+usertests.c:  if(c != a - 4096){
+usertests.c:  // can one re-allocate that page?
+usertests.c:    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+usertests.c:    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+usertests.c:  c = sbrk(-(sbrk(0) - oldbrk));
+usertests.c:      sbrk(BIG - (uint)sbrk(0));
+usertests.c:    if(pids[i] != -1)
+usertests.c:    if(pids[i] == -1)
+usertests.c:    sbrk(-(sbrk(0) - oldbrk));
+usertests.c:    if(link("nosuchfile", (char*)p) != -1){
+usertests.c:  unlink("bigarg-ok");
+usertests.c:    for(i = 0; i < MAXARG-1; i++)
+usertests.c:    args[MAXARG-1] = 0;
+usertests.c:    fd = open("bigarg-ok", O_CREATE);
+usertests.c:  fd = open("bigarg-ok", 0);
+usertests.c:  unlink("bigarg-ok");
+usertests.c:    nfiles--;
+usertests.c:  read(fd, sbrk(0) - 1, -1);
+usertests.c:    printf(1, "already ran user tests -- rebuild fs.img\n");
+Binary file vectors.o matches
+vectors.pl:#!/usr/bin/perl -w
+vectors.pl:print "# generated by vectors.pl - do not edit\n";
+vectors.S:# generated by vectors.pl - do not edit
+vm.c:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+vm.c:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+vm.c:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+vm.c:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+vm.c:  // Map cpu and proc -- these are private per cpu.
+vm.c:  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+vm.c:  lgdt(c->gdt, sizeof(c->gdt));
+vm.c:  // Initialize cpu-local storage.
+vm.c:// be page-aligned.
+vm.c:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+vm.c:      return -1;
+vm.c:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+vm.c:                (uint)k->phys_start, k->perm) < 0)
+vm.c:// Switch h/w page table register to the kernel-only page table,
+vm.c:  if(p->kstack == 0)
+vm.c:  if(p->pgdir == 0)
+vm.c:  cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
+vm.c:  cpu->gdt[SEG_TSS].s = 0;
+vm.c:  cpu->ts.ss0 = SEG_KDATA << 3;
+vm.c:  cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+vm.c:  cpu->ts.iomb = (ushort) 0xFFFF;
+vm.c:  lcr3(V2P(p->pgdir));  // switch to process's address space
+vm.c:// Load a program segment into pgdir.  addr must be page-aligned
+vm.c:    if(sz - i < PGSIZE)
+vm.c:      n = sz - i;
+vm.c:      return -1;
+vm.c:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+vm.c:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+vm.c:      return -1;
+vm.c:    n = PGSIZE - (va - va0);
+vm.c:    memmove(pa0 + (va - va0), buf, n);
+vm.c:    len -= n;
+vm.d:vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
+Binary file vm.o matches
+Binary file _wc matches
+wc.asm:_wc:     file format elf32-i386
+wc.asm:  ad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+wc.asm:  b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+wc.asm:  de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+wc.asm:  ed:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
+wc.asm: 11a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+wc.asm: 121:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
+wc.asm: 12a:	01 7d dc             	add    %edi,-0x24(%ebp)
+wc.asm: 153:	8b 45 dc             	mov    -0x24(%ebp),%eax
+wc.asm: 15a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+wc.asm: 1a3:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+wc.asm: 1ac:	88 5a ff             	mov    %bl,-0x1(%edx)
+wc.asm:  return (uchar)*p - (uchar)*q;
+wc.asm:  return (uchar)*p - (uchar)*q;
+wc.asm: 2ab:	8d 7d e7             	lea    -0x19(%ebp),%edi
+wc.asm: 2cc:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+wc.asm: 2d7:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+wc.asm:    return -1;
+wc.asm:    return -1;
+wc.asm:    return -1;
+wc.asm: 35a:	8d 42 d0             	lea    -0x30(%edx),%eax
+wc.asm:    n = n*10 + *s++ - '0';
+wc.asm: 36e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+wc.asm: 375:	8d 5a d0             	lea    -0x30(%edx),%ebx
+wc.asm:    n = n*10 + *s++ - '0';
+wc.asm:  while(n-- > 0)
+wc.asm:  while(n-- > 0)
+wc.asm:  while(n-- > 0)
+wc.asm:    x = -xx;
+wc.asm: 49d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+wc.asm: 4a4:	89 75 c0             	mov    %esi,-0x40(%ebp)
+wc.asm:    x = -xx;
+wc.asm: 4ab:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+wc.asm: 4c7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+wc.asm: 4cc:	8b 75 c0             	mov    -0x40(%ebp),%esi
+wc.asm:    buf[i++] = '-';
+wc.asm: 4d6:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+wc.asm:  while(--i >= 0)
+wc.asm: 4db:	8d 79 ff             	lea    -0x1(%ecx),%edi
+wc.asm: 4e0:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+wc.asm: 4f7:	88 45 d7             	mov    %al,-0x29(%ebp)
+wc.asm:    buf[i++] = '-';
+wc.asm:  while(--i >= 0)
+wc.asm:    x = -xx;
+wc.asm: 514:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+wc.asm: 534:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+wc.asm: 551:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+wc.asm: 563:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+wc.asm: 56e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+wc.asm: 5b8:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+wc.asm: 5cf:	89 55 d0             	mov    %edx,-0x30(%ebp)
+wc.asm: 5d2:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+wc.asm: 5db:	8b 55 d0             	mov    -0x30(%ebp),%edx
+wc.asm: 5de:	8d 45 e7             	lea    -0x19(%ebp),%eax
+wc.asm: 5f0:	88 55 e7             	mov    %dl,-0x19(%ebp)
+wc.asm: 5f8:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+wc.asm: 620:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+wc.asm: 63a:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+wc.asm: 648:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+wc.asm: 64b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+wc.asm: 668:	88 45 e3             	mov    %al,-0x1d(%ebp)
+wc.asm: 66b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+wc.asm: 698:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+wc.asm: 6ac:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+wc.asm: 6c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+wc.asm: 6db:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+wc.asm: 6e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+wc.asm: 6f6:	88 45 e4             	mov    %al,-0x1c(%ebp)
+wc.asm: 6f9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+wc.asm: 705:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm: 720:	8d 53 f8             	lea    -0x8(%ebx),%edx
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  if(bp + bp->s.size == p->s.ptr){
+wc.asm: 740:	8b 73 fc             	mov    -0x4(%ebx),%esi
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm: 74a:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm:    p->s.ptr = bp;
+wc.asm:  bp = (Header*)ap - 1;
+wc.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+wc.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+wc.asm:  if(bp + bp->s.size == p->s.ptr){
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm: 76b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm: 772:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm: 77f:	03 4b fc             	add    -0x4(%ebx),%ecx
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm:    p->s.ptr = bp;
+wc.asm:    bp->s.size += p->s.ptr->s.size;
+wc.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+wc.asm:    bp->s.ptr = p->s.ptr;
+wc.asm:  if(p + p->s.size == bp){
+wc.asm:    p->s.size += bp->s.size;
+wc.asm:    p->s.ptr = bp->s.ptr;
+wc.asm: 78a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+wc.asm:    p->s.ptr = bp;
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm: 7d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:        p->s.size = nunits;
+wc.asm: 7f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+wc.asm:  if(p == (char*)-1)
+wc.asm:  hp->s.size = nu;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:      if(p->s.size == nunits)
+wc.asm:        prevp->s.ptr = p->s.ptr;
+wc.asm:        p->s.size -= nunits;
+wc.asm:        p += p->s.size;
+wc.asm:        p->s.size = nunits;
+wc.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+wc.asm:    if(p->s.size >= nunits){
+wc.asm:      if(p->s.size == nunits)
+wc.asm:        prevp->s.ptr = p->s.ptr;
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+wc.asm:    return newThread->tid;
+wc.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+wc.asm:    return newThread->tid;
+wc.asm:    thread->state=RUNNABLE;
+wc.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+wc.asm:    thread->state=RUNNABLE;
+wc.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+wc.asm:	ttable.threads[i]->state=RUNNABLE;
+wc.asm:    thread->state=RUNNABLE;
+wc.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+wc.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+wc.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+wc.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+wc.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+wc.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+wc.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+wc.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+wc.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+wc.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+wc.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+wc.asm:  //1. store tf in the thread->btf
+wc.asm:  *thread->btf = tf;
+wc.asm:  if(nextThread->isFirstRun==1){
+wc.asm:    //move the tf that is stored in nextThread->btf to the stack
+wc.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+wc.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+wc.asm:  nextThread->state=RUNNING;
+wc.asm:  nextThread->isFirstRun=0;
+wc.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+wc.asm:  nextThread->state=RUNNING;
+wc.asm:  nextThread->isFirstRun=0;
+wc.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+wc.asm:    thread->state=RUNNABLE;
+wc.asm:  *thread->btf = tf;
+wc.asm:  if(nextThread->isFirstRun==1){
+wc.asm: a43:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+wc.asm: a4b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+wc.asm:    ntf->esp=nextThread->btf->esp;
+wc.asm:    ntf->eip=nextThread->btf->eip;
+wc.asm:      //ttable.threads[i]->utstack=0;
+wc.asm:      //ttable.threads[i]->tid=0;
+wc.asm:      //ttable.threads[i]->esp=0;
+wc.asm:      //ttable.threads[i]->ebp=0;
+wc.asm:      //ttable.threads[i]->eip=0;
+wc.asm:      ttable.threads[i]->state=EMPTY;
+wc.asm:      //ttable.threads[i]->sleepTime=0
+wc.asm:      //ttable.threads[i]->sleepInit=0;
+wc.asm:      ttable.threads[i]->isFirstRun=1;
+wc.asm:      //ttable.threads[i]->btf=0;
+wc.asm:      //ttable.threads[i]->waitingExitTid=0;
+wc.asm:    thread->tid = threadTidCounter;
+wc.asm:    thread->state = RUNNING;
+wc.asm:      //ttable.threads[i]->btf=0;
+wc.asm:      //ttable.threads[i]->waitingExitTid=0;
+wc.asm:    thread->tid = threadTidCounter;
+wc.asm:    thread->state = RUNNING;
+wc.asm:    thread->tid = threadTidCounter;
+wc.asm:    thread->state = RUNNING;
+wc.asm:        return -1;*/
+wc.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+wc.asm:      //ttable.threads[i]->btf=0;
+wc.asm:      //ttable.threads[i]->waitingExitTid=0;
+wc.asm:    thread->tid = threadTidCounter;
+wc.asm:    thread->state = RUNNING;
+wc.asm:        return -1;*/
+wc.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+wc.asm:      return -1;
+wc.asm:        return -1;*/
+wc.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+wc.asm:      return -1;
+wc.asm:    if (threadNum == MAX_UTHREADS - 1) 
+wc.asm:        return -1;
+wc.asm:      if(ttable.threads[i]->state==EMPTY){
+wc.asm:    newThread->tid = threadTidCounter;
+wc.asm:    newThread->tid = threadTidCounter;
+wc.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+wc.asm:    newThread->tid = threadTidCounter;
+wc.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+wc.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+wc.asm:    esp -= 4;
+wc.asm:    newThread->tid = threadTidCounter;
+wc.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+wc.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+wc.asm:    esp -= 4;
+wc.asm:    esp -= 4;
+wc.asm:    newThread->btf->esp=esp-3*sizeof(int);
+wc.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+wc.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+wc.asm:    esp -= 4;
+wc.asm:    esp -= 4;
+wc.asm:    newThread->btf->esp=esp-3*sizeof(int);
+wc.asm:    newThread->btf->eip=(int)start_func;
+wc.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+wc.asm:    newThread->eip=(int)start_func;//
+wc.asm:    newThread->state = RUNNABLE;
+wc.asm:    return newThread->tid;
+wc.asm:    if (threadNum == MAX_UTHREADS - 1) 
+wc.asm:        return -1;
+wc.asm:    return thread->tid;
+wc.asm:    return thread->tid;
+wc.asm:    return thread->tid;
+wc.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+wc.asm:    return thread->tid;
+wc.asm:      if(ttable.threads[i]->tid==tid){
+wc.asm:      return -1; 
+wc.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+wc.asm:      return -1; 
+wc.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+wc.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+wc.asm:    thread->waitingExitTid=tid;
+wc.asm:    thread->state=BLOCKED;
+wc.asm:      return -1; 
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:	return -1;
+wc.asm:    thread->state=BLOCKED;
+wc.asm:    thread->sleepInit=uptime();
+wc.asm:    thread->sleepTime=ticks;
+wc.asm:	return -1;
+wc.asm:    thread->state=BLOCKED;
+wc.asm:    thread->sleepInit=uptime();
+wc.asm:    thread->sleepTime=ticks;
+wc.asm:	return -1;
+wc.asm:    free(th->utstack);
+wc.asm:    th->tid=0;
+wc.asm:    th->esp=0;
+wc.asm:    th->ebp=0;
+wc.asm:    th->eip=0;
+wc.asm:    th->state=EMPTY;
+wc.asm:    th->sleepTime=0;
+wc.asm:    th->sleepInit=0;
+wc.asm:    th->isFirstRun=1;
+wc.asm:    th->btf=0;
+wc.asm:    th->waitingExitTid=0;
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:    th->isFirstRun=1;
+wc.asm:    th->btf=0;
+wc.asm:    th->waitingExitTid=0;
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+wc.asm:      if(ttable.threads[i]->state==RUNNABLE){
+wc.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+wc.asm:	ttable.threads[i]->state=RUNNABLE;
+wc.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+wc.asm:	ttable.threads[i]->state=RUNNABLE;
+wc.asm:    threadsCounter--;
+wc.asm:    threadsCounter--;
+wc.d:wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file wc.o matches
+x86.h:  pd[0] = size-1;
+x86.h:  pd[0] = size-1;
+x86.h:  // The + in "+m" denotes a read-modify-write operand.
+Binary file xv6.img matches
+Binary file _zombie matches
+zombie.asm:_zombie:     file format elf32-i386
+zombie.asm:  43:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
+zombie.asm:  4c:	88 5a ff             	mov    %bl,-0x1(%edx)
+zombie.asm:  return (uchar)*p - (uchar)*q;
+zombie.asm:  return (uchar)*p - (uchar)*q;
+zombie.asm: 14b:	8d 7d e7             	lea    -0x19(%ebp),%edi
+zombie.asm: 16c:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+zombie.asm: 177:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
+zombie.asm:    return -1;
+zombie.asm:    return -1;
+zombie.asm:    return -1;
+zombie.asm: 1fa:	8d 42 d0             	lea    -0x30(%edx),%eax
+zombie.asm:    n = n*10 + *s++ - '0';
+zombie.asm: 20e:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
+zombie.asm: 215:	8d 5a d0             	lea    -0x30(%edx),%ebx
+zombie.asm:    n = n*10 + *s++ - '0';
+zombie.asm:  while(n-- > 0)
+zombie.asm:  while(n-- > 0)
+zombie.asm:  while(n-- > 0)
+zombie.asm:    x = -xx;
+zombie.asm: 33d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
+zombie.asm: 344:	89 75 c0             	mov    %esi,-0x40(%ebp)
+zombie.asm:    x = -xx;
+zombie.asm: 34b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
+zombie.asm: 367:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+zombie.asm: 36c:	8b 75 c0             	mov    -0x40(%ebp),%esi
+zombie.asm:    buf[i++] = '-';
+zombie.asm: 376:	c6 44 05 d8 2d       	movb   $0x2d,-0x28(%ebp,%eax,1)
+zombie.asm:  while(--i >= 0)
+zombie.asm: 37b:	8d 79 ff             	lea    -0x1(%ecx),%edi
+zombie.asm: 380:	0f b6 44 3d d8       	movzbl -0x28(%ebp,%edi,1),%eax
+zombie.asm: 397:	88 45 d7             	mov    %al,-0x29(%ebp)
+zombie.asm:    buf[i++] = '-';
+zombie.asm:  while(--i >= 0)
+zombie.asm:    x = -xx;
+zombie.asm: 3b4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
+zombie.asm: 3d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+zombie.asm: 3f1:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+zombie.asm: 403:	88 55 e2             	mov    %dl,-0x1e(%ebp)
+zombie.asm: 40e:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+zombie.asm: 458:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+zombie.asm: 46f:	89 55 d0             	mov    %edx,-0x30(%ebp)
+zombie.asm: 472:	c6 45 e6 25          	movb   $0x25,-0x1a(%ebp)
+zombie.asm: 47b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+zombie.asm: 47e:	8d 45 e7             	lea    -0x19(%ebp),%eax
+zombie.asm: 490:	88 55 e7             	mov    %dl,-0x19(%ebp)
+zombie.asm: 498:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
+zombie.asm: 4c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+zombie.asm: 4da:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+zombie.asm: 4e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+zombie.asm: 4eb:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+zombie.asm: 508:	88 45 e3             	mov    %al,-0x1d(%ebp)
+zombie.asm: 50b:	8d 45 e3             	lea    -0x1d(%ebp),%eax
+zombie.asm: 538:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+zombie.asm: 54c:	c6 45 e5 25          	movb   $0x25,-0x1b(%ebp)
+zombie.asm: 560:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+zombie.asm: 57b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+zombie.asm: 584:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+zombie.asm: 596:	88 45 e4             	mov    %al,-0x1c(%ebp)
+zombie.asm: 599:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+zombie.asm: 5a5:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm: 5c0:	8d 53 f8             	lea    -0x8(%ebx),%edx
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+zombie.asm: 5e0:	8b 73 fc             	mov    -0x4(%ebx),%esi
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm: 5ea:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:  bp = (Header*)ap - 1;
+zombie.asm:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+zombie.asm:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+zombie.asm:  if(bp + bp->s.size == p->s.ptr){
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm: 60b:	89 73 fc             	mov    %esi,-0x4(%ebx)
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm: 612:	89 4b f8             	mov    %ecx,-0x8(%ebx)
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm: 61f:	03 4b fc             	add    -0x4(%ebx),%ecx
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:    bp->s.size += p->s.ptr->s.size;
+zombie.asm:    bp->s.ptr = p->s.ptr->s.ptr;
+zombie.asm:    bp->s.ptr = p->s.ptr;
+zombie.asm:  if(p + p->s.size == bp){
+zombie.asm:    p->s.size += bp->s.size;
+zombie.asm:    p->s.ptr = bp->s.ptr;
+zombie.asm: 62a:	8b 53 f8             	mov    -0x8(%ebx),%edx
+zombie.asm:    p->s.ptr = bp;
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm: 678:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:        p->s.size = nunits;
+zombie.asm: 693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+zombie.asm:  if(p == (char*)-1)
+zombie.asm:  hp->s.size = nu;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:      if(p->s.size == nunits)
+zombie.asm:        prevp->s.ptr = p->s.ptr;
+zombie.asm:        p->s.size -= nunits;
+zombie.asm:        p += p->s.size;
+zombie.asm:        p->s.size = nunits;
+zombie.asm:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+zombie.asm:    if(p->s.size >= nunits){
+zombie.asm:      if(p->s.size == nunits)
+zombie.asm:        prevp->s.ptr = p->s.ptr;
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+zombie.asm:    return newThread->tid;
+zombie.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+zombie.asm:    return newThread->tid;
+zombie.asm:    thread->state=RUNNABLE;
+zombie.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+zombie.asm:    thread->state=RUNNABLE;
+zombie.asm:    if(ttable.threads[i]->state==BLOCKED && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit){
+zombie.asm:	ttable.threads[i]->state=RUNNABLE;
+zombie.asm:    thread->state=RUNNABLE;
+zombie.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+zombie.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+zombie.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+zombie.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+zombie.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+zombie.asm:  for(i=0; i<MAX_UTHREADS-1; i++){
+zombie.asm:    if(i!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+zombie.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+zombie.asm:  printf(1, "tf->eip is: %d\n", tf.eip);
+zombie.asm:  printf(1, "tf->esp is: %d\n", tf.esp);
+zombie.asm:  printf(1, "tf->ebp is: %d\n", tf.ebp);
+zombie.asm:  //1. store tf in the thread->btf
+zombie.asm:  *thread->btf = tf;
+zombie.asm:  if(nextThread->isFirstRun==1){
+zombie.asm:    //move the tf that is stored in nextThread->btf to the stack
+zombie.asm:    memmove(&tf, &nextThread->btf,sizeof(struct trapframe));
+zombie.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+zombie.asm:  nextThread->state=RUNNING;
+zombie.asm:  nextThread->isFirstRun=0;
+zombie.asm:    //*(struct trapframe*)(tempEbp+28)=*(nextThread->btf);
+zombie.asm:  nextThread->state=RUNNING;
+zombie.asm:  nextThread->isFirstRun=0;
+zombie.asm:  if(thread->state==RUNNING){ //switch the current thread to RUNNABLE, but only if it's currently running
+zombie.asm:    thread->state=RUNNABLE;
+zombie.asm:  *thread->btf = tf;
+zombie.asm:  if(nextThread->isFirstRun==1){
+zombie.asm: 8e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+zombie.asm: 8eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+zombie.asm:    ntf->esp=nextThread->btf->esp;
+zombie.asm:    ntf->eip=nextThread->btf->eip;
+zombie.asm:      //ttable.threads[i]->utstack=0;
+zombie.asm:      //ttable.threads[i]->tid=0;
+zombie.asm:      //ttable.threads[i]->esp=0;
+zombie.asm:      //ttable.threads[i]->ebp=0;
+zombie.asm:      //ttable.threads[i]->eip=0;
+zombie.asm:      ttable.threads[i]->state=EMPTY;
+zombie.asm:      //ttable.threads[i]->sleepTime=0
+zombie.asm:      //ttable.threads[i]->sleepInit=0;
+zombie.asm:      ttable.threads[i]->isFirstRun=1;
+zombie.asm:      //ttable.threads[i]->btf=0;
+zombie.asm:      //ttable.threads[i]->waitingExitTid=0;
+zombie.asm:    thread->tid = threadTidCounter;
+zombie.asm:    thread->state = RUNNING;
+zombie.asm:      //ttable.threads[i]->btf=0;
+zombie.asm:      //ttable.threads[i]->waitingExitTid=0;
+zombie.asm:    thread->tid = threadTidCounter;
+zombie.asm:    thread->state = RUNNING;
+zombie.asm:    thread->tid = threadTidCounter;
+zombie.asm:    thread->state = RUNNING;
+zombie.asm:        return -1;*/
+zombie.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+zombie.asm:      //ttable.threads[i]->btf=0;
+zombie.asm:      //ttable.threads[i]->waitingExitTid=0;
+zombie.asm:    thread->tid = threadTidCounter;
+zombie.asm:    thread->state = RUNNING;
+zombie.asm:        return -1;*/
+zombie.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+zombie.asm:      return -1;
+zombie.asm:        return -1;*/
+zombie.asm:    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+zombie.asm:      return -1;
+zombie.asm:    if (threadNum == MAX_UTHREADS - 1) 
+zombie.asm:        return -1;
+zombie.asm:      if(ttable.threads[i]->state==EMPTY){
+zombie.asm:    newThread->tid = threadTidCounter;
+zombie.asm:    newThread->tid = threadTidCounter;
+zombie.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+zombie.asm:    newThread->tid = threadTidCounter;
+zombie.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+zombie.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+zombie.asm:    esp -= 4;
+zombie.asm:    newThread->tid = threadTidCounter;
+zombie.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+zombie.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+zombie.asm:    esp -= 4;
+zombie.asm:    esp -= 4;
+zombie.asm:    newThread->btf->esp=esp-3*sizeof(int);
+zombie.asm:    newThread->utstack = (char*) malloc(STACK_SIZE);
+zombie.asm:    int esp = (int)newThread->utstack + STACK_SIZE;
+zombie.asm:    esp -= 4;
+zombie.asm:    esp -= 4;
+zombie.asm:    newThread->btf->esp=esp-3*sizeof(int);
+zombie.asm:    newThread->btf->eip=(int)start_func;
+zombie.asm:    newThread->ebp=(int)newThread->utstack+STACK_SIZE-3*sizeof(int);
+zombie.asm:    newThread->eip=(int)start_func;//
+zombie.asm:    newThread->state = RUNNABLE;
+zombie.asm:    return newThread->tid;
+zombie.asm:    if (threadNum == MAX_UTHREADS - 1) 
+zombie.asm:        return -1;
+zombie.asm:    return thread->tid;
+zombie.asm:    return thread->tid;
+zombie.asm:    return thread->tid;
+zombie.asm:    sigsend(thread->tid,SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+zombie.asm:    return thread->tid;
+zombie.asm:      if(ttable.threads[i]->tid==tid){
+zombie.asm:      return -1; 
+zombie.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+zombie.asm:      return -1; 
+zombie.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+zombie.asm:    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+zombie.asm:    thread->waitingExitTid=tid;
+zombie.asm:    thread->state=BLOCKED;
+zombie.asm:      return -1; 
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:	return -1;
+zombie.asm:    thread->state=BLOCKED;
+zombie.asm:    thread->sleepInit=uptime();
+zombie.asm:    thread->sleepTime=ticks;
+zombie.asm:	return -1;
+zombie.asm:    thread->state=BLOCKED;
+zombie.asm:    thread->sleepInit=uptime();
+zombie.asm:    thread->sleepTime=ticks;
+zombie.asm:	return -1;
+zombie.asm:    free(th->utstack);
+zombie.asm:    th->tid=0;
+zombie.asm:    th->esp=0;
+zombie.asm:    th->ebp=0;
+zombie.asm:    th->eip=0;
+zombie.asm:    th->state=EMPTY;
+zombie.asm:    th->sleepTime=0;
+zombie.asm:    th->sleepInit=0;
+zombie.asm:    th->isFirstRun=1;
+zombie.asm:    th->btf=0;
+zombie.asm:    th->waitingExitTid=0;
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:    th->isFirstRun=1;
+zombie.asm:    th->btf=0;
+zombie.asm:    th->waitingExitTid=0;
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+zombie.asm:      if(ttable.threads[i]->state==RUNNABLE){
+zombie.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+zombie.asm:	ttable.threads[i]->state=RUNNABLE;
+zombie.asm:      if(ttable.threads[i]->waitingExitTid==thread->tid){
+zombie.asm:	ttable.threads[i]->state=RUNNABLE;
+zombie.asm:    threadsCounter--;
+zombie.asm:    threadsCounter--;
+zombie.d:zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
+Binary file zombie.o matches
diff --git a/buf.h b/buf.h
old mode 100644
new mode 100755
diff --git a/cat.c b/cat.c
old mode 100644
new mode 100755
diff --git a/console.c b/console.c
old mode 100644
new mode 100755
diff --git a/csem.c b/csem.c
new file mode 100644
index 0000000..9774a09
--- /dev/null
+++ b/csem.c
@@ -0,0 +1,36 @@
+#include "bsem.h"
+
+struct counting_semaphore{
+    int bsem[2];
+    int value;
+};
+
+struct counting_semaphore *initCsem(int value){
+    struct counting_semaphore* sem = (struct counting_semaphore *) malloc(sizeof(struct counting_semaphore));
+    sem->bsem[0] = bsem_alloc();
+    sem->bsem[1] = bsem_alloc();
+    if(value<1){
+        bsem_down(sem->bsem[1]);
+    }
+    
+    sem->value = value;
+    
+    return sem;
+}
+
+void down(struct counting_semaphore *sem){
+    bsem_down(sem->bsem[1]);
+    bsem_down(sem->bsem[0]);
+    sem->value--;
+    if (sem->value > 0)
+        bsem_up(sem->bsem[1]);
+    bsem_up(sem->bsem[0]);
+}
+
+void up(struct counting_semaphore *sem){
+    bsem_down(sem->bsem[0]);
+    sem->value++;
+    if(sem->value == 1)
+        bsem_up(sem->bsem[1]);
+    bsem_up(sem->bsem[0]);  
+}
diff --git a/csem.h b/csem.h
new file mode 100644
index 0000000..af28352
--- /dev/null
+++ b/csem.h
@@ -0,0 +1,15 @@
+#include "bsem.h"
+
+struct counting_semaphore{
+    int bsem[2];
+    int value;
+};
+
+struct counting_semaphore *initCsem(int value);
+
+void down(struct counting_semaphore *sem);
+
+void up(struct counting_semaphore *sem);
+
+
+
diff --git a/date.h b/date.h
old mode 100644
new mode 100755
diff --git a/defs.h b/defs.h
old mode 100644
new mode 100755
index 300c75c..8c0f8d3
--- a/defs.h
+++ b/defs.h
@@ -116,6 +116,10 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+sighandler_t    signal(int, sighandler_t);
+int             sigsend(int, int);
+int             sigreturn(void);
+int             alarm(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/echo.c b/echo.c
old mode 100644
new mode 100755
diff --git a/elf.h b/elf.h
old mode 100644
new mode 100755
diff --git a/entry.S b/entry.S
old mode 100644
new mode 100755
diff --git a/entryother.S b/entryother.S
old mode 100644
new mode 100755
diff --git a/exec.c b/exec.c
old mode 100644
new mode 100755
diff --git a/fcntl.h b/fcntl.h
old mode 100644
new mode 100755
diff --git a/file.c b/file.c
old mode 100644
new mode 100755
diff --git a/file.h b/file.h
old mode 100644
new mode 100755
diff --git a/forktest.c b/forktest.c
old mode 100644
new mode 100755
diff --git a/fs.c b/fs.c
old mode 100644
new mode 100755
diff --git a/fs.h b/fs.h
old mode 100644
new mode 100755
diff --git a/gdbutil b/gdbutil
old mode 100644
new mode 100755
diff --git a/grep.c b/grep.c
old mode 100644
new mode 100755
diff --git a/ide.c b/ide.c
old mode 100644
new mode 100755
diff --git a/init.c b/init.c
old mode 100644
new mode 100755
diff --git a/initcode.S b/initcode.S
old mode 100644
new mode 100755
diff --git a/ioapic.c b/ioapic.c
old mode 100644
new mode 100755
diff --git a/kalloc.c b/kalloc.c
old mode 100644
new mode 100755
diff --git a/kbd.c b/kbd.c
old mode 100644
new mode 100755
diff --git a/kbd.h b/kbd.h
old mode 100644
new mode 100755
diff --git a/kernel.ld b/kernel.ld
old mode 100644
new mode 100755
diff --git a/kill.c b/kill.c
old mode 100644
new mode 100755
diff --git a/lapic.c b/lapic.c
old mode 100644
new mode 100755
diff --git a/ln.c b/ln.c
old mode 100644
new mode 100755
diff --git a/log.c b/log.c
old mode 100644
new mode 100755
diff --git a/ls.c b/ls.c
old mode 100644
new mode 100755
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
diff --git a/memide.c b/memide.c
old mode 100644
new mode 100755
diff --git a/memlayout.h b/memlayout.h
old mode 100644
new mode 100755
diff --git a/mkdir.c b/mkdir.c
old mode 100644
new mode 100755
diff --git a/mkfs.c b/mkfs.c
old mode 100644
new mode 100755
diff --git a/mmu.h b/mmu.h
old mode 100644
new mode 100755
diff --git a/mp.c b/mp.c
old mode 100644
new mode 100755
diff --git a/mp.h b/mp.h
old mode 100644
new mode 100755
diff --git a/param.h b/param.h
old mode 100644
new mode 100755
diff --git a/picirq.c b/picirq.c
old mode 100644
new mode 100755
diff --git a/pipe.c b/pipe.c
old mode 100644
new mode 100755
diff --git a/printf.c b/printf.c
old mode 100644
new mode 100755
diff --git a/proc.c b/proc.c
old mode 100644
new mode 100755
index 7d03ad7..01d459f
--- a/proc.c
+++ b/proc.c
@@ -7,6 +7,11 @@
 #include "proc.h"
 #include "spinlock.h"
 
+#define  SIGALRM 14
+
+extern int invoke_signal_syscall_start(void);
+extern int invoke_signal_syscall_end(void);
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -19,6 +24,8 @@ extern void forkret(void);
 extern void trapret(void);
 
 static void wakeup1(void *chan);
+void invokeSignal();
+void endInvokeSignal();
 
 void
 pinit(void)
@@ -26,6 +33,11 @@ pinit(void)
   initlock(&ptable.lock, "ptable");
 }
 
+void
+defaultHandler(int sig){
+    cprintf("A signal %d was accepted by process %d", sig, proc->pid);
+}
+
 //PAGEBREAK: 32
 // Look in the process table for an UNUSED proc.
 // If found, change state to EMBRYO and initialize
@@ -36,7 +48,7 @@ allocproc(void)
 {
   struct proc *p;
   char *sp;
-
+  
   acquire(&ptable.lock);
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
@@ -48,8 +60,15 @@ allocproc(void)
 
 found:
   p->state = EMBRYO;
+  p->alarmTime=-1;
   p->pid = nextpid++;
 
+  //set default func to sig handler
+  int i;
+  for(i = 0; i < NUMSIG; i++){
+      p->sigFuncs[i] = &defaultHandler;
+  }
+  
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -82,6 +101,7 @@ void
 userinit(void)
 {
   struct proc *p;
+  
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
@@ -483,3 +503,132 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+sighandler_t
+signal(int signum, sighandler_t handler)
+{
+    if (signum < 1 || signum > 32)
+        return (sighandler_t) -1;
+    
+    sighandler_t oldHandler = proc->sigFuncs[signum-1]; 
+    proc->sigFuncs[signum-1] = handler;   
+    return oldHandler;
+}
+
+int
+sigsend(int pid, int signum)
+{
+    struct proc *p;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if(p->pid == pid) {
+            p->pending= p->pending | (1 << (signum-1)); //set the signal
+            return 0;
+      }
+    }
+    return -1;
+}
+
+
+
+int
+sigreturn(){
+  proc->tf->esp += 4; //set the esp to point to the tf (and skip the sigNum)
+  memmove((void*) proc->tf, (void*) proc->tf->esp, sizeof(struct trapframe)); //save the tf from the stack (located at proc->tf->esp) to the proc's tf
+  proc->isHandlingSignal = 0; 
+  return 0;
+}
+
+
+
+void
+handleSignals(struct trapframe *tf)
+{
+    //handle bad cases- returning to kernel, no proc, no proc pending or already handlingSignal
+    if(!((tf->cs & 3) == DPL_USER) || !proc || !proc->pending || proc->isHandlingSignal) {
+        return;
+    }
+    
+    int sigNum;
+  
+    proc->isHandlingSignal = 1; 
+    for(sigNum = 0; sigNum < NUMSIG; sigNum++) {
+        if(proc->pending & (1 << sigNum)) {    //found the pending signal!
+            proc->pending = proc->pending & ~(1 << sigNum);   // turn off the bit
+            if(proc->sigFuncs[sigNum] == (sighandler_t) defaultHandler) {   //handler is the default handler
+                defaultHandler(sigNum+1);
+                proc->isHandlingSignal = 0;  
+                return;
+            }
+            break;
+        }
+    }
+            
+    int length = (int)(&invoke_signal_syscall_end) - (int)(&invoke_signal_syscall_start);
+    uint temp_esp, offset;
+    temp_esp=proc->tf->esp;
+    //1. push the InvokeSignal
+    temp_esp -= length; 
+    offset = temp_esp; //retAddr
+    memmove((void*)offset, (void*)invoke_signal_syscall_start, length); 
+    //2. push the tf
+    temp_esp -= sizeof(struct trapframe);
+    memmove((struct trapframe*) temp_esp, proc->tf, sizeof(struct trapframe));
+    //3. push the sigNum
+    temp_esp -= 4;
+    *((uint*)temp_esp) = (uint)(sigNum+1); 
+    //4. push the retAddr
+    temp_esp -= 4;
+    *((uint*)temp_esp) = offset; 
+    //set the eip to the handlerand update esp
+    proc->tf->eip = (uint)proc->sigFuncs[sigNum]; 
+    proc->tf->esp = temp_esp;  
+    
+    return;
+    
+    /////////////////
+    ////         ////
+    ////   IS    ////
+    ////         ////
+    /////////////////
+    ////         ////
+    ////   TF    ////
+    ////         ////
+    /////////////////
+    ////         ////
+    //// SigNum  ////
+    ////         ////
+    /////////////////
+    ////         ////
+    //// retAddr ////
+    ////         ////
+    /////////////////
+        
+}
+
+
+int
+alarm(int ticks)
+{
+    if (ticks == 0) {
+        proc->pending = proc->pending & ~(1 << (SIGALRM - 1)); // disable alarm (set the SIGALRM bit off)
+        proc->alarmTime=-1;
+    }
+    proc->alarmTime = ticks;
+    return 0;
+}
+
+void
+updateAlarmTicks()
+{
+    struct proc *p;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state == RUNNABLE || p->state==RUNNING || p->state==SLEEPING){ //update only on active process
+        if(p->alarmTime > 0) { //decrease remaining ticks until alarm
+            p->alarmTime--;
+        }
+        if(p->alarmTime == 1) { //perform the alarm! change pending
+            p->pending = p->pending | 1 << (SIGALRM - 1);   // enable alarm (set the SIGALRM bit on)
+        }
+      }
+    }
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
old mode 100644
new mode 100755
index 7352805..a362f55
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,4 @@
+#define NUMSIG 32
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -57,14 +58,23 @@ struct proc {
   int pid;                     // Process ID
   struct proc *parent;         // Parent process
   struct trapframe *tf;        // Trap frame for current syscall
+  struct trapframe *btf;       // Backup trap frame for current syscall
   struct context *context;     // swtch() here to run process
   void *chan;                  // If non-zero, sleeping on chan
   int killed;                  // If non-zero, have been killed
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int pending;                 // Pending signals
+  void* sigFuncs[NUMSIG];      // Array of pointer to functions
+  int alarmTime;               // time of alarm
+  int initAlarmTime;           // init time of alarm
+  int isHandlingSignal;
+  
 };
 
+void
+updateAlarmTicks();
 // Process memory is laid out contiguously, low addresses first:
 //   text
 //   original data and bss
diff --git a/rm.c b/rm.c
old mode 100644
new mode 100755
diff --git a/runoff.list b/runoff.list
old mode 100644
new mode 100755
diff --git a/runoff.spec b/runoff.spec
old mode 100644
new mode 100755
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..c8d07b8
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,96 @@
+#include "csem.h"
+#include "types.h"
+#include "user.h"
+#include "stat.h"
+
+#define MAX_QUEUE 100
+#define MAX_ITEMS 1000
+
+int queue[MAX_QUEUE];
+
+
+int counterNum = 1;
+int counterObj = 0;
+struct counting_semaphore* producerSem = 0; //will indicate when the 
+struct counting_semaphore* consumerSem = 0;
+struct counting_semaphore* queueSem = 0;
+
+void initSems(){
+    producerSem = initCsem(MAX_QUEUE);
+    consumerSem = initCsem(0);
+    queueSem = initCsem(1);
+}
+
+
+int frontIndex = 0;
+int rearIndex = -1;
+int itemsCount = 0;
+
+
+void insert(int item){
+
+    down(producerSem); //producer will be able to insert to the queue only if the queue isn't full
+    down(queueSem);
+    if(rearIndex==MAX_QUEUE-1){
+        rearIndex = -1;
+    }
+    queue[++rearIndex]=item;
+    itemsCount++;
+    up(queueSem);
+    up(consumerSem);
+}
+
+int remove(){
+    down(consumerSem); //consumer will be able to remove from the queue only if there is at least one item (inserted by the producer)
+    down(queueSem);
+    int item = queue[frontIndex++];
+    if(frontIndex==MAX_QUEUE){
+        frontIndex=0;
+    }
+    itemsCount--;
+    up(queueSem);
+    up(producerSem); 
+    return item;
+}
+
+
+void produce(void *arg) {
+    int i = 0;    
+    for(i = 1; i<=MAX_ITEMS; i++){
+        insert(i);
+        printf(2,"inserted item:%d\n ",i);
+    }
+}
+
+void consume(void *arg) {
+    while(1){
+        int item = remove();
+        printf(2,"removed: %d\n",item);
+        uthread_sleep(item);
+        printf(2, "thread %d ",uthread_self());
+        printf(2, "slept for: %d ticks\n",item);
+        if (item==MAX_ITEMS){
+            printf(1,"exiting...\n");
+            exit();
+        }
+    }
+}
+
+
+int main(int argc, char *argv[]) {
+        initSems();
+	uthread_init();
+	printf(1,"uthread_init - done\n");
+	uthread_create(produce, (void*)555);
+	printf(1,"uthread_create producer - done\n");
+	uthread_create(consume, (void*)555);
+	printf(1,"uthread_create consumer1 - done\n");
+	uthread_create(consume, (void*)555);
+	printf(1,"uthread_create consumer2 - done\n");
+        uthread_create(consume, (void*)555);
+	printf(1,"uthread_create consumer3 - done\n");
+
+        while(1);
+	
+	exit();
+}
\ No newline at end of file
diff --git a/sh.c b/sh.c
old mode 100644
new mode 100755
diff --git a/sleep1.p b/sleep1.p
old mode 100644
new mode 100755
diff --git a/sleeplock.c b/sleeplock.c
old mode 100644
new mode 100755
diff --git a/sleeplock.h b/sleeplock.h
old mode 100644
new mode 100755
diff --git a/spinlock.c b/spinlock.c
old mode 100644
new mode 100755
diff --git a/spinlock.h b/spinlock.h
old mode 100644
new mode 100755
diff --git a/stat.h b/stat.h
old mode 100644
new mode 100755
diff --git a/stressfs.c b/stressfs.c
old mode 100644
new mode 100755
diff --git a/string.c b/string.c
old mode 100644
new mode 100755
diff --git a/swtch.S b/swtch.S
old mode 100644
new mode 100755
diff --git a/symlink.patch b/symlink.patch
old mode 100644
new mode 100755
diff --git a/syscall.c b/syscall.c
old mode 100644
new mode 100755
index 9ae7536..a78fe90
--- a/syscall.c
+++ b/syscall.c
@@ -98,6 +98,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_signal(void);
+extern int sys_sigsend(void);
+extern int sys_sigreturn(void);
+extern int sys_alarm(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +125,10 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_signal]  sys_signal,
+[SYS_sigsend] sys_sigsend,
+[SYS_sigreturn] sys_sigreturn,
+[SYS_alarm]   sys_alarm,
 };
 
 void
diff --git a/syscall.h b/syscall.h
old mode 100644
new mode 100755
index bc5f356..00c9b11
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_signal 22
+#define SYS_sigsend 23
+#define SYS_sigreturn 24
+#define SYS_alarm 25
\ No newline at end of file
diff --git a/sysfile.c b/sysfile.c
old mode 100644
new mode 100755
diff --git a/sysproc.c b/sysproc.c
old mode 100644
new mode 100755
index 6b585e0..2f6354b
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,45 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_signal(void)
+{
+    int signum;
+    sighandler_t handler;
+    if ((argint(0, &signum) < 0) || argptr(1, (void*) &handler, sizeof(handler)) < 0)
+        return -1;
+    return (int) signal(signum, handler);
+}
+
+int 
+sys_sigsend(void)
+{
+    int pid;
+    int signum;
+    if((argint(0,&pid) < 0) || (argint(1, &signum) < 0))
+        return -1;
+    return sigsend(pid,signum);
+}
+
+
+int 
+sys_sigreturn(void){
+    return sigreturn();
+}
+
+
+int
+sys_alarm(void){
+    int pticks;
+    if(argint(0,&pticks) < 0)
+    {
+        return -1;
+    }
+    return alarm(pticks);
+}
+
+
+
+
+
diff --git a/thread.c b/thread.c
new file mode 100755
index 0000000..3b11497
--- /dev/null
+++ b/thread.c
@@ -0,0 +1,312 @@
+#include "types.h"
+#include "thread.h"
+#include "user.h"
+#include "x86.h"
+
+
+
+
+struct thtable{
+    struct thread* threads[MAX_UTHREADS];
+};
+
+static struct thtable ttable;
+
+struct thread* thread; //points to the current thread
+int threadTidCounter = 0;
+int lastThreadTableIndex = 0;
+int threadsCounter =0;
+
+
+int
+uthread_init(){
+    alarm(0); //disable context switching while inside uthread_schedule
+    int i;
+    for(i=0; i<MAX_UTHREADS; i++){
+        ttable.threads[i]=malloc(sizeof(struct thread));
+    }
+
+    //initialize the threads table:
+    for (i = 0; i<MAX_UTHREADS; i++){
+      ttable.threads[i]->state=EMPTY;
+      ttable.threads[i]->isFirstRun=1;
+      ttable.threads[i]->tid=-1;
+      ttable.threads[i]->lockUp=-1;
+      ttable.threads[i]->waitingExitTid=-1;
+      ttable.threads[i]->btf=malloc(sizeof(struct trapframe));
+    }
+
+    thread = ttable.threads[threadTidCounter]; //threadTidCounter=0 at this point
+
+    thread->tid = threadTidCounter;
+    thread->state = RUNNING;
+    
+    threadTidCounter++;
+    threadsCounter++;
+    
+    //make sure the maing thread returns to uthread_exit
+    int ebp_val;
+    asm("movl %%ebp, %0" : "=r"(ebp_val));
+    int prevEbp = *(int*)ebp_val;
+    int retAddr = prevEbp+12; 
+    *(int*)retAddr = (int)uthread_exit;
+    
+    if(signal(SIGALRM, uthread_schedule)==(sighandler_t)-1){
+      return -1;
+    }
+    
+    alarm(UTHREAD_QUANTA);
+    return 0;
+}
+
+
+
+int 
+uthread_create(void (*start_func)(void*), void* arg){
+    alarm(0); //disable context switching while inside uthread_schedule //disable context switching threads
+    if (threadsCounter == MAX_UTHREADS - 1) 
+        return -1;
+    
+    //loop over the threads table until finding a cell that is "empty" (start from smallest)
+    int i;
+    for(i=0; i<MAX_UTHREADS; i++){
+      if(ttable.threads[i]->state==EMPTY){
+	break;
+      }
+    }
+    ttable.threads[i]->tid = threadTidCounter;
+    threadTidCounter++;
+    threadsCounter++;
+    ttable.threads[i]->utstack = (char*) malloc(STACK_SIZE);
+
+    int esp = (int)ttable.threads[i]->utstack + STACK_SIZE;
+    esp -= 4;
+    *(int*)esp=(int)arg;
+    esp -= 4;
+    *(int*)esp = (int)uthread_exit;
+    ttable.threads[i]->esp=esp;
+    ttable.threads[i]->ebp=esp;
+    ttable.threads[i]->eip=(int)start_func;
+    
+    ttable.threads[i]->state = RUNNABLE;
+    ttable.threads[i]->isFirstRun=1;
+
+    alarm(UTHREAD_QUANTA);
+    return ttable.threads[i]->tid;
+}
+
+
+
+void
+uthread_schedule(int sigNum, struct trapframe tf){
+  alarm(0); //disable context switching while inside uthread_schedule //disable context switching while inside uthread_schedule
+  if(thread->state==RUNNING){ 
+    thread->state=RUNNABLE;
+  }
+
+  //wakeup sleeping threads whose sleeping time finished (but not waiting for semaphore!!
+  int i;
+  for(i=0; i<MAX_UTHREADS; i++){
+      
+    /** if(ttable.threads[i]->state==EMPTY && ttable.threads[i]->btf!=0){
+        free(ttable.threads[i]->btf);
+        ttable.threads[i]->btf=0;
+    } */
+    //free memory
+    if(ttable.threads[i]->state==EMPTY){
+        if(ttable.threads[i]->btf!=0){
+            free(ttable.threads[i]->btf);
+            ttable.threads[i]->btf=0;
+        }
+        if(ttable.threads[i]->utstack!=0){
+            free(ttable.threads[i]->utstack);
+            ttable.threads[i]->utstack=0;
+        }
+    }
+    if(ttable.threads[i]->state==BLOCKED
+        && uptime()>=ttable.threads[i]->sleepTime+ttable.threads[i]->sleepInit && ttable.threads[i]->lockUp == -1 && ttable.threads[i]->waitingExitTid == -1)
+    {
+	ttable.threads[i]->state=RUNNABLE;
+    }
+  }
+  
+  //choose a new thread according to ROUND ROBIN
+  int j=(lastThreadTableIndex+1)%MAX_UTHREADS;
+  int foundLiveThread=0;
+  for(i=0; i<MAX_UTHREADS; i++){
+    if(j!=lastThreadTableIndex && ttable.threads[j]->state==RUNNABLE){
+	foundLiveThread=1;
+	break;
+    }
+    j=(j+1)%MAX_UTHREADS;
+  }
+  
+  lastThreadTableIndex=j;
+
+  if(!foundLiveThread){ 
+      sigsend(getpid(),SIGALRM); 
+      return;
+  }
+  
+  //1. store tf in the thread->btf
+  thread->isFirstRun=0;
+  *thread->btf = tf;
+  
+  if(ttable.threads[j]->isFirstRun==1){
+    //we create a clone of tf
+    struct trapframe* ntf;
+    ntf = malloc(sizeof(struct trapframe));
+    *ntf = tf;
+    ntf->esp=ttable.threads[j]->esp;
+    ntf->eip=ttable.threads[j]->eip;
+    //move the tf that we cloned (ntf) to the stack
+    ttable.threads[j]->isFirstRun=0;
+    memmove(&tf, ntf, sizeof(struct trapframe));
+  }
+  else{
+    //move the tf that is stored in nextThread->btf to the stack
+    memmove(&tf, ttable.threads[j]->btf,sizeof(struct trapframe));
+  }
+  ttable.threads[j]->state=RUNNING;
+ 
+  
+  for(i = 0; i<MAX_UTHREADS; i++){
+      if(ttable.threads[i]->tid != ttable.threads[j]->tid && ttable.threads[i]->state == RUNNING)
+         ttable.threads[i]->state=RUNNABLE; 
+  }
+  
+  
+  thread=ttable.threads[j];
+  alarm(UTHREAD_QUANTA);
+  
+  return;
+}
+
+
+int uthread_self(){
+    return thread->tid;
+}
+
+int uthread_join(int tid){
+    alarm(0); //disable context switching while inside uthread_schedule
+    int i,foundThread=0;
+    for(i=0; i<MAX_UTHREADS; i++){
+      if(ttable.threads[i]->tid==tid){
+	foundThread=1;
+	break;
+      }
+    }
+    
+    if(foundThread==0){ //couldn't find requested thread
+      return -1; 
+    }
+    else if(ttable.threads[i]->state==EMPTY){ //thread already terminated!
+      return 0; 
+    }
+    
+    //otherwise, set current thread to wait for specified tid
+    thread->waitingExitTid=tid;
+    thread->state=BLOCKED;
+    
+    //give up runtime
+    uthread_yield();
+
+    return 0;
+}
+
+int uthread_sleep(int ticks){
+    alarm(0); //disable context switching while inside uthread_schedule
+    
+    
+    int i, foundLiveThread=0;
+    for(i=0; i<MAX_UTHREADS; i++){
+      if(ttable.threads[i]->state==RUNNABLE){
+	foundLiveThread=1;
+      }
+    }
+    
+    if(foundLiveThread==0){ //couldn't go to sleep, because there is no other thread that can run!!!
+	return -1;
+    }
+    
+    thread->state=BLOCKED;
+    thread->sleepInit=uptime();
+    thread->sleepTime=ticks;
+    
+    uthread_yield();
+    
+    return 0;
+}
+
+
+//gives up CPU and 
+void
+uthread_yield(){
+    alarm(0); //disable context switching while inside uthread_schedule
+    sigsend(getpid(),SIGALRM); //force signal to be sent, which will be handled by uthread_schedule as we set in uthread_init
+				  //this will happen when we return from the kernel to the usermode
+    alarm(UTHREAD_QUANTA);
+}
+
+
+void 
+uthread_exit(){
+    alarm(0); //disable context switching while inside uthread_schedule
+    int i, foundLiveThread=0,isAllAsleep=1;
+    for(i=0; i<MAX_UTHREADS; i++){
+      if(ttable.threads[i]->tid!=thread->tid && ttable.threads[i]->state!=BLOCKED){
+          isAllAsleep=0;
+      }
+      if(ttable.threads[i]->state==RUNNABLE){
+	foundLiveThread=1;
+      }
+      if(ttable.threads[i]->waitingExitTid==thread->tid){ //if a thread is waiting for this thread to exit, wake it up!
+        ttable.threads[i]->waitingExitTid=-1;
+	ttable.threads[i]->state=RUNNABLE;
+      }
+    }
+        
+    if(isAllAsleep==1){ //if all threads are sleeping besides current thread,
+        uthread_sleep(UTHREAD_QUANTA);
+        sigsend(getpid(),SIGALRM);
+    }
+    
+    threadsCounter--;
+    
+    if(foundLiveThread==0){ 
+      //sigsend(getpid(),SIGALRM); 
+      exit();
+    }
+    
+    
+    thread->state=EMPTY;
+    thread->isFirstRun=1;
+    thread->waitingExitTid=-1;
+    thread->tid=-1;
+    
+    
+    sigsend(getpid(),SIGALRM);
+    
+}
+
+struct thread* getCurrThread(){
+    return thread;
+}
+
+
+//wakeup one thread waiting for semaphore 
+void bsem_wakeUp(int desc){
+        int i;
+        for(i=0; i<MAX_UTHREADS; i++){
+            if(ttable.threads[i]->lockUp==desc){
+                ttable.threads[i]->lockUp=-1;
+                ttable.threads[i]->state=RUNNABLE;
+                break;
+            }
+        }
+
+}
+
+
+
+
diff --git a/thread.h b/thread.h
new file mode 100755
index 0000000..23dac02
--- /dev/null
+++ b/thread.h
@@ -0,0 +1,37 @@
+#define MAX_UTHREADS 64
+#define STACK_SIZE 4096
+#define SIGALRM 14
+#define UTHREAD_QUANTA 5
+
+void uthread_schedule();
+int uthread_init();
+void wrap_entry(void (*start_func)(void*), void* arg);
+int uthread_create(void (*start_func)(void*), void* arg);
+int uthread_self();
+int uthread_join(int tid);
+int uthread_sleep(int ticks);
+void uthread_exit();
+void uthread_yield();
+struct thread* getCurrThread();
+void bsem_wakeUp(int desc);
+
+
+typedef enum {EMPTY, RUNNING, RUNNABLE, BLOCKED} thread_state;
+
+
+struct thread{
+    int tid;                //thread id
+    int esp;
+    int ebp;
+    int eip;
+    int lockUp;
+    thread_state state;
+    int sleepTime;
+    int sleepInit;
+    int isFirstRun;
+    struct trapframe* btf;
+    int waitingExitTid;
+    char* utstack;          //user thread stack
+};
+
+
diff --git a/timer.c b/timer.c
old mode 100644
new mode 100755
diff --git a/toc.ftr b/toc.ftr
old mode 100644
new mode 100755
diff --git a/toc.hdr b/toc.hdr
old mode 100644
new mode 100755
diff --git a/trap.c b/trap.c
old mode 100644
new mode 100755
index e6b3784..876a28e
--- a/trap.c
+++ b/trap.c
@@ -8,6 +8,7 @@
 #include "traps.h"
 #include "spinlock.h"
 
+#define  SIGALRM 14
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
@@ -53,6 +54,7 @@ trap(struct trapframe *tf)
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
+      updateAlarmTicks();
     }
     lapiceoi();
     break;
diff --git a/trapasm.S b/trapasm.S
old mode 100644
new mode 100755
index 787727f..4a86940
--- a/trapasm.S
+++ b/trapasm.S
@@ -26,6 +26,9 @@ alltraps:
   # Return falls through to trapret...
 .globl trapret
 trapret:
+  pushl %esp
+  call handleSignals
+  addl $4, %esp
   popal
   popl %gs
   popl %fs
@@ -33,3 +36,12 @@ trapret:
   popl %ds
   addl $0x8, %esp  # trapno and errcode
   iret
+
+.globl invoke_signal_syscall_start
+.globl invoke_signal_syscall_end
+
+ # perform sigreturn system call
+invoke_signal_syscall_start:
+  movl $24, %eax 
+  int $64
+invoke_signal_syscall_end:
\ No newline at end of file
diff --git a/traps.h b/traps.h
old mode 100644
new mode 100755
diff --git a/types.h b/types.h
old mode 100644
new mode 100755
index e4adf64..a98cb25
--- a/types.h
+++ b/types.h
@@ -2,3 +2,4 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+typedef void (*sighandler_t)(int);
diff --git a/uart.c b/uart.c
old mode 100644
new mode 100755
diff --git a/ulib.c b/ulib.c
old mode 100644
new mode 100755
diff --git a/umalloc.c b/umalloc.c
old mode 100644
new mode 100755
diff --git a/user.h b/user.h
old mode 100644
new mode 100755
index f45b8d5..5d4e88f
--- a/user.h
+++ b/user.h
@@ -23,6 +23,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+sighandler_t signal(int, sighandler_t);
+int sigsend(int, int);
+int sigreturn(void);
+int alarm(int);
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usertests.c b/usertests.c
old mode 100644
new mode 100755
diff --git a/usys.S b/usys.S
old mode 100644
new mode 100755
index 8bfd8a1..7124928
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(signal)
+SYSCALL(sigsend)
+SYSCALL(sigreturn)
+SYSCALL(alarm)
diff --git a/vm.c b/vm.c
old mode 100644
new mode 100755
diff --git a/wc.c b/wc.c
old mode 100644
new mode 100755
diff --git a/x86.h b/x86.h
old mode 100644
new mode 100755
index 07312a5..0a08dd0
--- a/x86.h
+++ b/x86.h
@@ -1,5 +1,5 @@
 // Routines to let C code use special x86 instructions.
-
+struct trapframe;
 static inline uchar
 inb(ushort port)
 {
diff --git a/zombie.c b/zombie.c
old mode 100644
new mode 100755
